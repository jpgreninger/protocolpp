<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++&reg; (Protocolpp&reg;): jsnow3g Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++&reg; (Protocolpp&reg;)
   &#160;<span id="projectnumber">v5.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classjsnow3g.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">jsnow3g Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;include/jsnow3g.h&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="SNOWESNOWE"></a>
Snow3g Stream Cipher</h1>
<dl class="section see"><dt>See also</dt><dd>Specification of the 3GPP Confidentiality and Integrity Algorithms UEA2 and UIA2 Document 2: SNOW 3G Specification</dd></dl>
<p>SNOW 3G is a word-oriented stream cipher that generates a sequence of 32-bit words under the control of a 128-bit key and a 128-bit initialisation variable. These words can be used to mask the plaintext. First a key initialisation is performed, i.e. the cipher is clocked without producing output, see 4.1. Then with every clock tick it produces a 32-bit word of output</p>
<p><b>Functions used in different Components of SNOW 3G</b></p>
<p><b>MULx</b> maps 16 bits to 8 bits. Let V and c be 8-bit input values. Then MULx is defined:</p>
<p>If the leftmost (i.e. the most significant) bit of V equals 1, then</p>
<p><img class="formulaInl" alt="$ MULx(V, c) = (V &lt;&lt;_8 1) \oplus c, else MULx(V, c) = V &lt;&lt;_8 1$" src="form_149.png"/></p>
<p><b>MULxPOW</b> maps 16 bits and an positive integer i to 8 bit. Let V and c be 8-bit input values, then MULxPOW(V, i, c) is recursively defined:</p>
<p>If i equals 0, then <img class="formulaInl" alt="$ MULxPOW(V, i, c) = V$" src="form_150.png"/>, else <img class="formulaInl" alt="$ MULxPOW(V, i, c) = MULx(MULxPOW(V, i-1, c), c)$" src="form_151.png"/></p>
<p><b>Linear Feedback Shift Register (LFSR)</b></p>
<p>The Linear Feedback Shift Register (LFSR) consists of sixteen stages <img class="formulaInl" alt="$ s_0, s_1, s_2,\cdots, s_{15}$" src="form_152.png"/> each holding 32 bits</p>
<p><b>Finite State Machine (FSM)</b></p>
<p>The Finite State Machine (FSM) has three 32-bit registers R1, R2 and R3. The S-boxes S1 and S2 are used to update the registers R2 and R3</p>
<p><b>The 32x32-bit S-Box S1</b></p>
<p>The S-Box <img class="formulaInl" alt="$ S_1$" src="form_121.png"/> maps a 32-bit input to a 32-bit output. Let <img class="formulaInl" alt="$ w = w_0 || w_1 || w_2 || w_3$" src="form_153.png"/> the 32-bit input with <img class="formulaInl" alt="$ w_0$" src="form_154.png"/> the most and <img class="formulaInl" alt="$ w3$" src="form_155.png"/> the least significant byte</p>
<p>Let <img class="formulaInl" alt="$ S_1(w)= r_0 || r_1 || r_2 || r_3$" src="form_156.png"/> with <img class="formulaInl" alt="$ r_0$" src="form_157.png"/> the most and <img class="formulaInl" alt="$ r_3$" src="form_158.png"/> the least significant byte. We use the 8 to 8 bit Rijndael S-Box <img class="formulaInl" alt="$ S_R$" src="form_159.png"/> defined in 5.1</p>
<p>Then <img class="formulaInl" alt="$ r_0, r_1, r_2, r_3$" src="form_160.png"/> are defined as</p>
<p><img class="formulaInl" alt="$ r_0= MULx(S_R(w_0), 0x1B) \oplus S_R(w_1) \oplus S_R(w_2) \oplus MULx(S_R(w_3), 0x1B) \oplus S_R(w_3)$" src="form_161.png"/></p>
<p><img class="formulaInl" alt="$ r_1= MULx(S_R(w_0), 0x1B) \oplus S_R(w_0) \oplus MULx(S_R(w_1), 0x1B) \oplus S_R(w_2) \oplus S_R(w_3)$" src="form_162.png"/></p>
<p><img class="formulaInl" alt="$ r_2= S_R(w_0) \oplus MULx(S_R(w_1), 0x1B) \oplus S_R(w_1) \oplus MULx(S_R(w_2), 0x1B) \oplus S_R(w_3)$" src="form_163.png"/></p>
<p><img class="formulaInl" alt="$ r_3= S_R(w_0) \oplus S_R(w_1) \oplus MULx(S_R(w_2), 0x1B) \oplus S_R(w_2) \oplus MULx(S_R(w_3), 0x1B)$" src="form_164.png"/></p>
<p><b>The 32x32-bit S-Box S2</b></p>
<p>The S-Box <img class="formulaInl" alt="$ S_2$" src="form_165.png"/> maps a 32-bit input to a 32-bit output. Let <img class="formulaInl" alt="$ w = w_0 || w_1 || w_2 || w_3$" src="form_153.png"/> the 32-bit input with <img class="formulaInl" alt="$ w_0$" src="form_154.png"/> the most and <img class="formulaInl" alt="$ w_3$" src="form_166.png"/> the least significant byte. Let <img class="formulaInl" alt="$ S_2(w)= r_0 || r_1 || r_2 || r_3$" src="form_167.png"/> with <img class="formulaInl" alt="$ r0$" src="form_168.png"/> the most and <img class="formulaInl" alt="$ r3$" src="form_169.png"/> the least significant byte. We use the 8 to 8 bit S-Box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/> defined in 5.2</p>
<p>Then <img class="formulaInl" alt="$ r_0, r_1, r_2, r_3$" src="form_160.png"/> are defined as</p>
<p><img class="formulaInl" alt="$ r_0= MULx(S_Q(w_0), 0x69) \oplus S_Q(w_1) \oplus S_Q(w_2) \oplus MULx(S_Q(w_3), 0x69) \oplus SQ(w3)$" src="form_171.png"/></p>
<p><img class="formulaInl" alt="$ r_1= MULx(S_Q(w_0), 0x69) \oplus S_Q(w_0) \oplus MULx(S_Q(w_1), 0x69) \oplus S_Q(w_2) \oplus S_Q(w_3)$" src="form_172.png"/></p>
<p><img class="formulaInl" alt="$ r_2= S_Q(w_0) \oplus MULx(S_Q(w_1), 0x69) \oplus S_Q(w_1) \oplus MULx(S_Q(w_2), 0x69) \oplus S_Q(w_3)$" src="form_173.png"/></p>
<p><img class="formulaInl" alt="$ r_3= S_Q(w_0) \oplus S_Q(w_1) \oplus MULx(S_Q(w_2), 0x69) \oplus S_Q(w_2) \oplus MULx(S_Q(w_3), 0x69)$" src="form_174.png"/></p>
<h1><a class="anchor" id="TCOPSnow3G"></a>
The Clocking Operations</h1>
<p><b>Clocking the LFSR</b></p>
<p>The clocking of the LFSR has two different modes of operation, the Initialisation Mode 3.4.4 and the Keystream Mode 3.4.5. In both modes the functions <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> and <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> are used which are defined in 3.4.2 resp. 3.4.3</p>
<p><b>The function <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/></b></p>
<p>The function <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> maps 8 bits to 32 bits. Let c be the 8-bit input, then <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> is defined as</p>
<p><img class="formulaInl" alt="$ MUL_α(c) = (MULxPOW(c, 23, 0xA9) || MULxPOW(c, 245, 0xA9) || MULxPOW(c, 48, 0xA9) || MULxPOW(c, 239, 0xA9))$" src="form_177.png"/></p>
<p><b>The function <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/></b></p>
<p>The function <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> maps 8 bits to 32 bits. Let c be the 8-bit input, then <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> is defined as</p>
<p><img class="formulaInl" alt="$ DIV_α(c) = (MULxPOW(c, 16, 0xA9) || MULxPOW(c, 39, 0xA9) || MULxPOW(c, 6, 0xA9) || MULxPOW(c, 64, 0xA9))$" src="form_178.png"/></p>
<p><b>Initialisation Mode</b></p>
<p>In the Initialisation Mode the LFSR receives a 32-bit input word F, which is the output of the FSM</p>
<p>Let <img class="formulaInl" alt="$ s_0 = s_{0,0} || s_{0,1} || s_{0,2} || s_{0,3}$" src="form_179.png"/> with <img class="formulaInl" alt="$ s_{0,0}$" src="form_180.png"/> being the most and <img class="formulaInl" alt="$ s_{0,3}$" src="form_181.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_0$" src="form_182.png"/>.</p>
<p>Let <img class="formulaInl" alt="$ s_{11} = s_{11,0} || s_{11,1} || s_{11,2} || s_{11,3}$" src="form_183.png"/> with <img class="formulaInl" alt="$ s_{11,0}$" src="form_184.png"/> being the most and <img class="formulaInl" alt="$ s_{11,3}$" src="form_185.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_{11}$" src="form_186.png"/></p>
<p>Compute the intermediate value v as</p>
<p><img class="formulaInl" alt="$ v = (s_{0,1} || s_{0,2} || s_{0,3} || 0x00) \oplus MUL_α(s_{0,0}) \oplus s_2 \oplus (0x00 || s_{11,0} || s_{11,1} || s_{11,2}) \oplus DIV_α(s_{11,3}) \oplus F$" src="form_187.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ s_0=s_1, s_1=s_2, s_2=s_3, s_3=s_4, s_4=s_5, s_5=s_6, s_6=s_7, s_7=s_8$" src="form_188.png"/></p>
<p><img class="formulaInl" alt="$ s_8=s_9, s_9=s_{10}, s_{10}=s_{11}, s_{11}=s_{12}, s_{12}=s_{13}, s_{13}=s_{14}, s_{14}=s_{15}, s_{15} = v$" src="form_189.png"/></p>
<p><b>Keystream Mode</b></p>
<p>In the Keystream Mode the LFSR does not receive any input</p>
<p>Let <img class="formulaInl" alt="$ s_0 = s_{0,0} || s_{0,1} || s_{0,2} || s_{0,3}$" src="form_179.png"/> with <img class="formulaInl" alt="$ s_{0,0}$" src="form_180.png"/> being the most and <img class="formulaInl" alt="$ s_{0,3}$" src="form_181.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_0$" src="form_182.png"/></p>
<p>Let <img class="formulaInl" alt="$ s_11 = s_{11,0} || s_{11,1} || s_{11,2} || s_{11,3}$" src="form_190.png"/> with <img class="formulaInl" alt="$ s_{11,0}$" src="form_184.png"/> being the most and <img class="formulaInl" alt="$ s_{11,3}$" src="form_185.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_11$" src="form_191.png"/></p>
<p>Compute the intermediate value v as</p>
<p>v = <img class="formulaInl" alt="$ (s_{0,1} || s_{0,2} || s_{0,3} || 0x00) \oplus MUL_α(s_{0,0}) \oplus s_2 \oplus (0x00 || s_{11,0} || s_{11,1} || s_{11,2}) \oplus DIV_α(s_{11,3})$" src="form_192.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ s_0=s_1, s_1=s_2, s_2=s_3, s_3=s_4, s_4=s_5, s_5=s_6, s_6=s_7, s_7=s_8$" src="form_188.png"/></p>
<p><img class="formulaInl" alt="$ s_8=s_9, s_9=s_{10}, s_{10}=s_{11}, s_{11}=s_{12}, s_{12}=s_{13}, s_{13}=s_{14}, s_{14}=s_{15}, s_{15}=v$" src="form_193.png"/></p>
<p><b>Clocking the FSM</b></p>
<p>The FSM has two input words <img class="formulaInl" alt="$ s_{15}$" src="form_194.png"/> and <img class="formulaInl" alt="$ s_5$" src="form_195.png"/> from the LFSR. It produces a 32-bit output word F:</p>
<p><img class="formulaInl" alt="$ F = (s_{15} \oplus R1) \oplus R2$" src="form_196.png"/></p>
<p>Then the registers are updated. Compute the intermediate value r as</p>
<p><img class="formulaInl" alt="$ r = R2 \oplus (R3 \oplus s_5)$" src="form_197.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ R3 = S_2(R2)$" src="form_198.png"/></p>
<p><img class="formulaInl" alt="$ R2 = S_1(R1)$" src="form_199.png"/></p>
<p><img class="formulaInl" alt="$ R1 = r$" src="form_200.png"/></p>
<h1><a class="anchor" id="OPSnow3GSnow3G"></a>
Operation of SNOW 3G</h1>
<p><b>Initialisation</b></p>
<p>SNOW 3G is initialized with a 128-bit key consisting of four 32-bit words <b> <img class="formulaInl" alt="$ k_0, k_1, k_2, k_3$" src="form_201.png"/></b> and an 128-bit initialisation variable consisting of four 32-bit words <b> <img class="formulaInl" alt="$ IV_0, IV_1, IV_2, IV_3$" src="form_202.png"/></b> as follows</p>
<p>Let <b>1</b> be the all-ones word (0xffffffff)</p>
<p><img class="formulaInl" alt="$ s_{15}=k_3 \oplus IV_0$" src="form_203.png"/></p>
<p><img class="formulaInl" alt="$ s_{14}=k_2$" src="form_204.png"/></p>
<p><img class="formulaInl" alt="$ s_{13}=k_1$" src="form_205.png"/></p>
<p><img class="formulaInl" alt="$ s_{12}=k_0 \oplus IV_1$" src="form_206.png"/></p>
<p><img class="formulaInl" alt="$ s_{11}=k_3 \oplus 1$" src="form_207.png"/></p>
<p><img class="formulaInl" alt="$ s_{10}=k_2 \oplus 1 \oplus IV_2 s_9 = k_1 \oplus 1 \oplus IV_3 s_8 = k_0 \oplus 1$" src="form_208.png"/></p>
<p><img class="formulaInl" alt="$ s_7=k_3$" src="form_209.png"/></p>
<p><img class="formulaInl" alt="$ s_6=k_2$" src="form_210.png"/></p>
<p><img class="formulaInl" alt="$ s_5=k_1$" src="form_211.png"/></p>
<p><img class="formulaInl" alt="$ s_4=k_0$" src="form_212.png"/></p>
<p><img class="formulaInl" alt="$ s_3=k_3 \oplus 1$" src="form_213.png"/></p>
<p><img class="formulaInl" alt="$ s_2=k_2 \oplus 1$" src="form_214.png"/></p>
<p><img class="formulaInl" alt="$ s_1=k_1 \oplus 1$" src="form_215.png"/></p>
<p><img class="formulaInl" alt="$ s_0=k_0 \oplus 1$" src="form_216.png"/></p>
<p>The FSM is initialised with <img class="formulaInl" alt="$ R1 = R2 = R3 = 0$" src="form_217.png"/></p>
<p>Then the cipher runs in a special mode without producing output:</p>
<p>repeat 32-times {</p>
<p>STEP 1: The FSM is clocked (see 3.4.6) producing the 32-bit word F</p>
<p>STEP 2: Then the LFSR is clocked in Initialisation Mode (see 3.4.4) consuming F</p>
<p>}</p>
<div class="image">
<img src="Snow3GDuringInit.png" alt=""/>
<div class="caption">
Snow 3G Algorithm During Initialization</div></div>
 <p><b>Generation of Keystream</b></p>
<p>First the FSM is clocked once, see 3.4.6. The output word of the FSM is discarded. Then the LFSR is clocked once in Keystream Mode, see 3.4.4</p>
<p>After that n 32-bit words of keystream are produced:</p>
<p>for t = 1 to n {</p>
<p>STEP 1: The FSM is clocked (see 3.4.6) and produces a 32-bit output word F</p>
<p>STEP 2: The next keystream word is computed as <img class="formulaInl" alt="$ z_t = F \oplus s_0$" src="form_218.png"/></p>
<p>STEP 3: Then the LFSR is clocked in Keystream Mode, see 3.4.4</p>
<p>}</p>
<div class="image">
<img src="Snow3GDuringKeyStream.png" alt=""/>
<div class="caption">
Snow 3G Algorithm During Key-Stream Generation</div></div>
 <p><b>The Rijndael S-box <img class="formulaInl" alt="$ S_R$" src="form_159.png"/></b></p>
<p>The S-box SR maps 8 bit to 8 bit. Here the input and output is presented in hexadecimal form</p>
<p>Let <img class="formulaInl" alt="$ x_0, x_1, y_0, y_1$" src="form_219.png"/> be hexadecimal digits with <img class="formulaInl" alt="$ S_R(x_0 {2}^{4}+x_1) = y_0 {2}^{4} + y_1$" src="form_220.png"/>, then the cell at the intersection of the <img class="formulaInl" alt="$ {x_0}^{th}$" src="form_221.png"/> row and the <img class="formulaInl" alt="$ {x_1}^{th}$" src="form_222.png"/> column contains the values for <img class="formulaInl" alt="$ y_0 || y_1$" src="form_223.png"/> in hexadecimal form</p>
<p>For example <img class="formulaInl" alt="$ S_R(42) = S_R(0x2A) = 0xE5 = 229$" src="form_224.png"/></p>
<div class="image">
<img src="SnowSBOXSr.png" alt=""/>
<div class="caption">
Rijndael S-Box</div></div>
 <p><b>The S-box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/></b></p>
<p>The S-box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/> maps 8 bit to 8 bit. Here the input is presented in hexadecimal form</p>
<p>Let <img class="formulaInl" alt="$ x_0, x_1, y_0, y_1$" src="form_219.png"/> be hexadecimal digits with <img class="formulaInl" alt="$ S_Q(x_0 {2}^{4}+x_1) = y_0 {2}^{4} + y_1$" src="form_225.png"/>, then the cell at the intersection of the <img class="formulaInl" alt="$ {x_0}^{th}$" src="form_221.png"/> row and the <img class="formulaInl" alt="$ {x_1}^{th}$" src="form_222.png"/> column contains the values for <img class="formulaInl" alt="$ y_0 || y_1$" src="form_223.png"/> in hexadecimal form</p>
<p>For example <img class="formulaInl" alt="$ S_Q(42) = S_Q(0x2A) = 0xAC = 172$" src="form_226.png"/></p>
<div class="image">
<img src="SnowSBOXSq.png" alt=""/>
<div class="caption">
S-Box SQ</div></div>
 <p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jarray.html">ProtocolPP::jarray</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jsnow3g.html">ProtocolPP::jsnow3g</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jmodes.html">ProtocolPP::jmodes</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jconfident.html">ProtocolPP::jconfident</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jintegrity.html">ProtocolPP::jintegrity</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjarray.html">jarray</a> </dd>
<dd>
<a class="el" href="classjsnow3g.html">jsnow3g</a> </dd>
<dd>
<a class="el" href="classjmodes.html">jmodes</a> </dd>
<dd>
<a class="el" href="classjconfident.html">jconfident</a> </dd>
<dd>
<a class="el" href="classjintegrity.html">jintegrity</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2024 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
<li><b>TXu002383571 (Version 5.4.3)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jsnow3g.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classjsnow3g.html">jsnow3g</a></li>
    <li class="footer">Generated on Wed Jul 3 2024 13:58:01 for Protocol++&reg; (Protocolpp&reg;) by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
