<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++ (ProtocolPP): jconfident Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++ (ProtocolPP)
   &#160;<span id="projectnumber">5.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">jconfident Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="jconfident_8h_source.html">include/jconfident.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for jconfident:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classjconfident__coll__graph.png" border="0" usemap="#jconfident_coll__map" alt="Collaboration graph"/></div>
<map name="jconfident_coll__map" id="jconfident_coll__map">
</map>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjmodes.html">jmodes</a> for encryption modes of operation</dd></dl>
<h1><a class="anchor" id="RC4C"></a>
ARC4 Stream Cipher</h1>
<p>See <a href="https://en.wikipedia.org/wiki/RC4">https://en.wikipedia.org/wiki/RC4</a> <br />
 See <a href="http://cypherpunks.venona.com/archive/1994/09/msg00304.html">http://cypherpunks.venona.com/archive/1994/09/msg00304.html</a></p>
<p>In cryptography, RC4 (Rivest Cipher 4 also known as ARC4 or ARCFOUR meaning Alleged RC4, see below) is a stream cipher. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure. It is especially vulnerable when the beginning of the output keystream is not discarded, or when nonrandom or related keys are used. Particularly problematic uses of RC4 have led to very insecure protocols such as WEP</p>
<p>As of 2015, there is speculation that some state cryptologic agencies may possess the capability to break RC4 when used in the TLS protocol. IETF has published RFC 7465 to prohibit the use of RC4 in TLS; Mozilla and Microsoft have issued similar recommendations</p>
<p>A number of attempts have been made to strengthen RC4, notably Spritz, RC4A, VMPC, and RC4+</p>
<p><b>History</b></p>
<p>RC4 was designed by Ron Rivest of RSA Security in 1987. While it is officially termed "Rivest Cipher 4", the RC acronym is alternatively understood to stand for "Ron's Code" (see also RC2, RC5 and RC6)</p>
<p>RC4 was initially a trade secret, but in September 1994 a description of it was anonymously posted to the Cypherpunks mailing list. It was soon posted on the sci.crypt newsgroup, where it was broken within days by Bob Jenkins. From there it spread to many sites on the Internet. The leaked code was confirmed to be genuine as its output was found to match that of proprietary software using licensed RC4. Because the algorithm is known, it is no longer a trade secret. The name RC4 is trademarked, so RC4 is often referred to as ARCFOUR or ARC4 (meaning alleged RC4) to avoid trademark problems. RSA Security has never officially released the algorithm; Rivest has, however, linked to the English Wikipedia article on RC4 in his own course notes in 2008 and confirmed the history of RC4 and its code in a 2014 paper by him</p>
<p>RC4 became part of some commonly used encryption protocols and standards, such as WEP in 1997 and WPA in 2003/2004 for wireless cards; and SSL in 1995 and its successor TLS in 1999, until it was prohibited for all versions of TLS by RFC 7465 in 2015, due to the RC4 attacks weakening or breaking RC4 used in SSL/TLS. The main factors in RC4's success over such a wide range of applications have been its speed and simplicity: efficient implementations in both software and hardware were very easy to develop</p>
<p><b>Description</b></p>
<p>RC4 generates a pseudorandom stream of bits (a keystream). As with any stream cipher, these can be used for encryption by combining it with the plaintext using bit-wise exclusive-or; decryption is performed the same way (since exclusive-or with given data is an involution). This is similar to the one-time pad except that generated pseudorandom bits, rather than a prepared stream, are used</p>
<p>To generate the keystream, the cipher makes use of a secret internal state which consists of two parts:</p>
<ol type="1">
<li>A permutation of all 256 possible bytes (denoted "S" below)</li>
<li>Two 8-bit index-pointers (denoted "i" and "j")</li>
</ol>
<p>The permutation is initialized with a variable length key, typically between 40 and 2048 bits, using the key- scheduling algorithm (KSA). Once this has been completed, the stream of bits is generated using the pseudo-random generation algorithm (PRGA).</p>
<p><b>Key-scheduling algorithm (KSA)</b></p>
<p>The key-scheduling algorithm is used to initialize the permutation in the array "S". "keylength" is defined as the number of bytes in the key and can be in the range 1 ≤ keylength ≤ 256, typically between 5 and 16, corresponding to a key length of 40–128 bits. First, the array "S" is initialized to the identity permutation. S is then processed for 256 iterations in a similar way to the main PRGA, but also mixes in bytes of the key at the same time</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i from 0 to 255</div><div class="line">   S[i] := i</div><div class="line">endfor</div><div class="line">j := 0</div><div class="line"><span class="keywordflow">for</span> i from 0 to 255</div><div class="line">   j := (j + S[i] + key[i mod keylength]) mod 256</div><div class="line">   <a class="code" href="namespaceProtocolPP.html#a6c7793aaf65e41dd012e888085221fd9">swap</a> values of S[i] and S[j]</div><div class="line">endfor</div></div><!-- fragment --><div class="image">
<img src="ARC4Lookup25.png" alt="ARC4Lookup25.png"/>
</div>
 <p>In the above lookup stage of ARC4, the output byte is selected by looking up the values of S[<em>i</em>] and S[<em>j</em>], adding them together modulo 256, and then using the sum as an index into S; S(S[<em>i</em>] + S[<em>j</em>]) is used as a byte of the key stream, K</p>
<p><b>Pseudo-random generation algorithm (PRGA)</b></p>
<p>The lookup stage of RC4. The output byte is selected by looking up the values of S[i] and S[j], adding them together modulo 256, and then using the sum as an index into S; S(S[i] + S[j]) is used as a byte of the key stream, K</p>
<p>For as many iterations as are needed, the PRGA modifies the state and outputs a byte of the keystream. In each iteration, the PRGA:</p>
<ul>
<li>increments i</li>
<li>looks up the ith element of S, S[i], and adds that to <em>j</em></li>
<li>exchanges the values of S[<em>i</em>] and S[<em>j</em>] then uses the sum S[<em>i</em>] + S[<em>j</em>] (modulo 256) as an index to fetch a third element of S (the keystream value K below)</li>
<li>then bitwise exclusive ORed (XORed) with the next byte of the message to produce the next byte of either ciphertext or plaintext.</li>
</ul>
<p>Each element of S is swapped with another element at least once every 256 iterations</p>
<div class="fragment"><div class="line">i := 0</div><div class="line">j := 0</div><div class="line"><span class="keywordflow">while</span> GeneratingOutput:</div><div class="line">   i := (i + 1) mod 256</div><div class="line">   j := (j + S[i]) mod 256</div><div class="line">   <a class="code" href="namespaceProtocolPP.html#a6c7793aaf65e41dd012e888085221fd9">swap</a> values of S[i] and S[j]</div><div class="line">   K := S[(S[i] + S[j]) mod 256]</div><div class="line">   output K</div><div class="line">endwhile</div></div><!-- fragment --><p><b>Security</b></p>
<p>Unlike a modern stream cipher (such as those in eSTREAM), RC4 does not take a separate nonce alongside the key. This means that if a single long-term key is to be used to securely encrypt multiple streams, the protocol must specify how to combine the nonce and the long-term key to generate the stream key for RC4. One approach to addressing this is to generate a "fresh" RC4 key by hashing a long-term key with a nonce. However, many applications that use RC4 simply concatenate key and nonce; RC4's weak key schedule then gives rise to related key attacks, like the Fluhrer, Mantin and Shamir attack (which is famous for breaking the WEP standard)</p>
<p>Because RC4 is a stream cipher, it is more malleable than common block ciphers. If not used together with a strong message authentication code (MAC), then encryption is vulnerable to a bit-flipping attack. The cipher is also vulnerable to a stream cipher attack if not implemented correctly</p>
<p>It is noteworthy, however, that RC4, being a stream cipher, was for a period of time the only common cipher that was immune to the 2011 BEAST attack on TLS 1.0. The attack exploits a known weakness in the way cipher block chaining mode is used with all of the other ciphers supported by TLS 1.0, which are all block ciphers</p>
<p>In March 2013, there were new attack scenarios proposed by Isobe, Ohigashi, Watanabe and Morii, as well as AlFardan, Bernstein, Paterson, Poettering and Schuldt that use new statistical biases in RC4 key table to recover plaintext with large number of TLS encryptions</p>
<p>The use of RC4 in TLS is prohibited by RFC 7465 published in February 2015.</p>
<h1><a class="anchor" id="DESC"></a>
Data Encryption Standard (DES)</h1>
<p><b>Description</b></p>
<p>For brevity, the following description omits the exact transformations and permutations which specify the algorithm; for reference, the details can be found in DES supplementary material</p>
<p>DES is the archetypal block cipher—an algorithm that takes a fixed-length string of plaintext bits and transforms it through a series of complicated operations into another ciphertext bitstring of the same length. In the case of DES, the block size is 64 bits. DES also uses a key to customize the transformation, so that decryption can supposedly only be performed by those who know the particular key used to encrypt. The key ostensibly consists of 64 bits; however, only 56 of these are actually used by the algorithm. Eight bits are used solely for checking parity, and are thereafter discarded. Hence the effective key length is 56 bits</p>
<p>The key is nominally stored or transmitted as 8 bytes, each with odd parity. According to ANSI X3.92-1981 (Now, known as ANSI INCITS 92-1981), section 3.5:</p>
<p>One bit in each 8-bit byte of the KEY may be utilized for error detection in key generation, distribution, and storage. Bits 8, 16,..., 64 are for use in ensuring that each byte is of odd parity</p>
<p>Like other block ciphers, DES by itself is not a secure means of encryption, but must instead be used in a mode of operation. FIPS-81 specifies several modes for use with DES. Further comments on the usage of DES are contained in FIPS-74. Decryption uses the same structure as encryption, but with the keys used in reverse order. (This has the advantage that the same hardware or software can be used in both directions</p>
<p><b>Overall structure</b></p>
<p>The algorithm's overall structure is shown in the figure below: there are 16 identical stages of processing, termed rounds. There is also an initial and final permutation, termed IP and FP, which are inverses (IP "undoes" the action of FP, and vice versa). IP and FP have no cryptographic significance, but were included in order to facilitate loading blocks in and out of mid-1970s 8-bit based hardware</p>
<p>Before the main rounds, the block is divided into two 32-bit halves and processed alternately; this criss-crossing is known as the Feistel scheme. The Feistel structure ensures that decryption and encryption are very similar processes—the only difference is that the subkeys are applied in the reverse order when decrypting. The rest of the algorithm is identical. This greatly simplifies implementation, particularly in hardware, as there is no need for separate encryption and decryption algorithms</p>
<p>The <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> symbol denotes the exclusive-OR (XOR) operation. The F-function scrambles half a block together with some of the key. The output from the F-function is then combined with the other half of the block, and the halves are swapped before the next round. After the final round, the halves are swapped; this is a feature of the Feistel structure which makes encryption and decryption similar processes</p>
<div class="image">
<img src="DES-main-network50.png" alt="DES-main-network50.png"/>
</div>
 <p><b>The Feistel (F) function</b></p>
<p>The F-function, depicted in the figure below, operates on half a block (32 bits) at a time and consists of four stages:</p>
<ol type="1">
<li>Expansion: the 32-bit half-block is expanded to 48 bits using the expansion permutation, denoted E in the diagram, by duplicating half of the bits. The output consists of eight 6-bit (8 * 6 = 48 bits) pieces, each containing a copy of 4 corresponding input bits, plus a copy of the immediately adjacent bit from each of the input pieces to either side</li>
<li>Key mixing: the result is combined with a subkey using an XOR operation. Sixteen 48-bit subkeys—one for each round—are derived from the main key using the key schedule (described below)</li>
<li>Substitution: after mixing in the subkey, the block is divided into eight 6-bit pieces before processing by the S-boxes, or substitution boxes. Each of the eight S-boxes replaces its six input bits with four output bits according to a non-linear transformation, provided in the form of a lookup table. The S-boxes provide the core of the security of DES—without them, the cipher would be linear, and trivially breakable</li>
<li>Permutation: finally, the 32 outputs from the S-boxes are rearranged according to a fixed permutation, the P-box. This is designed so that, after permutation, the bits from the output of each S-box in this round are spread across four different S-boxes in the next round</li>
</ol>
<p>The alternation of substitution from the S-boxes, and permutation of bits from the P-box and E-expansion provides so-called "confusion and diffusion" respectively, a concept identified by Claude Shannon in the 1940s as a necessary condition for a secure yet practical cipher</p>
<div class="image">
<img src="DES_Feistel25.png" alt="DES_Feistel25.png"/>
</div>
 <p><b>Key schedule</b></p>
<p>The figure below illustrates the key schedule for encryption—the algorithm which generates the subkeys. Initially, 56 bits of the key are selected from the initial 64 by Permuted Choice 1 (PC-1)—the remaining eight bits are either discarded or used as parity check bits. The 56 bits are then divided into two 28-bit halves; each half is thereafter treated separately. In successive rounds, both halves are rotated left by one or two bits (specified for each round), and then 48 subkey bits are selected by Permuted Choice 2 (PC-2)—24 bits from the left half, and 24 from the right. The rotations (denoted by "&lt;&lt;&lt;" in the diagram) mean that a different set of bits is used in each subkey; each bit is used in approximately 14 out of the 16 subkeys</p>
<p>The key schedule for decryption is similar—the subkeys are in reverse order compared to encryption. Apart from that change, the process is the same as for encryption. The same 28 bits are passed to all rotation boxes</p>
<div class="image">
<img src="DES-key-schedule.png" alt="DES-key-schedule.png"/>
</div>
 <p><b>Security and cryptanalysis</b></p>
<p>Although more information has been published on the cryptanalysis of DES than any other block cipher, the most practical attack to date is still a brute-force approach. Various minor cryptanalytic properties are known, and three theoretical attacks are possible which, while having a theoretical complexity less than a brute-force attack, require an unrealistic number of known or chosen plaintexts to carry out, and are not a concern in practice</p>
<p><b>Brute-force attack</b></p>
<p>For any cipher, the most basic method of attack is brute force—trying every possible key in turn. The length of the key determines the number of possible keys, and hence the feasibility of this approach. For DES, questions were raised about the adequacy of its key size early on, even before it was adopted as a standard, and it was the small key size, rather than theoretical cryptanalysis, which dictated a need for a replacement algorithm. As a result of discussions involving external consultants including the NSA, the key size was reduced from 128 bits to 56 bits to fit on a single chip</p>
<p>The EFF's US$250,000 DES cracking machine contained 1,856 custom chips and could brute-force a DES key in a matter of days—the photo shows a DES Cracker circuit board fitted with several Deep Crack chips</p>
<p>In academia, various proposals for a DES-cracking machine were advanced. In 1977, Diffie and Hellman proposed a machine costing an estimated US$20 million which could find a DES key in a single day.[1][31] By 1993, Wiener had proposed a key-search machine costing US$1 million which would find a key within 7 hours. However, none of these early proposals were ever implemented—or, at least, no implementations were publicly acknowledged. The vulnerability of DES was practically demonstrated in the late 1990s. In 1997, RSA Security sponsored a series of contests, offering a $10,000 prize to the first team that broke a message encrypted with DES for the contest. That contest was won by the DESCHALL Project, led by Rocke Verser, Matt Curtin, and Justin Dolske, using idle cycles of thousands of computers across the Internet. The feasibility of cracking DES quickly was demonstrated in 1998 when a custom DES-cracker was built by the Electronic Frontier Foundation (EFF), a cyberspace civil rights group, at the cost of approximately US$250,000 (see EFF DES cracker). Their motivation was to show that DES was breakable in practice as well as in theory: "There are many people who will not believe a truth until they can see it with their own eyes. Showing them a physical machine that can crack DES in a few days is the only way to convince some people that they really cannot trust their security to DES." The machine brute-forced a key in a little more than 2 days' worth of searching</p>
<p>The next confirmed DES cracker was the COPACOBANA machine built in 2006 by teams of the Universities of Bochum and Kiel, both in Germany. Unlike the EFF machine, COPACOBANA consists of commercially available, reconfigurable integrated circuits. 120 of these field-programmable gate arrays (FPGAs) of type XILINX Spartan-3 1000 run in parallel. They are grouped in 20 DIMM modules, each containing 6 FPGAs. The use of reconfigurable hardware makes the machine applicable to other code breaking tasks as well. One of the more interesting aspects of COPACOBANA is its cost factor. One machine can be built for approximately $10,000. The cost decrease by roughly a factor of 25 over the EFF machine is an example of the continuous improvement of digital hardware—see Moore's law. Adjusting for inflation over 8 years yields an even higher improvement of about 30x. Since 2007, SciEngines GmbH, a spin-off company of the two project partners of COPACOBANA has enhanced and developed successors of COPACOBANA. In 2008 their COPACOBANA RIVYERA reduced the time to break DES to less than one day, using 128 Spartan-3 5000's. SciEngines RIVYERA held the record in brute-force breaking DES, having utilized 128 Spartan-3 5000 FPGAs. Their 256 Spartan-6 LX150 model has further lowered this time</p>
<p>In 2012, David Hulton and Moxie Marlinspike announced a system with 48 Xilinx Virtex-6 LX240T FPGAs, each FPGA containing 40 fully pipelined DES cores running at 400 MHz, for a total capacity of 768 gigakeys/sec. The system can exhaustively search the entire 56-bit DES key space in about 26 hours and this service is offered for a fee online</p>
<h1><a class="anchor" id="DES3C"></a>
Triple DES</h1>
<p>See <a href="https://en.wikipedia.org/wiki/Triple_DES">https://en.wikipedia.org/wiki/Triple_DES</a></p>
<p>In cryptography, Triple DES (3DES or TDES), officially the Triple Data Encryption Algorithm (TDEA or Triple DEA), is a symmetric-key block cipher, which applies the DES cipher algorithm three times to each data block. The Data Encryption Standard’s(DES) 56-bit key is no longer considered adequate in the face of modern cryptanalytic techniques and supercomputing power. However, an adapted version of DES, Triple DES (3DES), uses the same algorithm to produce a more secure encryption</p>
<p>While the government and industry standards abbreviate the algorithm's name as TDES (Triple DES) and TDEA (Triple Data Encryption Algorithm),[1] RFC 1851 referred to it as 3DES from the time it first promulgated the idea, and this namesake has since come into wide use by most vendors, users, and cryptographers</p>
<p><b>Algorithm</b></p>
<p>The original DES cipher's key size of 56 bits was generally sufficient when that algorithm was designed, but the availability of increasing computational power made brute-force attacks feasible. Triple DES provides a relatively simple method of increasing the key size of DES to protect against such attacks, without the need to design a completely new block cipher algorithm</p>
<p>A naive approach to increase strength of a block encryption algorithm with short key length (like DES) would be to use two keys <b>(K1, K2)</b> instead of one, and encrypt each block twice: <img class="formulaInl" alt="$ E_K2(E_K1(plaintext)) $" src="form_6.png"/>. If the original key length is <em>n</em> bits, one would hope this scheme provides security equivalent to using key <em>2n</em> bits long. Unfortunately, this approach is vulnerable to meet-in-the-middle attack: given a known plaintext pair <b>(x, y)</b>, such that <img class="formulaInl" alt="$ y = E_K2(E_K1(x))$" src="form_7.png"/>, one can recover the key pair <b>(K1, K2)</b> in <img class="formulaInl" alt="$ {2}^{n}$" src="form_8.png"/> steps, instead of <img class="formulaInl" alt="$ {2}^{2n}$" src="form_9.png"/> steps one would expect from an ideally secure algorithm with <b><em>2n</em></b> bits of key</p>
<p>Therefore, Triple DES uses a "key bundle" that comprises three DES keys, <b>K1, K2</b> and <b>K3</b>, each of 56 bits (excluding parity bits). The encryption algorithm is:</p>
<p><img class="formulaInl" alt="$ ciphertext = E_K3 (D_K2(E_K1(plaintext)))$" src="form_10.png"/></p>
<p>That is, DES encrypt with <b>K1</b>, DES decrypt with <b>K2</b>, then DES encrypt with <b>K3</b>. Decryption is the reverse:</p>
<p><img class="formulaInl" alt="$ plaintext = D_K1(E_K2(D_K3(ciphertext)))$" src="form_11.png"/></p>
<p>That is, decrypt with <b>K3</b>, encrypt with <b>K2</b>, then decrypt with <b>K1</b></p>
<p>Each triple encryption encrypts one block of 64 bits of data</p>
<p>In each case the middle operation is the reverse of the first and last. This improves the strength of the algorithm when using keying option 2 and provides backward compatibility with DES with keying option 3</p>
<p><b>Keying options</b></p>
<p>The standards define three keying options:</p>
<ul>
<li>Keying option 1<ul>
<li>All three keys are independent. Sometimes known as 3TDEA or triple-length keys. This is the strongest, with 3 × 56 = 168 independent key bits. It is still vulnerable to meet-in-the-middle attack, but the attack requires <img class="formulaInl" alt="$ {2}^{2 × 56} steps$" src="form_12.png"/></li>
</ul>
</li>
<li>Keying option 2<ul>
<li>K1 and K2 are independent, and <b>K3 = K1</b>. Sometimes known as 2TDEA or double-length keys. This provides a shorter key length of 112 bits and a reasonable compromise between DES and Kehttps://en.wikipedia.org/wiki/Triple_DESying option 1, with the same caveat as above. This is an improvement over "double DES" which only requires 256 steps to attack. NIST has deprecated this option</li>
</ul>
</li>
<li>Keying option 3<ul>
<li>All three keys are identical, i.e. <b>K1 = K2 = K3</b>. This is backward compatible with DES, since two operations cancel out. ISO/IEC 18033-3 never allowed this option, and NIST no longer allows K1 = K2 or K2 = K3</li>
</ul>
</li>
</ul>
<p>Each DES key is 8 odd-parity bytes, with 56 bits of key and 8 bits of error-detection. A key bundle requires 24 bytes for option 1, 16 for option 2, or 8 for option 3</p>
<p>NIST (and the current TCG specifications version 2.0 of approved algorithms for Trusted Platform Module) also disallows using any one of the 64 following 64-bit values in any keys (note that 32 of them are the binary complement of the 32 others; and that 32 of these keys are also the reverse permutation of bytes of the 32 others), listed here in hexadecimal (in each byte, the least significant bit is a odd-parity generated bit, it is discarded when forming the effective 56-bit keys):</p>
<div class="fragment"><div class="line">01.01.01.01.01.01.01.01, FE.FE.FE.FE.FE.FE.FE.FE, E0.FE.FE.E0.F1.FE.FE.F1, 1F.01.01.1F.0E.01.01.0E,</div><div class="line">01.01.FE.FE.01.01.FE.FE, FE.FE.01.01.FE.FE.01.01, E0.FE.01.1F.F1.FE.01.0E, 1F.01.FE.E0.0E.01.FE.F1,</div><div class="line">01.01.E0.E0.01.01.F1.F1, FE.FE.1F.1F.FE.FE.0E.0E, E0.FE.1F.01.F1.FE.0E.01, 1F.01.E0.FE.0E.01.F1.FE,</div><div class="line">01.01.1F.1F.01.01.0E.0E, FE.FE.E0.E0.FE.FE.F1.F1, E0.FE.E0.FE.F1.FE.F1.FE, 1F.01.1F.01.0E.01.0E.01,</div><div class="line">01.FE.01.FE.01.FE.01.FE, FE.01.FE.01.FE.01.FE.01, E0.01.FE.1F.F1.01.FE.0E, 1F.FE.01.E0.0E.FE.01.F1,</div><div class="line">01.FE.FE.01.01.FE.FE.01, FE.01.01.FE.FE.01.01.FE, E0.01.01.E0.F1.01.01.F1, 1F.FE.FE.1F.0E.FE.FE.0E,</div><div class="line">01.FE.E0.1F.01.FE.F1.0E, FE.01.1F.E0.FE.01.0E.F1, E0.01.1F.FE.F1.01.0E.FE, 1F.FE.E0.01.0E.FE.F1.01,</div><div class="line">01.FE.1F.E0.01.FE.0E.F1, FE.01.E0.1F.FE.01.F1.0E, E0.01.E0.01.F1.01.F1.01, 1F.FE.1F.FE.0E.FE.0E.FE,</div><div class="line">01.E0.01.E0.01.F1.01.F1, FE.1F.FE.1F.FE.0E.FE.0E, E0.1F.FE.01.F1.0E.FE.01, 1F.E0.01.FE.0E.F1.01.FE,</div><div class="line">01.E0.FE.1F.01.F1.FE.0E, FE.1F.01.E0.FE.0E.01.F1, E0.1F.01.FE.F1.0E.01.FE, 1F.E0.FE.01.0E.F1.FE.01,</div><div class="line">01.E0.E0.01.01.F1.F1.01, FE.1F.1F.FE.FE.0E.0E.FE, E0.1F.1F.E0.F1.0E.0E.F1, 1F.E0.E0.1F.0E.F1.F1.0E,</div><div class="line">01.E0.1F.FE.01.F1.0E.FE, FE.1F.E0.01.FE.0E.F1.01, E0.1F.E0.1F.F1.0E.F1.0E, 1F.E0.1F.E0.0E.F1.0E.F1,</div><div class="line">01.1F.01.1F.01.0E.01.0E, FE.E0.FE.E0.FE.F1.FE.F1, E0.E0.FE.FE.F1.F1.FE.FE, 1F.1F.01.01.0E.0E.01.01,</div><div class="line">01.1F.FE.E0.01.0E.FE.F1, FE.E0.01.1F.FE.F1.01.0E, E0.E0.01.01.F1.F1.01.01, 1F.1F.FE.FE.0E.0E.FE.FE,</div><div class="line">01.1F.E0.FE.01.0E.F1.FE, FE.E0.1F.01.FE.F1.0E.01, E0.E0.1F.1F.F1.F1.0E.0E, 1F.1F.E0.E0.0E.0E.F1.F1,</div><div class="line">01.1F.1F.01.01.0E.0E.01, FE.E0.E0.FE.FE.F1.F1.FE, E0.E0.E0.E0.F1.F1.F1.F1, 1F.1F.1F.1F.0E.0E.0E.0E,</div></div><!-- fragment --><p>With these restrictions on allowed keys, Triple DES has been reapproved with keying options 1 and 2 only. Generally the three keys are generated by taking 24 bytes from a strong random generator and only keying option 1 should be used (option 2 needs only 16 random bytes, but strong random generators are hard to assert and it's considered best practice to use only option 1)</p>
<p><b>Usage</b></p>
<p>The electronic payment industry uses Triple DES and continues to develop and promulgate standards based upon it, such as EMV</p>
<p>Earlier versions of Microsoft OneNote, Microsoft Outlook 2007 and Microsoft System Center Configuration Manager 2012 use Triple DES to password-protect user content and system data. However, in December 2018, Microsoft announced the retirement of 3DES throughout their Office 365 service</p>
<p>Firefox and Mozilla Thunderbird use Triple DES in CBC mode to encrypt website authentication login credentials when using a master password</p>
<h1><a class="anchor" id="AESC"></a>
The Advanced Encryption Standard (AES)</h1>
<p>Also known by its original name Rijndael is a specification for the encryption of electronic data established by the U.S. National Institute of Standards and Technology (NIST) in 2001. AES is a subset of the Rijndael block cipher developed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, who submitted a proposal to NIST during the AES selection process. Rijndael is a family of ciphers with different key and block sizes</p>
<p>For AES, NIST selected three members of the Rijndael family, each with a block size of 128 bits, but three different key lengths: 128, 192 and 256 bits</p>
<p>AES has been adopted by the U.S. government and is now used worldwide. It supersedes the Data Encryption Standard (DES), which was published in 1977. The algorithm described by AES is a symmetric-key algorithm, meaning the same key is used for both encrypting and decrypting the data</p>
<p>In the United States, AES was announced by the NIST as U.S. FIPS PUB 197 (FIPS 197) on November 26,</p><ol type="1">
<li>This announcement followed a five-year standardization process in which fifteen competing designs were presented and evaluated, before the Rijndael cipher was selected as the most suitable (see Advanced Encryption Standard process for more details)</li>
</ol>
<p>AES became effective as a federal government standard on May 26, 2002, after approval by the Secretary of Commerce. AES is included in the ISO/IEC 18033-3 standard. AES is available in many different encryption packages, and is the first (and only) publicly accessible cipher approved by the National Security Agency (NSA) for top secret information when used in an NSA approved cryptographic module (see Security of AES, below)</p>
<p><b>Description of the ciphers</b></p>
<p>AES is based on a design principle known as a substitution–permutation network, and is efficient in both software and hardware. Unlike its predecessor DES, AES does not use a Feistel network. AES is a variant of Rijndael which has a fixed block size of 128 bits, and a key size of 128, 192, or 256 bits. By contrast, Rijndael per se is specified with block and key sizes that may be any multiple of 32 bits, with a minimum of 128 and a maximum of 256 bits</p>
<p>AES operates on a 4 × 4 column-major order array of bytes, termed the state. Most AES calculations are done in a particular finite field</p>
<p>For instance, if there are 16 bytes, <img class="formulaInl" alt="$ b_0, b_1,...,b_15,$" src="form_13.png"/> these bytes are represented as this two-dimensional array:</p>
<div class="image">
<img src="MajorBytesArray.png" alt="MajorBytesArray.png"/>
</div>
 <p>The key size used for an AES cipher specifies the number of transformation rounds that convert the input, called the plaintext, into the final output, called the ciphertext. The number of rounds are as follows:</p>
<ul>
<li>10 rounds for 128-bit keys</li>
<li>12 rounds for 192-bit keys</li>
<li>14 rounds for 256-bit keys</li>
</ul>
<p>Each round consists of several processing steps, including one that depends on the encryption key itself. A set of reverse rounds are applied to transform ciphertext back into the original plaintext using the same encryption key</p>
<p><b>High-level description of the algorithm</b></p>
<ol type="1">
<li>KeyExpansion—round keys are derived from the cipher key using Rijndael's key schedule. AES requires a separate 128-bit round key block for each round plus one more</li>
<li>Initial round key addition:<ol type="a">
<li>AddRoundKey—each byte of the state is combined with a block of the round key using bitwise xor</li>
</ol>
</li>
<li>9, 11 or 13 rounds:<ol type="a">
<li>SubBytes—a non-linear substitution step where each byte is replaced with another according to a lookup table</li>
<li>ShiftRows—a transposition step where the last three rows of the state are shifted cyclically a certain number of steps</li>
<li>MixColumns—a linear mixing operation which operates on the columns of the state, combining the four bytes in each column.</li>
<li>AddRoundKey</li>
</ol>
</li>
<li>Final round (making 10, 12 or 14 rounds in total):<ol type="a">
<li>SubBytes</li>
<li>ShiftRows</li>
<li>AddRoundKey</li>
</ol>
</li>
</ol>
<p><b>The SubBytes step</b></p>
<p>In the SubBytes step, each byte <img class="formulaInl" alt="$ a_i,j $" src="form_14.png"/> in the state array is replaced with a SubByte <img class="formulaInl" alt="$ S(a_i,j) $" src="form_15.png"/> using an 8-bit substitution box. This operation provides the non-linearity in the cipher. The S-box used is derived from the multiplicative inverse over GF(28), known to have good non-linearity properties. To avoid attacks based on simple algebraic properties, the S-box is constructed by combining the inverse function with an invertible affine transformation. The S-box is also chosen to avoid any fixed points (and so is a derangement), i.e., <img class="formulaInl" alt="$ S(a_i,j) ≠ a_i,j $" src="form_16.png"/>, and also any opposite fixed points, i.e., <img class="formulaInl" alt="$ S(a_i,j) \oplus a_i,j ≠ 0xFF_16 $" src="form_17.png"/>. While performing the decryption, the InvSubBytes step (the inverse of SubBytes) is used, which requires first taking the inverse of the affine transformation and then finding the multiplicative inverse</p>
<div class="image">
<img src="AES-SubBytes25.png" alt="AES-SubBytes25.png"/>
</div>
 <p><b>The ShiftRows step</b></p>
<p>In the ShiftRows step, bytes in each row of the state are shifted cyclically to the left. The number of places each byte is shifted differs for each row. The ShiftRows step operates on the rows of the state; it cyclically shifts the bytes in each row by a certain offset. For AES, the first row is left unchanged. Each byte of the second row is shifted one to the left. Similarly, the third and fourth rows are shifted by offsets of two and three respectively. In this way, each column of the output state of the ShiftRows step is composed of bytes from each column of the input state. The importance of this step is to avoid the columns being encrypted independently, in which case AES degenerates into four independent block ciphers</p>
<div class="image">
<img src="AES-ShiftRows25.png" alt="AES-ShiftRows25.png"/>
</div>
 <p><b>The MixColumns step</b></p>
<p>In the MixColumns step, each column of the state is multiplied with a fixed polynomial <img class="formulaInl" alt="$ c(x)$" src="form_18.png"/></p>
<p>In the MixColumns step, the four bytes of each column of the state are combined using an invertible linear transformation. The MixColumns function takes four bytes as input and outputs four bytes, where each input byte affects all four output bytes. Together with ShiftRows, MixColumns provides diffusion in the cipher</p>
<p>During this operation, each column is transformed using a fixed matrix (matrix left-multiplied by column gives new value of column in the state):</p>
<div class="image">
<img src="MixedMatrix.png" alt="MixedMatrix.png"/>
</div>
 <p>Matrix multiplication is composed of multiplication and addition of the entries. Entries are 8-bit bytes treated as coefficients of polynomial of order <img class="formulaInl" alt="$ {x}^{7} $" src="form_19.png"/>. Addition is simply XOR. Multiplication is modulo irreducible polynomial <img class="formulaInl" alt="$ {x}^{8}+{x}^{4}+{x}^{3}+x+1 $" src="form_20.png"/>. If processed bit by bit, then, after shifting, a conditional XOR with <img class="formulaInl" alt="$ 1B_16 $" src="form_21.png"/> should be performed if the shifted value is larger than <img class="formulaInl" alt="$ FF_16 $" src="form_22.png"/> (overflow must be corrected by subtraction of generating polynomial). These are special cases of the usual multiplication in <img class="formulaInl" alt="$ GF({2}^{8}) $" src="form_23.png"/></p>
<p>In more general sense, each column is treated as a polynomial over <img class="formulaInl" alt="$ GF({2}^{8}) $" src="form_23.png"/> and is then multiplied modulo <img class="formulaInl" alt="$ 01_16 \cdot {z}^{4} + 01_16 $" src="form_24.png"/> with a fixed polynomial <img class="formulaInl" alt="$ c(z) = 03_16 \cdot {z}^{3} + 01_16 \cdot {z}^{2} + 01_16 \cdot z + 02_16 $" src="form_25.png"/> The coefficients are displayed in their hexadecimal equivalent of the binary representation of bit polynomials from <img class="formulaInl" alt="$ GF(2)[x] $" src="form_26.png"/>. The MixColumns step can also be viewed as a multiplication by the shown particular MDS matrix in the finite field <img class="formulaInl" alt="$ GF({2}^{8}) $" src="form_23.png"/>. This process is described further in the article Rijndael MixColumns</p>
<div class="image">
<img src="AES-MixColumns25.png" alt="AES-MixColumns25.png"/>
</div>
 <p><b>The AddRoundKey step</b></p>
<p>In the AddRoundKey step, the subkey is combined with the state. For each round, a subkey is derived from the main key using Rijndael's key schedule; each subkey is the same size as the state. The subkey is added by combining each byte of the state with the corresponding byte of the subkey using bitwise XOR</p>
<div class="image">
<img src="AES-AddRoundKey25.png" alt="AES-AddRoundKey25.png"/>
</div>
 <p><b>Optimization of the cipher</b></p>
<p>On systems with 32-bit or larger words, it is possible to speed up execution of this cipher by combining the SubBytes and ShiftRows steps with the MixColumns step by transforming them into a sequence of table lookups. This requires four 256-entry 32-bit tables (together occupying 4096 bytes). A round can then be performed with 16 table lookup operations and 12 32-bit exclusive-or operations, followed by four 32-bit exclusive-or operations in the AddRoundKey step. Alternatively, the table lookup operation can be performed with a single 256-entry 32-bit table (occupying 1024 bytes) followed by circular rotation operations</p>
<p>Using a byte-oriented approach, it is possible to combine the SubBytes, ShiftRows, and MixColumns steps into a single round operation</p>
<p><b>Security</b></p>
<p>Until May 2009, the only successful published attacks against the full AES were side-channel attacks on some specific implementations. The National Security Agency (NSA) reviewed all the AES finalists, including Rijndael, and stated that all of them were secure enough for U.S. Government non-classified data. In June 2003, the U.S. Government announced that AES could be used to protect classified information:</p>
<p>The design and strength of all key lengths of the AES algorithm (i.e., 128, 192 and 256) are sufficient to protect classified information up to the SECRET level. TOP SECRET information will require use of either the 192 or 256 key lengths. The implementation of AES in products intended to protect national security systems and/or information must be reviewed and certified by NSA prior to their acquisition and use</p>
<p>AES has 10 rounds for 128-bit keys, 12 rounds for 192-bit keys, and 14 rounds for 256-bit keys</p>
<p>By 2006, the best known attacks were on 7 rounds for 128-bit keys, 8 rounds for 192-bit keys, and 9 rounds for 256-bit keys</p>
<p><b>Performance</b></p>
<p>High speed and low RAM requirements were criteria of the AES selection process. As the chosen algorithm, AES performed well on a wide variety of hardware, from 8-bit smart cards to high-performance computers</p>
<p>On a Pentium Pro, AES encryption requires 18 clock cycles per byte, equivalent to a throughput of about 11 Mbit/s for a 200 MHz processor. On a 1.7 GHz Pentium M throughput is about 60 Mbit/s</p>
<p>On Intel Core i3/i5/i7 and AMD Ryzen CPUs supporting AES-NI instruction set extensions, throughput can be multiple GB/s (even over 10 GB/s)</p>
<h1><a class="anchor" id="SERPC"></a>
Serpent Block Cipher</h1>
<p>Serpent is a symmetric key block cipher that was a finalist in the Advanced Encryption Standard (AES) contest, where it was ranked second to Rijndael. Serpent was designed by Ross Anderson, Eli Biham, and Lars Knudsen</p>
<p>Like other AES submissions, Serpent has a block size of 128 bits and supports a key size of 128, 192 or 256 bits. The cipher is a 32-round substitution–permutation network operating on a block of four 32-bit words. Each round applies one of eight 4-bit to 4-bit S-boxes 32 times in parallel. Serpent was designed so that all operations can be executed in parallel, using 32 bit slices. This maximizes parallelism, but also allows use of the extensive cryptanalysis work performed on DES</p>
<p>Serpent took a conservative approach to security, opting for a large security margin: the designers deemed 16 rounds to be sufficient against known types of attack, but specified 32 rounds as insurance against future discoveries in cryptanalysis. The official NIST report on AES competition classified Serpent as having a high security margin along with MARS and Twofish, in contrast to the adequate security margin of RC6 and Rijndael (currently AES). In final voting, Serpent had the fewest negative votes among the finalists, but scored second place overall because Rijndael had substantially more positive votes, the deciding factor being that Rijndael allowed for a far more efficient software implementation</p>
<p>The Serpent cipher algorithm is in the public domain and has not been patented. The reference code is public domain software and the optimized code is under GPL. There are no restrictions or encumbrances whatsoever regarding its use. As a result, anyone is free to incorporate Serpent in their software (or hardware implementations) without paying license fees</p>
<p><b>Rijndael vs. Serpent</b></p>
<p>Rijndael is a substitution-linear transformation network with ten, twelve, or fourteen rounds, depending on the key size, and with block sizes of 128 bits, 192 bits, or 256 bits, independently specified. Serpent is a substitution–permutation network which has thirty-two rounds, plus an initial and a final permutation to simplify an optimized implementation. The round function in Rijndael consists of three parts: a nonlinear layer, a linear mixing layer, and a key-mixing XOR layer. The round function in Serpent consists of key-mixing XOR, thirty-two parallel applications of the same 4×4 S-box, and a linear transformation, except in the last round, wherein another key-mixing XOR replaces the linear transformation. The nonlinear layer in Rijndael uses an 8×8 S-box whereas Serpent uses eight different 4×4 S-boxes. The 32 rounds means that Serpent has a higher security margin than Rijndael; however, Rijndael with 10 rounds is faster and easier to implement for small blocks. Hence, Rijndael was selected as the winner in the AES competition</p>
<p><b>Serpent-0 vs. Serpent-1</b></p>
<p>The original Serpent, Serpent-0, was presented at the 5th workshop on Fast Software Encryption, but a somewhat tweaked version, Serpent-1, was submitted to the AES competition. The AES submission paper discuss the changes, which include key scheduling differences</p>
<p><b>Security</b></p>
<p>The XSL attack, if effective, would weaken Serpent (though not as much as it would weaken Rijndael, which became AES). However, many cryptanalysts believe that once implementation considerations are taken into account the XSL attack would be more expensive than a brute force attack</p>
<p>In 2000, a paper by Kohno et al. presents a meet-in-the-middle attack against 6 of 32 rounds of Serpent and an amplified boomerang attack against 9 of 32 rounds in Serpent</p>
<p>A 2001 attack by Eli Biham, Orr Dunkelman and Nathan Keller presents a linear cryptanalysis attack that breaks 10 of 32 rounds of Serpent-128 with 2118 known plaintexts and 289 time, and 11 rounds of Serpent-192/256 with 2118 known plaintexts and 2187 time</p>
<p>A 2009 paper has noticed that the nonlinear order of Serpent S-boxes were not 3 as was claimed by the designers</p>
<p>A 2011 attack by Hongjun Wu, Huaxiong Wang and Phuong Ha Nguyen, also using linear cryptanalysis, breaks 11 rounds of Serpent-128 with 2116 known plaintexts, 2107.5 time and 2104 memory</p>
<p>The same paper also describes two attacks which break 12 rounds of Serpent-256. The first requires 2118 known plaintexts, 2228.8 time and 2228 memory. The other attack requires 2116 known plaintexts and 2121 memory but also requires 2237.5 time</p>
<div class="image">
<img src="Serpent.png" alt="Serpent.png"/>
<div class="caption">
Serpent Linear Function [1]</div></div>
<h1><a class="anchor" id="ARIAC"></a>
ARIA Block Cipher (Korea)</h1>
<p>ARIA is a general-purpose block cipher algorithm developed by Korean cryptographers in 2003. It is an iterated block cipher with 128-, 192-, and 256-bit keys and encrypts 128-bit blocks in 12, 14, and 16 rounds, depending on the key size. It is secure and suitable for most software and hardware implementations on 32-bit and 8-bit processors. It was established as a Korean standard block cipher algorithm in 2004 [ARIAKS] and has been widely used in Korea, especially for government-to-public services. It was included in PKCS #11 in 2007 [ARIAPKCS]. The algorithm specification and object identifiers are described in [RFC5794].</p>
<p><b>ARIA-CTR</b></p>
<p>Section 4.1.1 of [RFC3711] defines AES-128 counter mode encryption, which it refers to as "AES_CM". Section 2 of [RFC6188] defines "AES_192_CM" and "AES_256_CM" in SRTP. ARIA counter modes are defined in the same manner except that each invocation of AES is replaced by that of ARIA [RFC5794], and are denoted by ARIA_128_CTR, ARIA_192_CTR and ARIA_256_CTR respectively, according to the key lengths. The plaintext inputs to the block cipher are formed as in AES-CTR(AES_CM, AES_192_CM, AES_256_CM) and the block cipher outputs are processed as in AES-CTR. Note that, ARIA-CTR MUST be used only in conjunction with an authentication transform.</p>
<p><b>ARIA-GCM</b></p>
<p>GCM (Galois Counter Mode) [GCM][RFC5116] is an AEAD (Authenticated Encryption with Associated Data) block cipher mode. A detailed description of ARIA-GCM is defined similarly as AES-GCM found in [RFC5116][RFC5282].</p>
<h1><a class="anchor" id="SM4E"></a>
SM4 Block Cipher (China)</h1>
<p>See sm4_encryption_spec 15 May 2008 Version 1.03</p>
<p>SMS4 is a Chinese block cipher standard, mandated for use in protecting wireless networks and issued in January 2006. The input, output, and key of SMS4 are each 128 bits. The algorithm has 32 rounds, each of which modifies one of the four 32-bit words that make up the block by xoring it with a keyed function of the other three words. Encryption and decryption have the same structure except that the round key schedule for decryption is the reverse of the round key schedule for encryption</p>
<p><b>1. Terminology (Definitions)</b></p>
<p><b>1.1 Zi and ZiJie (Word and Byte)</b></p>
<p><img class="formulaInl" alt="${Z_2}^{e}$" src="form_27.png"/> is the set of e-bit vectors. Specifically, the elements of <img class="formulaInl" alt="${Z_2}^{32}$" src="form_28.png"/> are called <img class="formulaInl" alt="$ Zi$" src="form_29.png"/> (32-bit words), and the elements of <img class="formulaInl" alt="${Z_2}^{8}$" src="form_30.png"/> are called <img class="formulaInl" alt="$ ZiJie$" src="form_31.png"/> (8-bit characters, or bytes)</p>
<p><b>1.2 S box</b></p>
<p>The S (substitution) box takes in 8 bits and outputs 8 bits. It is written Sbox(.)</p>
<p><b>1.3 Fundamental Operations</b></p>
<p>The two fundamental operations used by this algorithm are:</p>
<ul>
<li>the bitwise XOR of two 32-bit vectors</li>
<li><img class="formulaInl" alt="$ \ll$" src="form_32.png"/> i the circular shift of a 32-bit word, with i bits shifted left</li>
</ul>
<p><b>1.4 Input and output blocks and key</b></p>
<p>The 128-bit input block consists of four 32-bit words <img class="formulaInl" alt="$ MK = (MK_1,MK_2,MK_3,MK_4) or MK_i(i = 0, 1, 2, 3)$" src="form_33.png"/></p>
<p>The round key schedule, derived from the encryption key, is represented by <img class="formulaInl" alt="$ (rk_0, rk_1,...,rk_{31})$" src="form_34.png"/> where each <img class="formulaInl" alt="$ rk_i, i=0,...,31)$" src="form_35.png"/> is 32 bits long</p>
<p>The 128-bit output block consists of four 32-bit words <img class="formulaInl" alt="$ FK = (FK_0, FK_1, FK_2, FK_3)$" src="form_36.png"/></p>
<p>For decryption, the round key schedule is represented by <img class="formulaInl" alt="$ CK = (CK_0,CK_1,...,CK_{31})$" src="form_37.png"/> or</p>
<ul>
<li><img class="formulaInl" alt="$ FK_i, (i = 0,...,3), CK_i, (i = 0,...,31)$" src="form_38.png"/></li>
</ul>
<p><b>2. The round function F</b></p>
<p>This algorithm uses a nonlinear substitution structure, encrypting 32 bits at a time. This is called a <em>one-round exchange</em>. To illustrate, consider a one-round-substitution:</p>
<p>Let the 128-bit input block be the four 32-bit elements</p>
<ul>
<li><img class="formulaInl" alt="$(X_0,X_1,X_2,X_3) \in {({Z_2}^{32})}^{4}$" src="form_39.png"/>, with <img class="formulaInl" alt="$rk \in {Z_2}^{32}$" src="form_40.png"/>, then F is given by</li>
<li><img class="formulaInl" alt="$ F(X_0,X_1,X_2,X_3,rk) = X_0 \oplus T(X_1 \oplus X_2 \oplus X_3 \oplus rk)$" src="form_41.png"/></li>
</ul>
<p><b>2.1 Mixer-substitution T</b></p>
<p>T is a substitution that generates 32 bits from 32 bits <img class="formulaInl" alt="$T : {Z_2}^{32} \mapsto {Z_2}^{32}$" src="form_42.png"/>. This substitution is a reversible process. It consists of a non-linear substitution, <img class="formulaInl" alt="$tau$" src="form_43.png"/>, and a linear substitution L, i.e., <img class="formulaInl" alt="$T(.) = L(\tau(.))$" src="form_44.png"/></p>
<p><b>2.1.1 Non-linear substitution <img class="formulaInl" alt="$\tau$" src="form_45.png"/></b></p>
<p><img class="formulaInl" alt="$\tau$" src="form_45.png"/> applies 4 S-boxes in parallel Let a 32-bit input word be <img class="formulaInl" alt="$A = (a_0, a_1, a_2, a_3) \in {({Z_2}^{8})}^{4}$" src="form_46.png"/>, where each ai is an 8-bit character Let the 32-bit output word be <img class="formulaInl" alt="$B = (b_0, b_1, b_2, b_3) \in {({Z_2}^{8})}^{4}$" src="form_47.png"/>, given by <img class="formulaInl" alt="$(b_0, b_1, b_2, b_3) = \tau(A) = (Sbox(a_0), Sbox(a_1), Sbox(a_2), Sbox(a_3))$" src="form_48.png"/></p>
<p><b>2.1.2 Linear substitution L</b></p>
<p><img class="formulaInl" alt="$B \in {Z_2}^{32}$" src="form_49.png"/>, the 32-bit output word of the non-linear substitution <img class="formulaInl" alt="$tau$" src="form_43.png"/> will be the input word of the linear substitution L. Let <img class="formulaInl" alt="$C \in {Z_2}^{32}$" src="form_50.png"/> be the 32-bit output word generated by L. Then</p>
<ul>
<li><img class="formulaInl" alt="$C = L(B) = B \oplus (B &lt;&lt;&lt; 2) \oplus (B &lt;&lt;&lt; 10) \oplus (B &lt;&lt;&lt; 18) \oplus (B &lt;&lt;&lt; 24)$" src="form_51.png"/></li>
</ul>
<p><b>2.2 S box</b></p>
<p>All Sbox numbers are in hexadecimal notation</p>
<a class="anchor" id="multirow"></a>
<table class="doxtable">
<caption><img class="formulaInl" alt="$ S Box$" src="form_52.png"/></caption>
<tr>
<th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15 </th></tr>
<tr>
<td>d6 </td><td>90 </td><td>e9 </td><td>fe </td><td>cc </td><td>e1 </td><td>3d </td><td>b7 </td><td>16 </td><td>b6 </td><td>14 </td><td>c2 </td><td>28 </td><td>fb </td><td>2c </td><td>05 </td></tr>
<tr>
<td>2b </td><td>67 </td><td>9a </td><td>76 </td><td>2a </td><td>be </td><td>04 </td><td>c3 </td><td>aa </td><td>44 </td><td>13 </td><td>26 </td><td>49 </td><td>86 </td><td>06 </td><td>99 </td></tr>
<tr>
<td>9c </td><td>42 </td><td>50 </td><td>f4 </td><td>91 </td><td>ef </td><td>98 </td><td>7a </td><td>33 </td><td>54 </td><td>0b </td><td>43 </td><td>ed </td><td>cf </td><td>ac </td><td>62 </td></tr>
<tr>
<td>e4 </td><td>b3 </td><td>1c </td><td>a9 </td><td>c9 </td><td>08 </td><td>e8 </td><td>95 </td><td>80 </td><td>df </td><td>94 </td><td>fa </td><td>75 </td><td>8f </td><td>3f </td><td>a6 </td></tr>
<tr>
<td>47 </td><td>07 </td><td>a7 </td><td>fc </td><td>f3 </td><td>73 </td><td>17 </td><td>ba </td><td>83 </td><td>59 </td><td>3c </td><td>19 </td><td>e6 </td><td>85 </td><td>4f </td><td>a8 </td></tr>
<tr>
<td>68 </td><td>6b </td><td>81 </td><td>b2 </td><td>71 </td><td>64 </td><td>da </td><td>8b </td><td>f8 </td><td>eb </td><td>0f </td><td>4b </td><td>70 </td><td>56 </td><td>9d </td><td>35 </td></tr>
<tr>
<td>1e </td><td>24 </td><td>0e </td><td>5e </td><td>63 </td><td>58 </td><td>d1 </td><td>a2 </td><td>25 </td><td>22 </td><td>7c </td><td>3b </td><td>01 </td><td>21 </td><td>78 </td><td>87 </td></tr>
<tr>
<td>d4 </td><td>00 </td><td>46 </td><td>57 </td><td>9f </td><td>d3 </td><td>27 </td><td>52 </td><td>4c </td><td>36 </td><td>02 </td><td>e7 </td><td>a0 </td><td>c4 </td><td>c8 </td><td>9e </td></tr>
<tr>
<td>ea </td><td>bf </td><td>8a </td><td>d2 </td><td>40 </td><td>c7 </td><td>38 </td><td>b5 </td><td>a3 </td><td>f7 </td><td>f2 </td><td>ce </td><td>f9 </td><td>61 </td><td>15 </td><td>a1 </td></tr>
<tr>
<td>e0 </td><td>ae </td><td>5d </td><td>a4 </td><td>9b </td><td>34 </td><td>1a </td><td>55 </td><td>ad </td><td>93 </td><td>32 </td><td>30 </td><td>f5 </td><td>8c </td><td>b1 </td><td>e3 </td></tr>
<tr>
<td>1d </td><td>f6 </td><td>e2 </td><td>2e </td><td>82 </td><td>66 </td><td>ca </td><td>60 </td><td>c0 </td><td>29 </td><td>23 </td><td>ab </td><td>0d </td><td>53 </td><td>4e </td><td>6f </td></tr>
<tr>
<td>d5 </td><td>db </td><td>37 </td><td>45 </td><td>de </td><td>fd </td><td>8e </td><td>2f </td><td>03 </td><td>ff </td><td>6a </td><td>72 </td><td>6d </td><td>6c </td><td>5b </td><td>51 </td></tr>
<tr>
<td>8d </td><td>1b </td><td>af </td><td>92 </td><td>bb </td><td>dd </td><td>bc </td><td>7f </td><td>11 </td><td>d9 </td><td>5c </td><td>41 </td><td>1f </td><td>10 </td><td>5a </td><td>d8 </td></tr>
<tr>
<td>0a </td><td>c1 </td><td>31 </td><td>88 </td><td>a5 </td><td>cd </td><td>7b </td><td>bd </td><td>2d </td><td>74 </td><td>d0 </td><td>12 </td><td>b8 </td><td>e5 </td><td>b4 </td><td>b0 </td></tr>
<tr>
<td>89 </td><td>69 </td><td>97 </td><td>4a </td><td>0c </td><td>96 </td><td>77 </td><td>7e </td><td>65 </td><td>b9 </td><td>f1 </td><td>09 </td><td>c5 </td><td>6e </td><td>c6 </td><td>84 </td></tr>
<tr>
<td>18 </td><td>f0 </td><td>7d </td><td>ec </td><td>3a </td><td>dc </td><td>4d </td><td>20 </td><td>79 </td><td>ee </td><td>5f </td><td>3e </td><td>d7 </td><td>cb </td><td>39 </td><td>48 </td></tr>
</table>
<p>For example, if the input to the Sbox is 'ef', then go to e-th row and f-th column, to find <img class="formulaInl" alt="$ Sbox('ef')='84'$" src="form_53.png"/></p>
<p><b>3. Encryption and decryption</b></p>
<p>Let the reverse substitution <img class="formulaInl" alt="$ R$" src="form_54.png"/> be:</p>
<ul>
<li><img class="formulaInl" alt="$R(A_0,A_1,A_2,A_3) = (A_3,A_2,A_1,A_0),A_i \in {Z_2}^{32}, i = 0,1,2,3$" src="form_55.png"/></li>
</ul>
<p>Let the plaintext input be <img class="formulaInl" alt="$(X_0,X_1,X_2,X_3) \in {({Z_2}^{32})}^{4}$" src="form_39.png"/>, the ciphertext output be <img class="formulaInl" alt="$(Y_0,Y_1,Y_2,Y_3) \in $" src="form_56.png"/> <img class="formulaInl" alt="${({Z_2}^{32})}^{4}$" src="form_57.png"/>, and the encrypting key be <img class="formulaInl" alt="$rk_i \in {Z_2}^{32}, i = 0,1,2,...,31$" src="form_58.png"/></p>
<p>Then encryption proceeds as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ X_{i+4} = F(X_i,X_{i+1},X_{i+2},X_{i+3}, rk_i) = Xi \oplus T(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus rk_i)$" src="form_59.png"/> where <img class="formulaInl" alt="$ i = 0,1,...,31$" src="form_60.png"/></li>
<li><img class="formulaInl" alt="$(Y_0, Y_1, Y_2, Y_3) = R(X_{32},X_{33},X_{34},X_{35}) = (X_{35},X_{34},X_{33},X_{32})$" src="form_61.png"/></li>
</ul>
<p>This algorithm's encryption and decryption methods have the same structure, except the order in which the round keys are used is reversed</p>
<p>The key order for encryption is: <img class="formulaInl" alt="$(rk_0, rk_1,...,rk_{31})$" src="form_62.png"/>. The key order for decryption is:</p>
<ul>
<li><img class="formulaInl" alt="$(rk_{31}, rk_{30},...,rk_0)$" src="form_63.png"/></li>
</ul>
<p><b>4. Key expansion when encrypting</b></p>
<p>The <img class="formulaInl" alt="$rk_i$" src="form_64.png"/> round key used for encrypting in this algorithm is derived from the encryption key MK.</p>
<p>Let <img class="formulaInl" alt="$MK = (MK_0,MK_1,MK_2,MK_3), MK_i \in {Z_2}^{32}, i = 0,1,2,3;$" src="form_65.png"/></p>
<ul>
<li><img class="formulaInl" alt="$K_i \in {Z_2}^{32}, i = 0,1,...,31;$" src="form_66.png"/></li>
<li><img class="formulaInl" alt="$rk_i \in {Z_2}^{32}, i = 0,1,...,31$" src="form_67.png"/>;</li>
</ul>
<p>the derivation proceeds as follows:</p>
<p>First,</p>
<ul>
<li><img class="formulaInl" alt="$(K_0,K_1,K_2,K_3) = (MK_0 \oplus FK_0; MK_1 \oplus FK_1; MK_2 \oplus FK_2; MK_3 \oplus FK_3)$" src="form_68.png"/></li>
</ul>
<p>Then for i = 0,1,2,...,31:</p>
<ul>
<li><img class="formulaInl" alt="$rk_i = K_{i+4} = K_i \oplus T\prime(K_{i+1} \oplus K_{i+2} \oplus K_{i+3} \oplus CK_i)$" src="form_69.png"/></li>
</ul>
<p>Notes:</p>
<ol type="1">
<li>T&amp;prime substitution uses the same T as in encryption, except the linear substitution L is changed to L&amp;prime: L&amp;prime <img class="formulaInl" alt="$(B) = B \oplus (B &lt;&lt;&lt; 13) \oplus (B &lt;&lt;&lt; 23)$" src="form_70.png"/>;</li>
<li>The system parameter <img class="formulaInl" alt="$ FK$" src="form_71.png"/> given in hexadecimal notation is</li>
</ol>
<ul>
<li><img class="formulaInl" alt="$FK_0 = (a3b1bac6), FK_1 = (56aa3350), FK_2 = (677d9197), FK_3 = (b27022dc)$" src="form_72.png"/></li>
</ul>
<ol type="1">
<li>The constant parameter <img class="formulaInl" alt="$ CK$" src="form_73.png"/> is calculated as follows:</li>
</ol>
<p>Let <img class="formulaInl" alt="$ck_{i,j}$" src="form_74.png"/> be the j-th byte of <img class="formulaInl" alt="$CK_{i,j}(i = 0,1,...,31; j = 0,1,2,3)$" src="form_75.png"/>, i.e., <img class="formulaInl" alt="$CK_i = (ck_{i,0}, ck_{i,1}; ck_{i,2}; ck_{i,3}) \in {({Z_2}^{8})}^{4}, then ck_{i,j} = (4i + j) \times (mod 256)$" src="form_76.png"/></p>
<p>The 32 constants <img class="formulaInl" alt="$CK_i$" src="form_77.png"/> are represented in hexadecimal as tabulated below:</p>
<a class="anchor" id="constants"></a>
<table class="doxtable">
<caption><img class="formulaInl" alt="$ CK_i$" src="form_78.png"/></caption>
<tr>
<th>0</th><th>1</th><th>2</th><th>3 </th></tr>
<tr>
<td>00070e15 </td><td>1c232a31 </td><td>383f464d </td><td>545b6269 </td></tr>
<tr>
<td>70777e85 </td><td>8c939aa1 </td><td>a8afb6bd </td><td>c4cbd2d9 </td></tr>
<tr>
<td>e0e7eef5 </td><td>fc030a11 </td><td>181f262d </td><td>343b4249 </td></tr>
<tr>
<td>50575e65 </td><td>6c737a81 </td><td>888f969d </td><td>a4abb2b9 </td></tr>
<tr>
<td>c0c7ced5 </td><td>dce3eaf1 </td><td>f8ff060d </td><td>141b2229 </td></tr>
<tr>
<td>30373e45 </td><td>4c535a61 </td><td>686f767d </td><td>848b9299 </td></tr>
<tr>
<td>a0a7aeb5 </td><td>bcc3cad1 </td><td>d8dfe6ed </td><td>f4fb0209 </td></tr>
<tr>
<td>10171e25 </td><td>2c333a41 </td><td>484f565d </td><td>646b7279 </td></tr>
</table>
<h1><a class="anchor" id="CAMELLIAC"></a>
Camellia Block Cipher (Japan)</h1>
<div class="image">
<img src="CamelliaLogo75.png" alt="CamelliaLogo75.png"/>
</div>
 <p>See <a href="https://en.wikipedia.org/wiki/Camellia_(cipher)">https://en.wikipedia.org/wiki/Camellia_(cipher)</a> <br />
 See <a href="https://info.isl.ntt.co.jp/crypt/eng/camellia/dl/01espec.pdf">https://info.isl.ntt.co.jp/crypt/eng/camellia/dl/01espec.pdf</a></p>
<p>In cryptography, Camellia is a symmetric key block cipher with a block size of 128 bits and key sizes of 128, 192 and 256 bits. It was jointly developed by Mitsubishi Electric and NTT of Japan. The cipher has been approved for use by the ISO/IEC, the European Union's NESSIE project and the Japanese CRYPTREC project. The cipher has security levels and processing abilities comparable to the Advanced Encryption Standard</p>
<p>The cipher was designed to be suitable for both software and hardware implementations, from low-cost smart cards to high-speed network systems. It is part of the Transport Layer Security (TLS) cryptographic protocol designed to provide communications security over a computer network such as the Internet</p>
<p>The cipher was named for the flower Camellia japonica, which is known for being long-lived as well as because the cipher was developed in Japan</p>
<p><b>Design</b></p>
<p>Camellia is a Feistel cipher with either 18 rounds (when using 128-bit keys) or 24 rounds (when using 192- or 256-bit keys). Every six rounds, a logical transformation layer is applied: the so-called "FL-function" or its inverse. Camellia uses four 8×8-bit S-boxes with input and output affine transformations and logical operations. The cipher also uses input and output key whitening. The diffusion layer uses a linear transformation based on a matrix with a branch number of 5</p>
<p><b>Security analysis</b></p>
<p>Camellia is considered a modern, safe cipher. Even using the smaller key size option (128 bits), it's considered infeasible to break it by brute-force attack on the keys with current technology. There are no known successful attacks that weaken the cipher considerably. The cipher has been approved for use by the ISO/IEC, the European Union's NESSIE project and the Japanese CRYPTREC project. The Japanese cipher has security levels and processing abilities comparable to the AES/Rijndael cipher</p>
<p>Camellia is a block cipher which can be completely defined by minimal systems of multivariate polynomials:</p>
<ul>
<li>The Camellia (as well as AES) S-boxes can be described by a system of 23 quadratic equations in 80 terms</li>
<li>The key schedule can be described by 1,120 equations in 768 variables using 3,328 linear and quadratic terms</li>
<li>The entire block cipher can be described by 5,104 equations in 2,816 variables using 14,592 linear and quadratic terms</li>
<li>In total, 6,224 equations in 3,584 variables using 17,920 linear and quadratic terms are required</li>
<li>The number of free terms is 11,696, which is approximately the same number as for AES</li>
</ul>
<p>Theoretically, such properties might make it possible to break Camellia (and AES) using an algebraic attack, such as extended sparse linearisation, in the future, provided that the attack becomes feasible</p>
<h1><a class="anchor" id="SEEDC"></a>
SEED Block Cipher (Korea)</h1>
<p>SEED is a block cipher developed by the Korea Internet &amp; Security Agency (KISA). It is used broadly throughout South Korean industry, but seldom found elsewhere. It gained popularity in Korea because 40-bit encryption was not considered strong enough, so the Korea Information Security Agency developed its own standard. However, this decision has historically limited the competition of web browsers in Korea, as no major SSL libraries or web browsers supported the SEED algorithm, requiring users to use an ActiveX control in Internet Explorer for secure web sites</p>
<p>On April 1, 2015 the Ministry of Science, ICT and Future Planning (MSIP) announced its plan to remove the ActiveX dependency from at least 90 percent of the country's top 100 websites by 2017. Instead, HTML5-based technologies will be employed as they operate on many platforms, including mobile devices. Starting with the private sector, the ministry plans to expand this further to ultimately remove this dependency from public websites as well</p>
<p><b>Design</b></p>
<p>SEED is a 16-round Feistel network with 128-bit blocks and a 128-bit key. It uses two 8 × 8 S-boxes which, like those of SAFER, are derived from discrete exponentiation (in this case, x247 and x251 – plus some "incompatible
 operations"). It also has some resemblance to MISTY1 in the recursiveness of its structure: the 128-bit full cipher is a Feistel network with an F-function operating on 64-bit halves, while the F-function itself is a Feistel network composed of a G-function operating on 32-bit halves. However the recursion does not extend further because the G-function is not a Feistel network. In the G-function, the 32-bit word is considered as four 8-bit bytes, each of which is passed through one or the other of the S-boxes, then combined in a moderately complex set of boolean functions such that each output bit depends on 3 of the 4 input bytes</p>
<p>SEED has a fairly complex key schedule, generating its thirty-two 32-bit subkeys through application of its G-function on a series of rotations of the raw key, combined with round constants derived (as in TEA) from the Golden ratio</p>
<h1><a class="anchor" id="ZUCAlg"></a>
ZUC Encrytpion Algorithm (128-EEA3 and 128-EIA3)</h1>
<dl class="section see"><dt>See also</dt><dd>Specification of the 3GPP Confidentiality and Integrity Algorithms 128-EEA3 and 128-EIA3 Document 2: ZUC Specification</dd></dl>
<p><b>General structure of the algorithm</b></p>
<p>ZUC has three logical layers, see the figure below. The top layer is a linear feedback shift register (LFSR) of 16 stages, the middle layer is for bit-reorganization ( BR), and the bottom layer is a nonlinear function F</p>
<div class="image">
<img src="ZUCStructure.png" alt="ZUCStructure.png"/>
<div class="caption">
General Structure of ZUC</div></div>
<p><b>The linear feedback shift register (LFSR)</b></p>
<p>The linear feedback shift register (LFSR) has 16 of 31-bit cells <img class="formulaInl" alt="$ (s_0, s_1,\cdots,s_{15})$" src="form_79.png"/>. Each cell <img class="formulaInl" alt="$ s_i (0 \leq i \leq 15)$" src="form_80.png"/> is restricted to take values from the following set <b> <img class="formulaInl" alt="$ \{1,2,3,\cdots,{2}^{31} – 1\}$" src="form_81.png"/></b>. The LFSR has 2 modes of operations: the initialization mode and the working mode</p>
<p>In the initialization mode, the LFSR receives a 31-bit input word u, which is obtained by removing the rightmost bit from the 32-bit output W of the nonlinear function F, i.e., u=W&gt;&gt;1. More specifically, the initialization mode works as follows: <br />
 LFSRWithInitialisationMode(u) {</p>
<ol type="1">
<li><img class="formulaInl" alt="$ v={2}^{15}s_{15}+{2}^{17}s_{13}+{2}_{21}s_{10}+{2}^{20}s_4+(1+{2}^{8})s_0$" src="form_82.png"/> mod <img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></li>
<li><img class="formulaInl" alt="$ s_{16}=(v+u)$" src="form_84.png"/> mod <img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></li>
<li><img class="formulaInl" alt="$ If s_{16}=0$" src="form_85.png"/>, then set <img class="formulaInl" alt="$s_{16}={2}^{31}-1$" src="form_86.png"/></li>
<li><img class="formulaInl" alt="$ (s_1,s_2,\cdots,s_{15},s_{16})\rightarrow(s_0,s_1,\cdots,s_{14},s_{15})$" src="form_87.png"/> <br />
 } <br />
 In the working mode, the LFSR does not receive any input, and it works as follows: <br />
 LFSRWithWorkMode() {</li>
</ol>
<ol type="1">
<li><img class="formulaInl" alt="$ s_{16}={2}^{15}s_15+{2}^{17}s_13+{2}^{21}s_10+{2}^{20}s_4+(1+{2}^{8})s_0$" src="form_88.png"/> mod <img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></li>
<li><img class="formulaInl" alt="$ If s_{16}=0$" src="form_85.png"/>, then set <img class="formulaInl" alt="$ s_{16}={2}^{31}-1$" src="form_89.png"/></li>
<li><img class="formulaInl" alt="$ (s_1,s_2,\cdots,s_{15},s_{16})\rightarrow(s_0,s_1,\cdots,s_{14},s_{15})$" src="form_87.png"/></li>
</ol>
<p>} <br />
 Informative note: Since the multiplication of a 31-bit string s by <img class="formulaInl" alt="$ {2}^{i}$" src="form_90.png"/> over <img class="formulaInl" alt="$ GF({2}^{31}-1)$" src="form_91.png"/> can be implemented by a cyclic shift of s to the left by i bits, only addition modulo <img class="formulaInl" alt="$ {2}^{31}-1$" src="form_92.png"/> is needed in step 1 of the above functions. More precisely, step 1 of the function LFSRWithInitialisationMode can be implemented by <br />
 <img class="formulaInl" alt="$ v=(s_{15} &lt;&lt;&lt;_{31} 15)+(s_{13} &lt;&lt;&lt;_{31} 17)+(s_{10} &lt;&lt;&lt;_{31} 21)+(s_4 &lt;&lt;&lt;_{31} 20)+(s_0 &lt;&lt;&lt;_{31} 8)+s_0$" src="form_93.png"/> mod <img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></p>
<p>and the same implementation is needed for step 1 of the function LFSRWithWorkMode</p>
<p>Informative note: For two elements <img class="formulaInl" alt="$ a,b$" src="form_94.png"/> over <img class="formulaInl" alt="$ GF({2}^{31}-1)$" src="form_91.png"/>, the computation of <img class="formulaInl" alt="$ v=a+b$" src="form_95.png"/> mod <img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/> can be done by</p>
<p>(1) compute v=a+b and</p>
<p>(2) if the carry bit is 1, then set v=v+1</p>
<p>Alternatively (and better if the implementation should resist possible timing attacks):</p>
<p>(1) compute w=a+b, where w is a 32-bit value; and</p>
<p>(2) set v = (least significant 31 bits of w) + (most significant bit of w) <br />
 <b>The bit-reorganization</b></p>
<p>The middle layer of the algorithm is the bit-reorganization. It extracts 128 bits from the cells of the LFSR and forms 4 of 32-bit words, where the first three words will be used by the nonlinear function F in the bottom layer, and the last word will be involved in producing the keystream</p>
<p>Let <img class="formulaInl" alt="$ s_0, s_2, s_5, s_7, s_9, s_{11}, s_{14}, s_{15}$" src="form_96.png"/> be 8 cells of LFSR as in section 3.2. Then the bitreorganization forms 4 of 32-bit words <img class="formulaInl" alt="$ X_0, X_1, X_2, X_3$" src="form_97.png"/> from the above cells as follows: <br />
 Bitreorganization() {</p>
<ol type="1">
<li><img class="formulaInl" alt="$ X_0=s_{15H} \parallel s_{14L}$" src="form_98.png"/></li>
<li><img class="formulaInl" alt="$ X_1=s_{11L} \parallel s_{9H}$" src="form_99.png"/></li>
<li><img class="formulaInl" alt="$ X_2=s_{7L} \parallel s_{5H}$" src="form_100.png"/></li>
<li><img class="formulaInl" alt="$ X_3=s_{2L} \parallel s_{0H}$" src="form_101.png"/></li>
</ol>
<p>} <br />
 Note: The <img class="formulaInl" alt="$ s_i$" src="form_102.png"/> are 31-bit integers, so <img class="formulaInl" alt="$ s_{iH}$" src="form_103.png"/> means bits 30...15 and not 31...16 of <img class="formulaInl" alt="$ s_i, for 0 \leq i \leq 15$" src="form_104.png"/></p>
<p><b>The nonlinear function F</b></p>
<p>The nonlinear function F has 2 of 32-bit memory cells <img class="formulaInl" alt="$ R_1$" src="form_105.png"/> and <img class="formulaInl" alt="$ R_2$" src="form_106.png"/>. Let the inputs to F be <img class="formulaInl" alt="$ X_0, X_1$" src="form_107.png"/> and <img class="formulaInl" alt="$ X_2$" src="form_108.png"/>, which come from the outputs of the bit-reorganization (see section 3.3), then the function F outputs a 32-bit word W. The detailed process of F is as follows: <br />
 F ( <img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/>) {</p>
<ol type="1">
<li><img class="formulaInl" alt="$ W=(X_0 \oplus R_1) \oplus R_2$" src="form_110.png"/></li>
<li><img class="formulaInl" alt="$ W_1=R_1 \oplus X_1$" src="form_111.png"/></li>
<li><img class="formulaInl" alt="$ W_2=R_2 \oplus X_2$" src="form_112.png"/></li>
<li><img class="formulaInl" alt="$ R_1=S(L_1(W_{1L} \parallel W_{2H}))$" src="form_113.png"/></li>
<li><img class="formulaInl" alt="$ R_2=S(L_2(W_{2L} \parallel W_{1H}))$" src="form_114.png"/></li>
</ol>
<p>} <br />
 where <em>S</em> is a 32×32 S-box, see section 3.4.1, <img class="formulaInl" alt="$ L_1$" src="form_115.png"/> and <img class="formulaInl" alt="$ L_2$" src="form_116.png"/> are linear transforms as defined in section 3.4.2</p>
<p><b>The S-box S</b></p>
<p>The 32×32 S-box S is composed of 4 juxtaposed 8×8 S-boxes, i.e., S=( <img class="formulaInl" alt="$ S_0,S_1,S_2,S_3$" src="form_117.png"/>), where <img class="formulaInl" alt="$ S_0=S_2$" src="form_118.png"/>, <img class="formulaInl" alt="$ S_1=S_3$" src="form_119.png"/>. The definitions of <img class="formulaInl" alt="$ S_0$" src="form_120.png"/> and <img class="formulaInl" alt="$ S_1$" src="form_121.png"/> can be found in table 3.1 and table 3.2 respectively</p>
<p>Let x be an 8-bit input to <img class="formulaInl" alt="$ S_0$" src="form_120.png"/> (or <img class="formulaInl" alt="$ S_1$" src="form_121.png"/>). Write x into two hexadecimal digits as <img class="formulaInl" alt="$ x=h \parallel l$" src="form_122.png"/>, then the entry at the intersection of the h-th row and the l-th column in table 3.1 (or table 3.2) is the output of <img class="formulaInl" alt="$ S_0$" src="form_120.png"/> (or <img class="formulaInl" alt="$ S_1$" src="form_121.png"/>)</p>
<div class="image">
<img src="SBOX_S0.png" alt="SBOX_S0.png"/>
<div class="caption">
The S-Box S0</div></div>
<div class="image">
<img src="SBOX_S1.png" alt="SBOX_S1.png"/>
<div class="caption">
The S-Box S1</div></div>
<p><b>The linear transforms L1 and L2</b></p>
<p>Both L1 and L2 are linear transforms from 32-bit words to 32-bit words, and are defined as follows: <br />
 <img class="formulaInl" alt="$ L_1(X)=X \oplus (X &lt;&lt;&lt;_{32} 2) \oplus (X &lt;&lt;&lt;_{32} 10) \oplus (X &lt;&lt;&lt;_{32} 18) \oplus (X &lt;&lt;&lt;_{32} 24)$" src="form_123.png"/></p>
<p><img class="formulaInl" alt="$ L_2(X)=X \oplus (X &lt;&lt;&lt;_{32} 8) \oplus (X &lt;&lt;&lt;_{32} 14) \oplus (X &lt;&lt;&lt;_{32} 22) \oplus (X &lt;&lt;&lt;_{32} 30)$" src="form_124.png"/></p>
<p><b>Key loading</b></p>
<p>The key loading procedure will expand the initial key and the initial vector into 16 of 31-bit integers as the initial state of the LFSR. Let the 128-bit initial key k and the 128-bit initial vector iv be <br />
 <img class="formulaInl" alt="$ k=k_0 \parallel k_1 \parallel k_2 \parallel \cdots \parallel k_{15}$" src="form_125.png"/></p>
<p>and <br />
 <img class="formulaInl" alt="$ iv=iv_0 \parallel iv_1 \parallel iv_2 \parallel \cdots \parallel iv_{15}$" src="form_126.png"/></p>
<p>respectively, where <img class="formulaInl" alt="$ k_i$" src="form_127.png"/> and <img class="formulaInl" alt="$ iv_i, 0\leq i\leq 15$" src="form_128.png"/>, are all bytes. Then k and iv are loaded to the cells <img class="formulaInl" alt="$ s_0, s_1,\cdots, s_{15}$" src="form_129.png"/> of LFSR as follows: <br />
</p><ol type="1">
<li>Let D be a 240-bit long constant string composed of 16 substrings of 15 bits: <br />
 <img class="formulaInl" alt="$ D=d_0 \parallel d_1 \parallel \cdots \parallel d_{15}$" src="form_130.png"/></li>
</ol>
<p>where <br />
 <img class="formulaInl" alt="$ d00 = 100010011010111_2 $" src="form_131.png"/></p>
<p><img class="formulaInl" alt="$ d01 = 010011010111100_2 $" src="form_132.png"/></p>
<p><img class="formulaInl" alt="$ d02 = 110001001101011_2 $" src="form_133.png"/></p>
<p><img class="formulaInl" alt="$ d03 = 001001101011110_2 $" src="form_134.png"/></p>
<p><img class="formulaInl" alt="$ d04 = 101011110001001_2 $" src="form_135.png"/></p>
<p><img class="formulaInl" alt="$ d05 = 011010111100010_2 $" src="form_136.png"/></p>
<p><img class="formulaInl" alt="$ d06 = 111000100110101_2 $" src="form_137.png"/></p>
<p><img class="formulaInl" alt="$ d07 = 000100110101111_2 $" src="form_138.png"/></p>
<p><img class="formulaInl" alt="$ d08 = 100110101111000_2 $" src="form_139.png"/></p>
<p><img class="formulaInl" alt="$ d09 = 010111100010011_2 $" src="form_140.png"/></p>
<p><img class="formulaInl" alt="$ d10 = 110101111000100_2 $" src="form_141.png"/></p>
<p><img class="formulaInl" alt="$ d11 = 001101011110001_2 $" src="form_142.png"/></p>
<p><img class="formulaInl" alt="$ d12 = 101111000100110_2 $" src="form_143.png"/></p>
<p><img class="formulaInl" alt="$ d13 = 011110001001101_2 $" src="form_144.png"/></p>
<p><img class="formulaInl" alt="$ d14 = 111100010011010_2 $" src="form_145.png"/></p>
<p><img class="formulaInl" alt="$ d15 = 100011110101100_2 $" src="form_146.png"/></p>
<ol type="1">
<li><img class="formulaInl" alt="$ For 0 \leq i \leq 15, let s_i=k_i \parallel d_i \parallel iv_i$" src="form_147.png"/></li>
</ol>
<p><b>The execution of ZUC</b></p>
<p>The execution of ZUC has two stages: the initialization stage and the working stage</p>
<p><b>The initialization stage</b></p>
<p>During the initialization stage, the algorithm calls the key loading procedure (see section 3.5) to load the 128-bit initial key k and the 128-bit initial vector iv into the LFSR, and set the 32bit memory cells R1 and R2 to be all 0. Then the cipher runs the following operations 32 times:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>w=F( <img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/>);</li>
<li>LFSRWithInitialisationMode(w &gt;&gt; 1)</li>
</ol>
<p><b>The working stage</b></p>
<p>After the initialization stage, the algorithm moves into the working stage. At the working stage, the algorithm executes the following operations once, and discards the output W of F:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>F( <img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/>);</li>
<li>LFSRWithWorkMode()</li>
</ol>
<p>Then the algorithm goes into the stage of producing keystream, i.e., for each iteration, the following operations are executed once, and a 32-bit word Z is produced as an output:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>Z=F( <img class="formulaInl" alt="$ X_0, X_1, X_2) \oplus X3$" src="form_148.png"/>;</li>
<li>LFSRWithWorkMode()</li>
</ol>
<h1><a class="anchor" id="SNOWE"></a>
Snow3g Stream Cipher (UEA2 and UIA2)</h1>
<dl class="section see"><dt>See also</dt><dd>Specification of the 3GPP Confidentiality and Integrity Algorithms UEA2 and UIA2 Document 2: SNOW 3G Specification</dd></dl>
<p>SNOW 3G is a word-oriented stream cipher that generates a sequence of 32-bit words under the control of a 128-bit key and a 128-bit initialisation variable. These words can be used to mask the plaintext. First a key initialisation is performed, i.e. the cipher is clocked without producing output, see 4.1. Then with every clock tick it produces a 32-bit word of output</p>
<p><b>Functions used in different Components of SNOW 3G</b></p>
<p><b>MULx</b> maps 16 bits to 8 bits. Let V and c be 8-bit input values. Then MULx is defined:</p>
<p>If the leftmost (i.e. the most significant) bit of V equals 1, then</p>
<p><img class="formulaInl" alt="$ MULx(V, c) = (V &lt;&lt;_8 1) \oplus c, else MULx(V, c) = V &lt;&lt;_8 1$" src="form_149.png"/></p>
<p><b>MULxPOW</b> maps 16 bits and an positive integer i to 8 bit. Let V and c be 8-bit input values, then MULxPOW(V, i, c) is recursively defined:</p>
<p>If i equals 0, then <img class="formulaInl" alt="$ MULxPOW(V, i, c) = V$" src="form_150.png"/>, else <img class="formulaInl" alt="$ MULxPOW(V, i, c) = MULx(MULxPOW(V, i-1, c), c)$" src="form_151.png"/></p>
<p><b>Linear Feedback Shift Register (LFSR)</b></p>
<p>The Linear Feedback Shift Register (LFSR) consists of sixteen stages <img class="formulaInl" alt="$ s_0, s_1, s_2,\cdots, s_{15}$" src="form_152.png"/> each holding 32 bits</p>
<p><b>Finite State Machine (FSM)</b></p>
<p>The Finite State Machine (FSM) has three 32-bit registers R1, R2 and R3. The S-boxes S1 and S2 are used to update the registers R2 and R3</p>
<p><b>The 32x32-bit S-Box S1</b></p>
<p>The S-Box <img class="formulaInl" alt="$ S_1$" src="form_121.png"/> maps a 32-bit input to a 32-bit output. Let <img class="formulaInl" alt="$ w = w_0 || w_1 || w_2 || w_3$" src="form_153.png"/> the 32-bit input with <img class="formulaInl" alt="$ w_0$" src="form_154.png"/> the most and <img class="formulaInl" alt="$ w3$" src="form_155.png"/> the least significant byte</p>
<p>Let <img class="formulaInl" alt="$ S_1(w)= r_0 || r_1 || r_2 || r_3$" src="form_156.png"/> with <img class="formulaInl" alt="$ r_0$" src="form_157.png"/> the most and <img class="formulaInl" alt="$ r_3$" src="form_158.png"/> the least significant byte. We use the 8 to 8 bit Rijndael S-Box <img class="formulaInl" alt="$ S_R$" src="form_159.png"/> defined in 5.1</p>
<p>Then <img class="formulaInl" alt="$ r_0, r_1, r_2, r_3$" src="form_160.png"/> are defined as</p>
<p><img class="formulaInl" alt="$ r_0= MULx(S_R(w_0), 0x1B) \oplus S_R(w_1) \oplus S_R(w_2) \oplus MULx(S_R(w_3), 0x1B) \oplus S_R(w_3)$" src="form_161.png"/></p>
<p><img class="formulaInl" alt="$ r_1= MULx(S_R(w_0), 0x1B) \oplus S_R(w_0) \oplus MULx(S_R(w_1), 0x1B) \oplus S_R(w_2) \oplus S_R(w_3)$" src="form_162.png"/></p>
<p><img class="formulaInl" alt="$ r_2= S_R(w_0) \oplus MULx(S_R(w_1), 0x1B) \oplus S_R(w_1) \oplus MULx(S_R(w_2), 0x1B) \oplus S_R(w_3)$" src="form_163.png"/></p>
<p><img class="formulaInl" alt="$ r_3= S_R(w_0) \oplus S_R(w_1) \oplus MULx(S_R(w_2), 0x1B) \oplus S_R(w_2) \oplus MULx(S_R(w_3), 0x1B)$" src="form_164.png"/></p>
<p><b>The 32x32-bit S-Box S2</b></p>
<p>The S-Box <img class="formulaInl" alt="$ S_2$" src="form_165.png"/> maps a 32-bit input to a 32-bit output. Let <img class="formulaInl" alt="$ w = w_0 || w_1 || w_2 || w_3$" src="form_153.png"/> the 32-bit input with <img class="formulaInl" alt="$ w_0$" src="form_154.png"/> the most and <img class="formulaInl" alt="$ w_3$" src="form_166.png"/> the least significant byte. Let <img class="formulaInl" alt="$ S_2(w)= r_0 || r_1 || r_2 || r_3$" src="form_167.png"/> with <img class="formulaInl" alt="$ r0$" src="form_168.png"/> the most and <img class="formulaInl" alt="$ r3$" src="form_169.png"/> the least significant byte. We use the 8 to 8 bit S-Box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/> defined in 5.2</p>
<p>Then <img class="formulaInl" alt="$ r_0, r_1, r_2, r_3$" src="form_160.png"/> are defined as</p>
<p><img class="formulaInl" alt="$ r_0= MULx(S_Q(w_0), 0x69) \oplus S_Q(w_1) \oplus S_Q(w_2) \oplus MULx(S_Q(w_3), 0x69) \oplus SQ(w3)$" src="form_171.png"/></p>
<p><img class="formulaInl" alt="$ r_1= MULx(S_Q(w_0), 0x69) \oplus S_Q(w_0) \oplus MULx(S_Q(w_1), 0x69) \oplus S_Q(w_2) \oplus S_Q(w_3)$" src="form_172.png"/></p>
<p><img class="formulaInl" alt="$ r_2= S_Q(w_0) \oplus MULx(S_Q(w_1), 0x69) \oplus S_Q(w_1) \oplus MULx(S_Q(w_2), 0x69) \oplus S_Q(w_3)$" src="form_173.png"/></p>
<p><img class="formulaInl" alt="$ r_3= S_Q(w_0) \oplus S_Q(w_1) \oplus MULx(S_Q(w_2), 0x69) \oplus S_Q(w_2) \oplus MULx(S_Q(w_3), 0x69)$" src="form_174.png"/></p>
<h2><a class="anchor" id="TCOP"></a>
The Clocking Operations</h2>
<p><b>Clocking the LFSR</b></p>
<p>The clocking of the LFSR has two different modes of operation, the Initialisation Mode 3.4.4 and the Keystream Mode 3.4.5. In both modes the functions <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> and <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> are used which are defined in 3.4.2 resp. 3.4.3</p>
<p><b>The function <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/></b></p>
<p>The function <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> maps 8 bits to 32 bits. Let c be the 8-bit input, then <img class="formulaInl" alt="$ MUL_α$" src="form_175.png"/> is defined as</p>
<p><img class="formulaInl" alt="$ MUL_α(c) = (MULxPOW(c, 23, 0xA9) || MULxPOW(c, 245, 0xA9) || MULxPOW(c, 48, 0xA9) || MULxPOW(c, 239, 0xA9))$" src="form_177.png"/></p>
<p><b>The function <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/></b></p>
<p>The function <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> maps 8 bits to 32 bits. Let c be the 8-bit input, then <img class="formulaInl" alt="$ DIV_α$" src="form_176.png"/> is defined as</p>
<p><img class="formulaInl" alt="$ DIV_α(c) = (MULxPOW(c, 16, 0xA9) || MULxPOW(c, 39, 0xA9) || MULxPOW(c, 6, 0xA9) || MULxPOW(c, 64, 0xA9))$" src="form_178.png"/></p>
<p><b>Initialisation Mode</b></p>
<p>In the Initialisation Mode the LFSR receives a 32-bit input word F, which is the output of the FSM</p>
<p>Let <img class="formulaInl" alt="$ s_0 = s_{0,0} || s_{0,1} || s_{0,2} || s_{0,3}$" src="form_179.png"/> with <img class="formulaInl" alt="$ s_{0,0}$" src="form_180.png"/> being the most and <img class="formulaInl" alt="$ s_{0,3}$" src="form_181.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_0$" src="form_182.png"/>.</p>
<p>Let <img class="formulaInl" alt="$ s_{11} = s_{11,0} || s_{11,1} || s_{11,2} || s_{11,3}$" src="form_183.png"/> with <img class="formulaInl" alt="$ s_{11,0}$" src="form_184.png"/> being the most and <img class="formulaInl" alt="$ s_{11,3}$" src="form_185.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_{11}$" src="form_186.png"/></p>
<p>Compute the intermediate value v as</p>
<p><img class="formulaInl" alt="$ v = (s_{0,1} || s_{0,2} || s_{0,3} || 0x00) \oplus MUL_α(s_{0,0}) \oplus s_2 \oplus (0x00 || s_{11,0} || s_{11,1} || s_{11,2}) \oplus DIV_α(s_{11,3}) \oplus F$" src="form_187.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ s_0=s_1, s_1=s_2, s_2=s_3, s_3=s_4, s_4=s_5, s_5=s_6, s_6=s_7, s_7=s_8$" src="form_188.png"/></p>
<p><img class="formulaInl" alt="$ s_8=s_9, s_9=s_{10}, s_{10}=s_{11}, s_{11}=s_{12}, s_{12}=s_{13}, s_{13}=s_{14}, s_{14}=s_{15}, s_{15} = v$" src="form_189.png"/></p>
<p><b>Keystream Mode</b></p>
<p>In the Keystream Mode the LFSR does not receive any input</p>
<p>Let <img class="formulaInl" alt="$ s_0 = s_{0,0} || s_{0,1} || s_{0,2} || s_{0,3}$" src="form_179.png"/> with <img class="formulaInl" alt="$ s_{0,0}$" src="form_180.png"/> being the most and <img class="formulaInl" alt="$ s_{0,3}$" src="form_181.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_0$" src="form_182.png"/></p>
<p>Let <img class="formulaInl" alt="$ s_11 = s_{11,0} || s_{11,1} || s_{11,2} || s_{11,3}$" src="form_190.png"/> with <img class="formulaInl" alt="$ s_{11,0}$" src="form_184.png"/> being the most and <img class="formulaInl" alt="$ s_{11,3}$" src="form_185.png"/> being the least significant byte of <img class="formulaInl" alt="$ s_11$" src="form_191.png"/></p>
<p>Compute the intermediate value v as</p>
<p>v = <img class="formulaInl" alt="$ (s_{0,1} || s_{0,2} || s_{0,3} || 0x00) \oplus MUL_α(s_{0,0}) \oplus s_2 \oplus (0x00 || s_{11,0} || s_{11,1} || s_{11,2}) \oplus DIV_α(s_{11,3})$" src="form_192.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ s_0=s_1, s_1=s_2, s_2=s_3, s_3=s_4, s_4=s_5, s_5=s_6, s_6=s_7, s_7=s_8$" src="form_188.png"/></p>
<p><img class="formulaInl" alt="$ s_8=s_9, s_9=s_{10}, s_{10}=s_{11}, s_{11}=s_{12}, s_{12}=s_{13}, s_{13}=s_{14}, s_{14}=s_{15}, s_{15}=v$" src="form_193.png"/></p>
<p><b>Clocking the FSM</b></p>
<p>The FSM has two input words <img class="formulaInl" alt="$ s_{15}$" src="form_194.png"/> and <img class="formulaInl" alt="$ s_5$" src="form_195.png"/> from the LFSR. It produces a 32-bit output word F:</p>
<p><img class="formulaInl" alt="$ F = (s_{15} \oplus R1) \oplus R2$" src="form_196.png"/></p>
<p>Then the registers are updated. Compute the intermediate value r as</p>
<p><img class="formulaInl" alt="$ r = R2 \oplus (R3 \oplus s_5)$" src="form_197.png"/></p>
<p>Set</p>
<p><img class="formulaInl" alt="$ R3 = S_2(R2)$" src="form_198.png"/></p>
<p><img class="formulaInl" alt="$ R2 = S_1(R1)$" src="form_199.png"/></p>
<p><img class="formulaInl" alt="$ R1 = r$" src="form_200.png"/></p>
<h2><a class="anchor" id="OPSnow3G"></a>
Operation of SNOW 3G</h2>
<p><b>Initialisation</b></p>
<p>SNOW 3G is initialized with a 128-bit key consisting of four 32-bit words <b> <img class="formulaInl" alt="$ k_0, k_1, k_2, k_3$" src="form_201.png"/></b> and an 128-bit initialisation variable consisting of four 32-bit words <b> <img class="formulaInl" alt="$ IV_0, IV_1, IV_2, IV_3$" src="form_202.png"/></b> as follows</p>
<p>Let <b>1</b> be the all-ones word (0xffffffff)</p>
<p><img class="formulaInl" alt="$ s_{15}=k_3 \oplus IV_0$" src="form_203.png"/></p>
<p><img class="formulaInl" alt="$ s_{14}=k_2$" src="form_204.png"/></p>
<p><img class="formulaInl" alt="$ s_{13}=k_1$" src="form_205.png"/></p>
<p><img class="formulaInl" alt="$ s_{12}=k_0 \oplus IV_1$" src="form_206.png"/></p>
<p><img class="formulaInl" alt="$ s_{11}=k_3 \oplus 1$" src="form_207.png"/></p>
<p><img class="formulaInl" alt="$ s_{10}=k_2 \oplus 1 \oplus IV_2 s_9 = k_1 \oplus 1 \oplus IV_3 s_8 = k_0 \oplus 1$" src="form_208.png"/></p>
<p><img class="formulaInl" alt="$ s_7=k_3$" src="form_209.png"/></p>
<p><img class="formulaInl" alt="$ s_6=k_2$" src="form_210.png"/></p>
<p><img class="formulaInl" alt="$ s_5=k_1$" src="form_211.png"/></p>
<p><img class="formulaInl" alt="$ s_4=k_0$" src="form_212.png"/></p>
<p><img class="formulaInl" alt="$ s_3=k_3 \oplus 1$" src="form_213.png"/></p>
<p><img class="formulaInl" alt="$ s_2=k_2 \oplus 1$" src="form_214.png"/></p>
<p><img class="formulaInl" alt="$ s_1=k_1 \oplus 1$" src="form_215.png"/></p>
<p><img class="formulaInl" alt="$ s_0=k_0 \oplus 1$" src="form_216.png"/></p>
<p>The FSM is initialised with <img class="formulaInl" alt="$ R1 = R2 = R3 = 0$" src="form_217.png"/></p>
<p>Then the cipher runs in a special mode without producing output:</p>
<p>repeat 32-times {</p>
<p>STEP 1: The FSM is clocked (see 3.4.6) producing the 32-bit word F</p>
<p>STEP 2: Then the LFSR is clocked in Initialisation Mode (see 3.4.4) consuming F</p>
<p>}</p>
<div class="image">
<img src="Snow3GDuringInit.png" alt="Snow3GDuringInit.png"/>
<div class="caption">
Snow 3G Algorithm During Initialization</div></div>
<p><b>Generation of Keystream</b></p>
<p>First the FSM is clocked once, see 3.4.6. The output word of the FSM is discarded. Then the LFSR is clocked once in Keystream Mode, see 3.4.4</p>
<p>After that n 32-bit words of keystream are produced:</p>
<p>for t = 1 to n {</p>
<p>STEP 1: The FSM is clocked (see 3.4.6) and produces a 32-bit output word F</p>
<p>STEP 2: The next keystream word is computed as <img class="formulaInl" alt="$ z_t = F \oplus s_0$" src="form_218.png"/></p>
<p>STEP 3: Then the LFSR is clocked in Keystream Mode, see 3.4.4</p>
<p>}</p>
<div class="image">
<img src="Snow3GDuringKeyStream.png" alt="Snow3GDuringKeyStream.png"/>
<div class="caption">
Snow 3G Algorithm During Key-Stream Generation</div></div>
<p><b>The Rijndael S-box <img class="formulaInl" alt="$ S_R$" src="form_159.png"/></b></p>
<p>The S-box SR maps 8 bit to 8 bit. Here the input and output is presented in hexadecimal form</p>
<p>Let <img class="formulaInl" alt="$ x_0, x_1, y_0, y_1$" src="form_219.png"/> be hexadecimal digits with <img class="formulaInl" alt="$ S_R(x_0 {2}^{4}+x_1) = y_0 {2}^{4} + y_1$" src="form_220.png"/>, then the cell at the intersection of the <img class="formulaInl" alt="$ {x_0}^{th}$" src="form_221.png"/> row and the <img class="formulaInl" alt="$ {x_1}^{th}$" src="form_222.png"/> column contains the values for <img class="formulaInl" alt="$ y_0 || y_1$" src="form_223.png"/> in hexadecimal form</p>
<p>For example <img class="formulaInl" alt="$ S_R(42) = S_R(0x2A) = 0xE5 = 229$" src="form_224.png"/></p>
<div class="image">
<img src="SnowSBOXSr.png" alt="SnowSBOXSr.png"/>
<div class="caption">
Rijndael S-Box</div></div>
<p><b>The S-box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/></b></p>
<p>The S-box <img class="formulaInl" alt="$ S_Q$" src="form_170.png"/> maps 8 bit to 8 bit. Here the input is presented in hexadecimal form</p>
<p>Let <img class="formulaInl" alt="$ x_0, x_1, y_0, y_1$" src="form_219.png"/> be hexadecimal digits with <img class="formulaInl" alt="$ S_Q(x_0 {2}^{4}+x_1) = y_0 {2}^{4} + y_1$" src="form_225.png"/>, then the cell at the intersection of the <img class="formulaInl" alt="$ {x_0}^{th}$" src="form_221.png"/> row and the <img class="formulaInl" alt="$ {x_1}^{th}$" src="form_222.png"/> column contains the values for <img class="formulaInl" alt="$ y_0 || y_1$" src="form_223.png"/> in hexadecimal form</p>
<p>For example <img class="formulaInl" alt="$ S_Q(42) = S_Q(0x2A) = 0xAC = 172$" src="form_226.png"/></p>
<div class="image">
<img src="SnowSBOXSq.png" alt="SnowSBOXSq.png"/>
<div class="caption">
S-Box SQ</div></div>
<p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jconfident.html">ProtocolPP::jconfident</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jconfidentsa.html">ProtocolPP::jconfidentsa</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jmodes.html">ProtocolPP::jmodes</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jsnow3g.html">ProtocolPP::jsnow3g</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jsnowv.html">ProtocolPP::jsnowv</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jzuc.html">ProtocolPP::jzuc</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjconfident.html">jconfident</a> </dd>
<dd>
<a class="el" href="classjconfidentsa.html">jconfidentsa</a> </dd>
<dd>
<a class="el" href="classjmodes.html">jmodes</a> </dd>
<dd>
<a class="el" href="classjsnow3g.html">jsnow3g</a> </dd>
<dd>
<a class="el" href="classjsnowv.html">jsnowv</a> </dd>
<dd>
<a class="el" href="classjzuc.html">jzuc</a></dd></dl>
<p>[1] By Serpent-linearfunction.png: User:Dakederivative work: Hydrox (talk) - Serpent-linearfunction.png, CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=7437555">https://commons.wikimedia.org/w/index.php?curid=7437555</a></p>
<center>Protocol++&reg; (Protocolpp&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2022 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="jconfident_8h_source.html">jconfident.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 26 2022 17:49:47 for Protocol++ (ProtocolPP) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
