<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++ (ProtocolPP): jipsecsa Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++ (ProtocolPP)
   &#160;<span id="projectnumber">5.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">jipsecsa Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="jipsecsa_8h_source.html">include/jipsecsa.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for jipsecsa:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classjipsecsa__coll__graph.png" border="0" usemap="#jipsecsa_coll__map" alt="Collaboration graph"/></div>
<map name="jipsecsa_coll__map" id="jipsecsa_coll__map">
</map>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="ESPSASA"></a>
Encapsulating Security Payload (ESP) Security Association</h1>
<p>(See RFC4303 for complete details)</p>
<p>The (outer) protocol header (IPv4, IPv6, or Extension) that immediately precedes the ESP header SHALL contain the value 50 in its Protocol (IPv4) or Next Header (IPv6, Extension) field (see IANA web page at <a href="http://www.iana.org/assignments/protocol-numbers">http://www.iana.org/assignments/protocol-numbers</a>). Figure 1 illustrates the top-level format of an ESP packet. The packet begins with two 4-byte fields (Security Parameters Index (SPI) and Sequence Number). Following these fields is the Payload Data, which has substructure that depends on the choice of encryption algorithm and mode, and on the use of TFC padding, which is examined in more detail later. Following the Payload Data are Padding and Pad Length fields, and the Next Header field. The optional Integrity Check Value (ICV) field completes the packet.</p>
<div class="fragment"><div class="line"> 0               1               2               3</div><div class="line"> 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----</div><div class="line">|               Security Parameters Index (<a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a30d4418841c837a19e971f95530b9aba">SPI</a>)                 | ^Int.</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-</div><div class="line">|                      Sequence Number                          | |ered</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ----</div><div class="line">|                    Payload Data* (variable)                   | |   ^</div><div class="line">~                                                               ~ |   |</div><div class="line">|                                                               | |Conf.</div><div class="line">+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-</div><div class="line">|               |     Padding (0-255 bytes)                     | |ered*</div><div class="line">+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |</div><div class="line">|                               |  Pad Length   | Next Header   | v   v</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------</div><div class="line">|         Integrity Check Value-ICV   (variable)                |</div><div class="line">~                                                               ~</div><div class="line">|                                                               |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"></div><div class="line">            Figure 1.  Top-Level Format of an <a class="code" href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a3c81180cb6021e43241aa5aa223587f1">ESP</a> Packet</div><div class="line"></div><div class="line">    * If included in the Payload field, cryptographic synchronization</div><div class="line">      data, e.g., an Initialization Vector (<a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>, see Section 2.3),</div><div class="line">      usually is not encrypted per se, although it often is referred</div><div class="line">      to as being part of the ciphertext.</div></div><!-- fragment --><p>The (transmitted) ESP trailer consists of the Padding, Pad Length, and Next Header fields. Additional, implicit ESP trailer data (which is not transmitted) is included in the integrity computation, as described below.</p>
<p>If the integrity service is selected, the integrity computation encompasses the SPI, Sequence Number, Payload Data, and the ESP trailer (explicit and implicit).</p>
<p>If the confidentiality service is selected, the ciphertext consists of the Payload Data (except for any cryptographic synchronization data that may be included) and the (explicit) ESP trailer.</p>
<p>As noted above, the Payload Data may have substructure. An encryption algorithm that requires an explicit Initialization Vector (IV), e.g., Cipher Block Chaining (CBC) mode, often prefixes the Payload Data to be protected with that value. Some algorithm modes combine encryption and integrity into a single operation; this document refers to such algorithm modes as "combined mode
   algorithms". Accommodation of combined mode algorithms requires that the algorithm explicitly describe the payload substructure used to convey the integrity data.</p>
<p>Some combined mode algorithms provide integrity only for data that is encrypted, whereas others can provide integrity for some additional data that is not encrypted for transmission. Because the SPI and Sequence Number fields require integrity as part of the integrity service, and they are not encrypted, it is necessary to ensure that they are afforded integrity whenever the service is selected, regardless of the style of combined algorithm mode employed.</p>
<p>When any combined mode algorithm is employed, the algorithm itself is expected to return both decrypted plaintext and a pass/fail indication for the integrity check. For combined mode algorithms, the ICV that would normally appear at the end of the ESP packet (when integrity is selected) may be omitted. When the ICV is omitted and integrity is selected, it is the responsibility of the combined mode algorithm to encode within the Payload Data an ICV-equivalent means of verifying the integrity of the packet.</p>
<p>If a combined mode algorithm offers integrity only to data that is encrypted, it will be necessary to replicate the SPI and Sequence Number as part of the Payload Data.</p>
<p>Finally, a new provision is made to insert padding for traffic flow confidentiality after the Payload Data and before the ESP trailer. Figure 2 illustrates this substructure for Payload Data. (Note: This diagram shows bits-on-the-wire. So even if extended sequence numbers are being used, only 32 bits of the Sequence Number will be transmitted (see Section 2.2.1).)</p>
<div class="fragment"><div class="line"> 0               1               2               3</div><div class="line"> 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|               Security Parameters Index (<a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a30d4418841c837a19e971f95530b9aba">SPI</a>)                 |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|                      Sequence Number                          |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---</div><div class="line">|                    <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a> (optional)                              | ^ p</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a</div><div class="line">|                    Rest of Payload Data  (variable)           | | y</div><div class="line">~                                                               ~ | l</div><div class="line">|                                                               | | o</div><div class="line">+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a</div><div class="line">|               |         TFC Padding * (optional, variable)    | v d</div><div class="line">+-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---</div><div class="line">|                         |        Padding (0-255 bytes)        |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|                               |  Pad Length   | Next Header   |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|         Integrity Check Value-ICV   (variable)                |</div><div class="line">~                                                               ~</div><div class="line">|                                                               |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"></div><div class="line">            Figure 2. Substructure of Payload Data</div><div class="line"></div><div class="line">      * If tunnel mode is being used, then the IPsec implementation</div><div class="line">        can add Traffic Flow Confidentiality (TFC) padding (see</div><div class="line">        Section 2.4)  after the Payload Data and before the Padding</div><div class="line">        (0-255 bytes) field.</div></div><!-- fragment --><p>If a combined algorithm mode is employed, the explicit ICV shown in Figures 1 and 2 may be omitted (see Section 3.3.2.2 below). Because algorithms and modes are fixed when an SA is established, the detailed format of ESP packets for a given SA (including the Payload Data substructure) is fixed, for all traffic on the SA.</p>
<p>The tables below refer to the fields in the preceding figures and illustrate how several categories of algorithmic options, each with a different processing model, affect the fields noted above. The processing details are described in later sections.</p>
<div class="fragment"><div class="line">       Table 1. Separate Encryption and Integrity Algorithms</div><div class="line"></div><div class="line">                                         What    What    What</div><div class="line"><span class="preprocessor">                       # of     Requ&#39;d  Encrypt Integ    is</span></div><div class="line">                       bytes      [1]   Covers  Covers  Xmtd</div><div class="line">                       ------   ------  ------  ------  ------</div><div class="line"><a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a30d4418841c837a19e971f95530b9aba">SPI</a>                       4        M              Y     plain</div><div class="line">Seq# (low-order bits)     4        M              Y     plain       p</div><div class="line">                                                             ------ a</div><div class="line"><a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>                     variable    O              Y     plain     | y</div><div class="line"><a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5caec00ad7afee63cf726ab1f8b00ff16a5">IP</a> datagram [2]        variable  M or D    Y      Y     cipher[3] |-l</div><div class="line">TFC padding [4]        variable    O       Y      Y     cipher[3] | o</div><div class="line">                                                             ------ a</div><div class="line">Padding                 0-255      M       Y      Y     cipher[3]   d</div><div class="line">Pad Length                1        M       Y      Y     cipher[3]</div><div class="line">Next Header               1        M       Y      Y     cipher[3]</div><div class="line">Seq# (high-order bits)    4     <span class="keywordflow">if</span> ESN [5]        Y     not xmtd</div><div class="line">ICV Padding            variable <span class="keywordflow">if</span> need           Y     not xmtd</div><div class="line">ICV                    variable   M [6]                 plain</div><div class="line"></div><div class="line">        [1] M = mandatory; O = optional; D = dummy</div><div class="line">        [2] If tunnel mode -&gt; <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5caec00ad7afee63cf726ab1f8b00ff16a5">IP</a> datagram</div><div class="line">            If transport mode -&gt; next header and data</div><div class="line">        [3] ciphertext <span class="keywordflow">if</span> encryption has been selected</div><div class="line">        [4] Can be used only <span class="keywordflow">if</span> payload specifies its <span class="stringliteral">&quot;real&quot;</span> length</div><div class="line">        [5] See section 2.2.1</div><div class="line">        [6] mandatory <span class="keywordflow">if</span> a separate integrity algorithm is used</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">               Table 2. Combined Mode Algorithms</div><div class="line"></div><div class="line">                                          What    What    What</div><div class="line"><span class="preprocessor">                         # of     Requ&#39;d  Encrypt Integ    is</span></div><div class="line">                         bytes      [1]   Covers  Covers  Xmtd</div><div class="line">                         ------   ------  ------  ------  ------</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a30d4418841c837a19e971f95530b9aba">SPI</a>                        4        M                    plain</div><div class="line"> Seq# (low-order bits)      4        M                    plain    p</div><div class="line">                                                               --- a</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>                      variable    O              Y     plain  | y</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5caec00ad7afee63cf726ab1f8b00ff16a5">IP</a> datagram [2]         variable  M or D    Y      Y     cipher |-l</div><div class="line"> TFC padding [3]         variable    O       Y      Y     cipher | o</div><div class="line">                                                               --- a</div><div class="line"> Padding                  0-255      M       Y      Y     cipher   d</div><div class="line"> Pad Length                 1        M       Y      Y     cipher</div><div class="line"> Next Header                1        M       Y      Y     cipher</div><div class="line"> Seq# (high-order bits)     4     <span class="keywordflow">if</span> ESN [4]        Y     [5]</div><div class="line"> ICV Padding             variable <span class="keywordflow">if</span> need           Y     [5]</div><div class="line"> ICV                     variable    O [6]                plain</div><div class="line"></div><div class="line">         [1] M = mandatory; O = optional; D = dummy</div><div class="line">         [2] If tunnel mode -&gt; <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5caec00ad7afee63cf726ab1f8b00ff16a5">IP</a> datagram</div><div class="line">             If transport mode -&gt; next header and data</div><div class="line">         [3] Can be used only <span class="keywordflow">if</span> payload specifies its <span class="stringliteral">&quot;real&quot;</span> length</div><div class="line">         [4] See Section 2.2.1</div><div class="line">         [5] The algorithm choices determines whether these are</div><div class="line">             transmitted, but in either <span class="keywordflow">case</span>, the result is invisible</div><div class="line">             to <a class="code" href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a3c81180cb6021e43241aa5aa223587f1">ESP</a></div><div class="line">         [6] The algorithm spec determines whether <span class="keyword">this</span> field is</div><div class="line">             present</div></div><!-- fragment --><p>The following subsections describe the fields in the header format. "Optional" means that the field is omitted if the option is not selected, i.e., it is present in neither the packet as transmitted nor as formatted for computation of an ICV (see Section 2.7). Whether or not an option is selected is determined as part of Security Association (SA) establishment. Thus, the format of ESP packets for a given SA is fixed, for the duration of the SA. In contrast, "mandatory" fields are always present in the ESP packet format, for all SAs.</p>
<p>Note: All of the cryptographic algorithms used in IPsec expect their input in canonical network byte order (see Appendix of RFC 791 [Pos81]) and generate their output in canonical network byte order. IP packets are also transmitted in network byte order.</p>
<p>ESP does not contain a version number, therefore if there are concerns about backward compatibility, they MUST be addressed by using a signaling mechanism between the two IPsec peers to ensure compatible versions of ESP (e.g., Internet Key Exchange (IKEv2) [Kau05]) or an out-of-band configuration mechanism.</p>
<p><b>Security Parameters Index (SPI)</b></p>
<p>The SPI is an arbitrary 32-bit value that is used by a receiver to identify the SA to which an incoming packet is bound. The SPI field is mandatory.</p>
<p>For a unicast SA, the SPI can be used by itself to specify an SA, or it may be used in conjunction with the IPsec protocol type (in this case ESP). Because the SPI value is generated by the receiver for a unicast SA, whether the value is sufficient to identify an SA by itself or whether it must be used in conjunction with the IPsec protocol value is a local matter. This mechanism for mapping inbound traffic to unicast SAs MUST be supported by all ESP implementations.</p>
<p>If an IPsec implementation supports multicast, then it MUST support multicast SAs using the algorithm below for mapping inbound IPsec datagrams to SAs. Implementations that support only unicast traffic need not implement this de-multiplexing algorithm.</p>
<p>In many secure multicast architectures (e.g., [RFC3740]), a central Group Controller/Key Server unilaterally assigns the group security association's SPI. This SPI assignment is not negotiated or coordinated with the key management (e.g., IKE) subsystems that reside in the individual end systems that comprise the group. Consequently, it is possible that a group security association and a unicast security association can simultaneously use the same SPI. A multicast-capable IPsec implementation MUST correctly de-multiplex inbound traffic even in the context of SPI collisions.</p>
<p>Each entry in the Security Association Database (SAD) [Ken-Arch] must indicate whether the SA lookup makes use of the destination, or destination and source, IP addresses, in addition to the SPI. For multicast SAs, the protocol field is not employed for SA lookups. For each inbound, IPsec-protected packet, an implementation must conduct its search of the SAD such that it finds the entry that matches the "longest" SA identifier. In this context, if two or more SAD entries match based on the SPI value, then the entry that also matches based on destination, or destination and source, address comparison (as indicated in the SAD entry) is the "longest" match. This implies a logical ordering of the SAD search as follows:</p>
<ol type="1">
<li>Search the SAD for a match on {SPI, destination address, source address}. If an SAD entry matches, then process the inbound ESP packet with that matching SAD entry. Otherwise, proceed to step 2.</li>
<li>Search the SAD for a match on {SPI, destination address}. If the SAD entry matches, then process the inbound ESP packet with that matching SAD entry. Otherwise, proceed to step 3.</li>
<li>Search the SAD for a match on only {SPI} if the receiver has chosen to maintain a single SPI space for AH and ESP, or on {SPI, protocol} otherwise. If an SAD entry matches, then process the inbound ESP packet with that matching SAD entry. Otherwise, discard the packet and log an auditable event.</li>
</ol>
<p>In practice, an implementation MAY choose any method to accelerate this search, although its externally visible behavior MUST be functionally equivalent to having searched the SAD in the above order. For example, a software-based implementation could index into a hash table by the SPI. The SAD entries in each hash table bucket's linked list are kept sorted to have those SAD entries with the longest SA identifiers first in that linked list. Those SAD entries having the shortest SA identifiers are sorted so that they are the last entries in the linked list. A hardware-based implementation may be able to effect the longest match search intrinsically, using commonly available Ternary Content-Addressable Memory (TCAM) features.</p>
<p>The indication of whether source and destination address matching is required to map inbound IPsec traffic to SAs MUST be set either as a side effect of manual SA configuration or via negotiation using an SA management protocol, e.g., IKE or Group Domain of Interpretation (GDOI) [RFC3547]. Typically, Source-Specific Multicast (SSM) [HC03] groups use a 3-tuple SA identifier composed of an SPI, a destination multicast address, and source address. An Any-Source Multicast group SA requires only an SPI and a destination multicast address as an identifier.</p>
<p>The set of SPI values in the range 1 through 255 are reserved by the Internet Assigned Numbers Authority (IANA) for future use; a reserved SPI value will not normally be assigned by IANA unless the use of the assigned SPI value is specified in an RFC. The SPI value of zero (0) is reserved for local, implementation-specific use and MUST NOT be sent on the wire. (For example, a key management implementation might use the zero SPI value to mean "No Security Association Exists" during the period when the IPsec implementation has requested that its key management entity establish a new SA, but the SA has not yet been established.)</p>
<p><b>Sequence Number</b></p>
<p>This unsigned 32-bit field contains a counter value that increases by one for each packet sent, i.e., a per-SA packet sequence number. For a unicast SA or a single-sender multicast SA, the sender MUST increment this field for every transmitted packet. Sharing an SA among multiple senders is permitted, though generally not recommended. ESP provides no means of synchronizing packet counters among multiple senders or meaningfully managing a receiver packet counter and window in the context of multiple senders. Thus, for a multi-sender SA, the anti-replay features of ESP are not available (see Sections 3.3.3 and 3.4.3.)</p>
<p>The field is mandatory and MUST always be present even if the receiver does not elect to enable the anti-replay service for a specific SA. Processing of the Sequence Number field is at the discretion of the receiver, but all ESP implementations MUST be capable of performing the processing described in Sections 3.3.3 and 3.4.3. Thus, the sender MUST always transmit this field, but the receiver need not act upon it (see the discussion of Sequence Number Verification in the "Inbound Packet Processing" section (3.4.3) below).</p>
<p>The sender's counter and the receiver's counter are initialized to 0 when an SA is established. (The first packet sent using a given SA will have a sequence number of 1; see Section 3.3.3 for more details on how the sequence number is generated.) If anti-replay is enabled (the default), the transmitted sequence number must never be allowed to cycle. Thus, the sender's counter and the receiver's counter MUST be reset (by establishing a new SA and thus a new key) prior to the transmission of the 2^32nd packet on an SA.</p>
<p><b>Extended (64-bit) Sequence Number</b></p>
<p>To support high-speed IPsec implementations, Extended Sequence Numbers (ESNs) SHOULD be implemented, as an extension to the current, 32-bit sequence number field. Use of an ESN MUST be negotiated by an SA management protocol. Note that in IKEv2, this negotiation is implicit; the default is ESN unless 32-bit sequence numbers are explicitly negotiated. (The ESN feature is applicable to multicast as well as unicast SAs.)</p>
<p>The ESN facility allows use of a 64-bit sequence number for an SA. (See Appendix A, "Extended (64-bit) Sequence Numbers", for details.) Only the low-order 32 bits of the sequence number are transmitted in the plaintext ESP header of each packet, thus minimizing packet overhead. The high-order 32 bits are maintained as part of the sequence number counter by both transmitter and receiver and are included in the computation of the ICV (if the integrity service is selected). If a separate integrity algorithm is employed, the high order bits are included in the implicit ESP trailer, but are not transmitted, analogous to integrity algorithm padding bits. If a combined mode algorithm is employed, the algorithm choice determines whether the high-order ESN bits are transmitted or are included implicitly in the computation. See Section 3.3.2.2 for processing details.</p>
<p><b>Payload Data</b></p>
<p>Payload Data is a variable-length field containing data (from the original IP packet) described by the Next Header field. The Payload Data field is mandatory and is an integral number of bytes in length. If the algorithm used to encrypt the payload requires cryptographic synchronization data, e.g., an Initialization Vector (IV), then this data is carried explicitly in the Payload field, but it is not called out as a separate field in ESP, i.e., the transmission of an explicit IV is invisible to ESP. (See Figure 2.) Any encryption algorithm that requires such explicit, per-packet synchronization data MUST indicate the length, any structure for such data, and the location of this data as part of an RFC specifying how the algorithm is used with ESP. (Typically, the IV immediately precedes the ciphertext. See Figure 2.) If such synchronization data is implicit, the algorithm for deriving the data MUST be part of the algorithm definition RFC. (If included in the Payload field, cryptographic synchronization data, e.g., an Initialization Vector (IV), usually is not encrypted per se (see Tables 1 and 2), although it sometimes is referred to as being part of the ciphertext.)</p>
<p>Note that the beginning of the next layer protocol header MUST be aligned relative to the beginning of the ESP header as follows. For IPv4, this alignment is a multiple of 4 bytes. For IPv6, the alignment is a multiple of 8 bytes.</p>
<p>With regard to ensuring the alignment of the (real) ciphertext in the presence of an IV, note the following:</p>
<ul>
<li>For some IV-based modes of operation, the receiver treats the IV as the start of the ciphertext, feeding it into the algorithm directly. In these modes, alignment of the start of the (real) ciphertext is not an issue at the receiver.</li>
<li>In some cases, the receiver reads the IV in separately from the ciphertext. In these cases, the algorithm specification MUST address how alignment of the (real) ciphertext is to be achieved.</li>
</ul>
<p><b>Padding (for Encryption)</b></p>
<p>Two primary factors require or motivate use of the Padding field.</p>
<ul>
<li>If an encryption algorithm is employed that requires the plaintext to be a multiple of some number of bytes, e.g., the block size of a block cipher, the Padding field is used to fill the plaintext (consisting of the Payload Data, Padding, Pad Length, and Next Header fields) to the size required by the algorithm.</li>
<li>Padding also may be required, irrespective of encryption algorithm requirements, to ensure that the resulting ciphertext terminates on a 4-byte boundary. Specifically, the Pad Length and Next Header fields must be right aligned within a 4-byte word, as illustrated in the ESP packet format figures above, to ensure that the ICV field (if present) is aligned on a 4-byte boundary.</li>
</ul>
<p>Padding beyond that required for the algorithm or alignment reasons cited above could be used to conceal the actual length of the payload, in support of TFC. However, the Padding field described is too limited to be effective for TFC and thus should not be used for that purpose. Instead, the separate mechanism described below (see Section 2.7) should be used when TFC is required.</p>
<p>The sender MAY add 0 to 255 bytes of padding. Inclusion of the Padding field in an ESP packet is optional, subject to the requirements noted above, but all implementations MUST support generation and consumption of padding.</p>
<ul>
<li>For the purpose of ensuring that the bits to be encrypted are a multiple of the algorithm's block size (first bullet above), the padding computation applies to the Payload Data exclusive of any IV, but including the ESP trailer fields. If a combined algorithm mode requires transmission of the SPI and Sequence Number to effect integrity, e.g., replication of the SPI and Sequence Number in the Payload Data, then the replicated versions of these data items, and any associated, ICV-equivalent data, are included in the computation of the pad length. (If the ESN option is selected, the high-order 32 bits of the ESN also would enter into the computation, if the combined mode algorithm requires their transmission for integrity.)</li>
<li>For the purposes of ensuring that the ICV is aligned on a 4-byte boundary (second bullet above), the padding computation applies to the Payload Data inclusive of the IV, the Pad Length, and Next Header fields. If a combined mode algorithm is used, any replicated data and ICV-equivalent data are included in the Payload Data covered by the padding computation.</li>
</ul>
<p>If Padding bytes are needed but the encryption algorithm does not specify the padding contents, then the following default processing MUST be used. The Padding bytes are initialized with a series of (unsigned, 1-byte) integer values. The first padding byte appended to the plaintext is numbered 1, with subsequent padding bytes making up a monotonically increasing sequence: 1, 2, 3, .... When this padding scheme is employed, the receiver SHOULD inspect the Padding field. (This scheme was selected because of its relative simplicity, ease of implementation in hardware, and because it offers limited protection against certain forms of "cut and paste" attacks in the absence of other integrity measures, if the receiver checks the padding values upon decryption.)</p>
<p>If an encryption or combined mode algorithm imposes constraints on the values of the bytes used for padding, they MUST be specified by the RFC defining how the algorithm is employed with ESP. If the algorithm requires checking of the values of the bytes used for padding, this too MUST be specified in that RFC.</p>
<p><b>Pad Length</b></p>
<p>The Pad Length field indicates the number of pad bytes immediately preceding it in the Padding field. The range of valid values is 0 to 255, where a value of zero indicates that no Padding bytes are present. As noted above, this does not include any TFC padding bytes. The Pad Length field is mandatory.</p>
<p><b>Next Header</b></p>
<p>The Next Header is a mandatory, 8-bit field that identifies the type of data contained in the Payload Data field, e.g., an IPv4 or IPv6 packet, or a next layer header and data. The value of this field is chosen from the set of IP Protocol Numbers defined on the web page of the IANA, e.g., a value of 4 indicates IPv4, a value of 41 indicates IPv6, and a value of 6 indicates TCP.</p>
<p>To facilitate the rapid generation and discarding of the padding traffic in support of traffic flow confidentiality (see Section 2.4), the protocol value 59 (which means "no next header") MUST be used to designate a "dummy" packet. A transmitter MUST be capable of generating dummy packets marked with this value in the next protocol field, and a receiver MUST be prepared to discard such packets, without indicating an error. All other ESP header and trailer fields (SPI, Sequence Number, Padding, Pad Length, Next Header, and ICV) MUST be present in dummy packets, but the plaintext portion of the payload, other than this Next Header field, need not be well-formed, e.g., the rest of the Payload Data may consist of only random bytes. Dummy packets are discarded without prejudice.</p>
<p>Implementations SHOULD provide local management controls to enable the use of this capability on a per-SA basis. The controls should allow the user to specify if this feature is to be used and also provide parametric controls; for example, the controls might allow an administrator to generate random-length or fixed-length dummy packets.</p>
<p>DISCUSSION: Dummy packets can be inserted at random intervals to mask the absence of actual traffic. One can also "shape" the actual traffic to match some distribution to which dummy traffic is added as dictated by the distribution parameters. As with the packet length padding facility for Traffic Flow Security (TFS), the most secure approach would be to generate dummy packets at whatever rate is needed to maintain a constant rate on an SA. If packets are all the same size, then the SA presents the appearance of a constant bit rate data stream, analogous to what a link crypto would offer at layer 1 or 2. However, this is unlikely to be practical in many contexts, e.g., when there are multiple SAs active, because it would imply reducing the allowed bandwidth for a site, based on the number of SAs, and that would undermine the benefits of packet switching. Implementations SHOULD provide controls to enable local administrators to manage the generation of dummy packets for TFC purposes.</p>
<p><b>Traffic Flow Confidentiality (TFC) Padding</b></p>
<p>As noted above, the Padding field is limited to 255 bytes in length. This generally will not be adequate to hide traffic characteristics relative to traffic flow confidentiality requirements. An optional field, within the payload data, is provided specifically to address the TFC requirement.</p>
<p>An IPsec implementation SHOULD be capable of padding traffic by adding bytes after the end of the Payload Data, prior to the beginning of the Padding field. However, this padding (hereafter referred to as TFC padding) can be added only if the Payload Data field contains a specification of the length of the IP datagram. This is always true in tunnel mode, and may be true in transport mode depending on whether the next layer protocol (e.g., IP, UDP, ICMP) contains explicit length information. This length information will enable the receiver to discard the TFC padding, because the true length of the Payload Data will be known. (ESP trailer fields are located by counting back from the end of the ESP packet.) Accordingly, if TFC padding is added, the field containing the specification of the length of the IP datagram MUST NOT be modified to reflect this padding. No requirements for the value of this padding are established by this standard.</p>
<p>In principle, existing IPsec implementations could have made use of this capability previously, in a transparent fashion. However, because receivers may not have been prepared to deal with this padding, the SA management protocol MUST negotiate this service prior to a transmitter employing it, to ensure backward compatibility. Combined with the convention described in Section 2.6 above, about the use of protocol ID 59, an ESP implementation is capable of generating dummy and real packets that exhibit much greater length variability, in support of TFC.</p>
<p>Implementations SHOULD provide local management controls to enable the use of this capability on a per-SA basis. The controls should allow the user to specify if this feature is to be used and also provide parametric controls for the feature.</p>
<p><b>Integrity Check Value (ICV)</b></p>
<p>The Integrity Check Value is a variable-length field computed over the ESP header, Payload, and ESP trailer fields. Implicit ESP trailer fields (integrity padding and high-order ESN bits, if applicable) are included in the ICV computation. The ICV field is optional. It is present only if the integrity service is selected and is provided by either a separate integrity algorithm or a combined mode algorithm that uses an ICV. The length of the field is specified by the integrity algorithm selected and associated with the SA. The integrity algorithm specification MUST specify the length of the ICV and the comparison rules and processing steps for validation.</p>
<p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jsecass.html">ProtocolPP::jsecass</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jprotocol.html">ProtocolPP::jprotocol</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jipsec.html">ProtocolPP::jipsec</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jipsecsa.html">ProtocolPP::jipsecsa</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jicmp.html">ProtocolPP::jicmp</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jicmpsa.html">ProtocolPP::jicmpsa</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jmodes.html">ProtocolPP::jmodes</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjsecass.html">jsecass</a> </dd>
<dd>
<a class="el" href="classjprotocol.html">jprotocol</a> </dd>
<dd>
<a class="el" href="classjipsec.html">jipsec</a> </dd>
<dd>
<a class="el" href="classjipsecsa.html">jipsecsa</a> </dd>
<dd>
<a class="el" href="classjicmp.html">jicmp</a> </dd>
<dd>
<a class="el" href="classjicmpsa.html">jicmpsa</a> </dd>
<dd>
<a class="el" href="classjmodes.html">jmodes</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2022 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="jipsecsa_8h_source.html">jipsecsa.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 19 2022 22:31:29 for Protocol++ (ProtocolPP) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
