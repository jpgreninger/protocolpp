<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++(Protocolpp): jtls13 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Protocol++(Protocolpp)<span id="projectnumber">&#160;v5.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classjtls13.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jtls13 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;include/jtls13.h&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="TLS_Class_v13"></a>
Transport Layer Security v1.3 (TLS13)</h1>
<p >For additional information see <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">http://en.wikipedia.org/wiki/Transport_Layer_Security</a></p>
<p >The TLS protocol exchanges records—which encapsulate the data to be exchanged in a specific format (see below). Each record can be compressed, padded, appended with a message authentication code (MAC), or encrypted, all depending on the state of the connection. Each record has a content type field that designates the type of data encapsulated, a length field and a TLS version field. The data encapsulated may be control or procedural messages of the TLS itself, or simply the application data needed to be transferred by TLS. The specifications (cipher suite, keys etc.) required to exchange application data by TLS, are agreed upon in the "TLS handshake" between the client requesting the data and the server responding to requests. The protocol therefore defines both the structure of payloads transferred in TLS and the procedure to establish and monitor the transfer</p>
<p ><b>TLS handshake</b></p>
<p >When the connection starts, the record encapsulates a "control" protocol—the handshake messaging protocol (content type 22). This protocol is used to exchange all the information required by both sides for the exchange of the actual application data by TLS. It defines the messages formatting or containing this information and the order of their exchange. These may vary according to the demands of the client and server—i.e., there are several possible procedures to set up the connection. This initial exchange results in a successful TLS connection (both parties ready to transfer application data with TLS) or an alert message (as specified below)</p>
<h2><a class="anchor" id="TLS_HS_v13"></a>
Basic TLS handshake</h2>
<p >A typical connection example follows, illustrating a handshake where the server (but not the client) is authenticated by its certificate:</p>
<ol type="1">
<li>Negotiation phase: A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and suggested compression methods. If the client is attempting to perform a resumed handshake, it may send a session ID. The server responds with a ServerHello message, containing the chosen protocol version, a random number, CipherSuite and compression method from the choices offered by the client. To confirm or allow resumed handshakes the server may send a session ID. The chosen protocol version should be the highest that both the client and server support. For example, if the client supports TLS version 1.1 and the server supports version 1.2, version 1.1 should be selected; version 1.0 should not be selected. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server).[257] The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon ciphersuites.[1] The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the "master secret". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function.</li>
<li>The client now sends a ChangeCipherSpec record, essentially telling the server, "Everything I tell you from now on will be authenticated (and encrypted if encryption
    parameters were present in the server certificate)." The ChangeCipherSpec is itself a record-level protocol with content type of 20. Finally, the client sends an authenticated and encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down.</li>
<li>Finally, the server sends a ChangeCipherSpec, telling the client, "Everything I tell you
    from now on will be authenticated (and encrypted, if encryption was negotiated)." The server sends its authenticated and encrypted Finished message. The client performs the same decryption and verification.</li>
<li>Application phase: at this point, the "handshake" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be authenticated and optionally encrypted exactly like in their Finished message. Otherwise, the content type will return 25 and the client will not authenticate.</li>
</ol>
<p ><b>Client-authenticated TLS handshake</b></p>
<p >The following full example shows a client being authenticated (in addition to the server as in the example above) via TLS using certificates exchanged between both peers.</p>
<ol type="1">
<li>Negotiation Phase: A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. The server may also send a session id as part of the message to perform a resumed handshake. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server).[257] The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon ciphersuites.[1] The server requests a certificate from the client, so that the connection can be mutually authenticated, using a CertificateRequest message. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a Certificate message, which contains the client's certificate. The client sends a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client sends a CertificateVerify message, which is a signature over the previous handshake messages using the client's certificate's private key. This signature can be verified by using the client's certificate's public key. This lets the server know that the client has access to the private key of the certificate and thus owns the certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the "master secret". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function.</li>
<li>The client now sends a ChangeCipherSpec record, essentially telling the server, "Everything I tell
    you from now on will be authenticated (and encrypted if encryption was negotiated). " The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. Finally, the client sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down.</li>
<li>Finally, the server sends a ChangeCipherSpec, telling the client, "Everything I tell you from now
    on will be authenticated (and encrypted if encryption was negotiated). " The server sends its own encrypted Finished message. The client performs the same decryption and verification.</li>
<li>Application phase: at this point, the "handshake" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message.</li>
</ol>
<p ><b>Resumed TLS handshake</b></p>
<p >Public key operations (e.g., RSA) are relatively expensive in terms of computational power. TLS provides a secure shortcut in the handshake mechanism to avoid these operations: resumed sessions. Resumed sessions are implemented using session IDs or session tickets.</p>
<p >Apart from the performance benefit, resumed sessions can also be used for Single sign-on, as it guarantees that both the original session and any resumed session originate from the same client. This is of particular importance for the FTP over TLS/SSL protocol, which would otherwise suffer from a man-in-the-middle attack in which an attacker could intercept the contents of the secondary data connections.[258]</p>
<p ><b>Session IDs</b></p>
<p >In an ordinary full handshake, the server sends a session id as part of the ServerHello message. The client associates this session id with the server's IP address and TCP port, so that when the client connects again to that server, it can use the session id to shortcut the handshake. In the server, the session id maps to the cryptographic parameters previously negotiated, specifically the "master secret". Both sides must have the same "master secret" or the resumed handshake will fail (this prevents an eavesdropper from using a session id). The random data in the ClientHello and ServerHello messages virtually guarantee that the generated connection keys will be different from in the previous connection. In the RFCs, this type of handshake is called an abbreviated handshake. It is also described in the literature as a restart handshake.</p>
<ol type="1">
<li>Negotiation phase: A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. Included in the message is the session id from the previous TLS connection. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. If the server recognizes the session id sent by the client, it responds with the same session id. The client uses this to recognize that a resumed handshake is being performed. If the server does not recognize the session id sent by the client, it sends a different value for its session id. This tells the client that a resumed handshake will not be performed. At this point, both the client and server have the "master secret" and random data to generate the key data to be used for this connection.</li>
<li>The server now sends a ChangeCipherSpec record, essentially telling the client, "Everything I tell you
    from now on will be encrypted." The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. Finally, the server sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The client will attempt to decrypt the server's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down.</li>
<li>Finally, the client sends a ChangeCipherSpec, telling the server, "Everything I tell you from now on will
    be encrypted. " The client sends its own encrypted Finished message. The server performs the same decryption and verification.</li>
<li>Application phase: at this point, the "handshake" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message.</li>
</ol>
<p ></p>
<p ><b>Content Type</b></p>
<p >This field identifies the Record Layer Protocol Type contained in this Record</p>
<a class="anchor" id="tlsctypesv13"></a>
<table class="doxtable">
<caption>TLS Content Types</caption>
<tr>
<th>Hex</th><th>Dec</th><th>Type </th></tr>
<tr>
<td>0x14</td><td>20</td><td>ChangeCipherSpec </td></tr>
<tr>
<td>0x15</td><td>21</td><td>Alert </td></tr>
<tr>
<td>0x16</td><td>22</td><td>Handshake </td></tr>
<tr>
<td>0x17</td><td>23</td><td>Application </td></tr>
<tr>
<td>0x18</td><td>24</td><td>Heartbeat </td></tr>
</table>
<p ><b>Version</b></p>
<p >This field identifies the major and minor version of TLS for the contained message. For a ClientHello message, this need not be the highest version supported by the client</p>
<a class="anchor" id="tlsversionsv13"></a>
<table class="doxtable">
<caption>TLS Versions</caption>
<tr>
<th>Major Version</th><th>Minor Version</th><th>Version Type </th></tr>
<tr>
<td>0x03</td><td>0x04</td><td>TLS1.3 </td></tr>
</table>
<p ><b>Length</b></p>
<p >The length of Protocol message(s), MAC and Padding, not to exceed <picture><source srcset="form_429_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${2}^{14}$" src="form_429.png"/></picture> bytes (16KB)</p>
<p ><b>Protocol Message(s)</b></p>
<p >One or more messages identified by the Protocol field. Note that this field may be encrypted depending on the state of the connection</p>
<p ><b>MAC and Padding</b></p>
<p >A message authentication code computed over the Protocol message, with additional key material included Note that this field may be encrypted, or not included entirely, depending on the state of the connection No MAC or Padding can be present at end of TLS records before all cipher algorithms and parameters have been negotiated and handshaked and then confirmed by sending a CipherStateChange record (see below) for signaling that these parameters will take effect in all further records sent by the same peer</p>
<p ><b>Handshake protocol</b></p>
<p >Most messages exchanged during the setup of the TLS session are based on this record, unless an error or warning occurs and needs to be signaled by an Alert protocol record (see below), or the encryption mode of the session is modified by another record (see ChangeCipherSpec protocol below)</p>
<a class="anchor" id="tlshandshakev13"></a>
<table class="doxtable">
<caption>TLS Handshake Protocol</caption>
<tr>
<th>+</th><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3 </th></tr>
<tr>
<td>Byte 0</td><td><center>0x16</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 1-4</td><td colspan="2"><center>Version</center></td><td colspan="2"><center>Length</center> </td></tr>
<tr>
<td>Byte 5..8</td><td>Message Type</td><td colspan="3"><center>Handshake Message Data Length</center> </td></tr>
<tr>
<td>Byte 9-(n-1)</td><td colspan="4"><center>Handshake Message Data</center> </td></tr>
<tr>
<td><center><b>. . .</b></center></td><td colspan="4"><center><b>. . .</b></center> </td></tr>
</table>
<p ><b>Message type</b></p>
<p >This field identifies the handshake message type</p>
<a class="anchor" id="tlsmsgtypev13"></a>
<table class="doxtable">
<caption>TLS Message Types</caption>
<tr>
<th>Code</th><th>Description </th></tr>
<tr>
<td>0</td><td>HelloRequest </td></tr>
<tr>
<td>1</td><td>ClientHello </td></tr>
<tr>
<td>2</td><td>ServerHello </td></tr>
<tr>
<td>4</td><td>NewSessionTicket </td></tr>
<tr>
<td>11</td><td>Certificate </td></tr>
<tr>
<td>12</td><td>ServerKeyExchange </td></tr>
<tr>
<td>13</td><td>CertificateRequest </td></tr>
<tr>
<td>14</td><td>ServerHelloDone </td></tr>
<tr>
<td>15</td><td>CertificateVerify </td></tr>
<tr>
<td>16</td><td>ClientExchange </td></tr>
<tr>
<td>20</td><td>Finished </td></tr>
</table>
<p ><b>Handshake message data length</b></p>
<p >This is a 3-byte field indicating the length of the handshake data, not including the header Note that multiple handshake messages may be combined within one record</p>
<p ><b>Alert protocol</b></p>
<p >This record should normally not be sent during normal handshaking or application exchanges. However, this message can be sent at any time during the handshake and up to the closure of the session. If this is used to signal a fatal error, the session will be closed immediately after sending this record, so this record is used to give a reason for this closure. If the alert level is flagged as a warning, the remote can decide to close the session if it decides that the session is not reliable enough for its needs (before doing so, the remote may also send its own signal)</p>
<a class="anchor" id="tlsalertv13"></a>
<table class="doxtable">
<caption>TLS Alert Protocol</caption>
<tr>
<th>+</th><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3 </th></tr>
<tr>
<td>Byte 0</td><td><center>0x15</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 1-4</td><td colspan="2"><center>Version</center></td><td colspan="2"><center>Length</center> </td></tr>
<tr>
<td>Byte 5..6</td><td><center>Level</center></td><td><center>Description</center></td><td colspan="2">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 7-(n-1)</td><td colspan="4"><center>MAC (optional)</center> </td></tr>
<tr>
<td>Byte p-(q-1)</td><td colspan="4"><center>Padding (block ciphers only)</center> </td></tr>
</table>
<p ><b>Level</b></p>
<p >This field identifies the level of alert. If the level is fatal, the sender should close the session immediately. Otherwise, the recipient may decide to terminate the session itself, by sending its own fatal alert and closing the session itself immediately after sending it. The use of Alert records is optional, however if it is missing before the session closure, the session may be resumed automatically (with its handshakes)</p>
<p >Normal closure of a session after termination of the transported application should preferably be alerted with at least the Close notify Alert type (with a simple warning level) to prevent such automatic resume of a new session. Signaling explicitly the normal closure of a secure session before effectively closing its transport layer is useful to prevent or detect attacks (like attempts to truncate the securely transported data, if it intrinsically does not have a predetermined length or duration that the recipient of the secured data may expect)</p>
<p ><b>ChangeCipherSpec protocol</b></p>
<a class="anchor" id="tlscipherchangev13"></a>
<table class="doxtable">
<caption>TLS ChangeCipherSpec Protocol</caption>
<tr>
<th>+</th><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3 </th></tr>
<tr>
<td>Byte 0</td><td><center>0x14</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 1-4</td><td colspan="2"><center>Version</center></td><td colspan="2"><center>Length</center> </td></tr>
<tr>
<td>Byte 5</td><td><center>CCS Prot Type</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
</table>
<a class="anchor" id="tlsciphersuitesv13"></a>
<table class="doxtable">
<caption>TLSv13 CipherSuites Protocol</caption>
<tr>
<th>Description</th><th>Value </th></tr>
<tr>
<td>TLS_AES_128_GCM_SHA256</td><td><center>0x1301</center> </td></tr>
<tr>
<td>TLS_AES_256_GCM_SHA384</td><td><center>0x1302</center> </td></tr>
<tr>
<td>TLS_CHACHA20_POLY1305_128_SHA256</td><td><center>0x1303</center> </td></tr>
<tr>
<td>TLS_AES_128_CCM_SHA256</td><td><center>0x1304</center> </td></tr>
<tr>
<td>TLS_AES_128_CCM_8_SHA256</td><td><center>0x1305</center> </td></tr>
</table>
<p ><b>CCS protocol type</b></p>
<p >Currently only 1</p>
<p ><b>Application protocol</b></p>
<a class="anchor" id="tlsappv13"></a>
<table class="doxtable">
<caption>TLS Application Protocol</caption>
<tr>
<th>+</th><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3 </th></tr>
<tr>
<td>Byte 0</td><td><center>0x17</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 1-4</td><td colspan="2"><center>Version</center></td><td colspan="2"><center>Length</center> </td></tr>
<tr>
<td>Byte 5-(m-1)</td><td colspan="4"><center>Application Data</center> </td></tr>
<tr>
<td>Byte m-(p-1)</td><td colspan="4"><center>MAC (optional)</center> </td></tr>
<tr>
<td>Byte p-(q-1)</td><td colspan="4"><center>Padding (block ciphers only)</center> </td></tr>
</table>
<a class="anchor" id="tlsdtlsv13"></a>
<table class="doxtable">
<caption>DTLS Datagram</caption>
<tr>
<th>+</th><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3 </th></tr>
<tr>
<td>Byte 0</td><td><center>0x17</center></td><td colspan="3">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </td></tr>
<tr>
<td>Byte 1-4</td><td colspan="2"><center>Version</center></td><td colspan="2"><center>Epoch</center> </td></tr>
<tr>
<td>Byte 5-8</td><td colspan="4"><center>Seqnum</center> </td></tr>
<tr>
<td>Byte 9-12</td><td colspan="2"><center>Seqnum</center></td><td colspan="2"><center>Length</center> </td></tr>
<tr>
<td>Byte 13-(m-1)</td><td colspan="4"><center>Application Data</center> </td></tr>
<tr>
<td>Byte m-(p-1)</td><td colspan="4"><center>MAC (optional)</center> </td></tr>
<tr>
<td>Byte p-(q-1)</td><td colspan="4"><center>Padding (block ciphers only)</center> </td></tr>
</table>
<p ><b>Length</b></p>
<p >Length of the application data (excluding the protocol header and including the MAC and padding trailers)</p>
<p ><b>MAC</b></p>
<p >20 bytes for the SHA1 based HMAC, 16 bytes for the MD5 based HMAC</p>
<p ><b>Padding</b></p>
<p >Variable length; last byte contains the padding length</p>
<p ><b>IANA Considerations</b></p>
<p >IANA has allocated the following numbers in the TLS Cipher Suite Registry:</p>
<p ><b>Applying Encrypt-then-MAC</b></p>
<p >Once the use of encrypt-then-MAC has been negotiated, processing of TLS/DTLS packets switches from the standard:</p>
<ul>
<li>encrypt( data || MAC || pad )</li>
</ul>
<p >to the new:</p>
<ul>
<li>encrypt( data || pad ) || MAC</li>
</ul>
<p ><b>Major Differences from TLS 1.2</b></p>
<p >The following is a list of the major functional differences between TLS 1.2 and TLS 1.3. It is not intended to be exhaustive, and there are many minor differences</p>
<ul>
<li>The list of supported symmetric encryption algorithms has been pruned of all algorithms that are considered legacy. Those that remain are all Authenticated Encryption with Associated Data (AEAD) algorithms. The cipher suite concept has been changed to separate the authentication and key exchange mechanisms from the record protection algorithm (including secret key length) and a hash to be used with both the key derivation function and handshake message authentication code (MAC)</li>
<li>A zero round-trip time (0-RTT) mode was added, saving a round trip at connection setup for some application data, at the cost of certain security properties</li>
<li>Static RSA and Diffie-Hellman cipher suites have been removed; all public-key based key exchange mechanisms now provide forward secrecy</li>
<li>All handshake messages after the ServerHello are now encrypted. The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection</li>
<li>The key derivation functions have been redesigned. The new design allows easier analysis by cryptographers due to their improved key separation properties. The HMAC-based Extract-and-Expand Key Derivation Function (HKDF) is used as an underlying primitive</li>
<li>The handshake state machine has been significantly restructured to be more consistent and to remove superfluous messages such as ChangeCipherSpec (except when needed for middlebox compatibility)</li>
<li>Elliptic curve algorithms are now in the base spec, and new signature algorithms, such as EdDSA, are included. TLS 1.3 removed point format negotiation in favor of a single point format for each curve</li>
<li>Other cryptographic improvements were made, including changing the RSA padding to use the RSA Probabilistic Signature Scheme (RSASSA-PSS), and the removal of compression, the Digital Signature Algorithm (DSA), and custom Ephemeral Diffie-Hellman (DHE) groups</li>
<li>The TLS 1.2 version negotiation mechanism has been deprecated in favor of a version list in an extension. This increases compatibility with existing servers that incorrectly implemented version negotiation</li>
<li>Session resumption with and without server-side state as well as the PSK-based cipher suites of earlier TLS versions have been replaced by a single new PSK exchange</li>
<li>References have been updated to point to the updated versions of RFCs, as appropriate (e.g., RFC 5280 rather than RFC 3280)</li>
</ul>
<p ><b>Updates Affecting TLS 1.2</b></p>
<p >This document defines several changes that optionally affect implementations of TLS 1.2, including those which do not also support TLS 1.3</p>
<ul>
<li>A version downgrade protection mechanism is described inSection 4.1.3</li>
<li>RSASSA-PSS signature schemes are defined in Section 4.2.3</li>
<li>The "supported_versions" ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello</li>
<li>The "signature_algorithms_cert" extension allows a client to indicate which signature algorithms it can validate in X.509 certificates</li>
</ul>
<p >Additionally, this document clarifies some compliance requirements for earlier versions of TLS; see Section 9.3</p>
<p ><b>Per-Record Nonce</b></p>
<p >A 64-bit sequence number is maintained separately for reading and writing records. Each sequence number is set to zero at the beginning of a connection and whenever the key is changed. The sequence number is incremented by one after reading or writing each record. The first record transmitted under a particular set of traffic keys MUST use sequence number 0</p>
<p >Because the size of sequence numbers is 64-bit, they should not wrap. If a TLS implementation would need to wrap a sequence number, it MUST either re-key (Section 4.6.3) or terminate the connection</p>
<p >Each AEAD algorithm will specify a range of possible lengths for the per-record nonce, from N_MIN bytes to N_MAX bytes of input ([RFC5116]). The length of the TLS per-record nonce (iv_length) is set to the larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116] Section 4). An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS. The per-record nonce for the AEAD construction is formed as follows:</p>
<ol type="1">
<li>The 64-bit record sequence number is encoded in network byte order and padded to the left with zeros to iv_length</li>
<li>The padded sequence number is XORed with the static client_write_iv or server_write_iv, depending on the role. The resulting quantity (of length iv_length) is used as the per-record nonce</li>
</ol>
<p ><b>*** Note: This is a different construction from that in TLS 1.2, which specified a partially explicit nonce ***</b></p>
<p ><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jprotocol.html">ProtocolPP::jprotocol</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jtlsa13.html">ProtocolPP::jtlsa13</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jtls13.html">ProtocolPP::jtls13</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjprotocol.html">jprotocol</a> </dd>
<dd>
<a class="el" href="classjtlsa13.html">jtlsa13</a> </dd>
<dd>
<a class="el" href="classjtls13.html">jtls13</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2023 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p >The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p >No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p >Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p >Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p >The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jtls13.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classjtls13.html">jtls13</a></li>
    <li class="footer">Generated on Sat May 6 2023 22:07:12 for Protocol++(Protocolpp) by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
