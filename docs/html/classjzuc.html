<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++&reg; (Protocolpp&reg;): jzuc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Protocol++&reg; (Protocolpp&reg;)<span id="projectnumber">&#160;v5.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classjzuc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jzuc Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;include/jzuc.h&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="ZUCAlgZUC"></a>
ZUC Encrytpion Algorithm (128-EEA3)</h1>
<dl class="section see"><dt>See also</dt><dd>Specification of the 3GPP Confidentiality and Integrity Algorithms 128-EEA3 and 128-EIA3 Document 2: ZUC Specification</dd></dl>
<p><b>General structure of the algorithm</b></p>
<p >ZUC has three logical layers, see the figure below. The top layer is a linear feedback shift register (LFSR) of 16 stages, the middle layer is for bit-reorganization ( BR), and the bottom layer is a nonlinear function F</p>
<div class="image">
<img src="ZUCStructure.png" alt=""/>
<div class="caption">
General Structure of ZUC</div></div>
 <p ><b>The linear feedback shift register (LFSR)</b></p>
<p >The linear feedback shift register (LFSR) has 16 of 31-bit cells <picture><source srcset="form_79_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ (s_0, s_1,\cdots,s_{15})$" src="form_79.png"/></picture>. Each cell <picture><source srcset="form_80_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_i (0 \leq i \leq 15)$" src="form_80.png"/></picture> is restricted to take values from the following set <b> <picture><source srcset="form_81_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \{1,2,3,\cdots,{2}^{31} – 1\}$" src="form_81.png"/></picture></b>. The LFSR has 2 modes of operations: the initialization mode and the working mode</p>
<p >In the initialization mode, the LFSR receives a 31-bit input word u, which is obtained by removing the rightmost bit from the 32-bit output W of the nonlinear function F, i.e., u=W&gt;&gt;1. More specifically, the initialization mode works as follows: <br  />
</p>
<p >LFSRWithInitialisationMode(u) {</p>
<ol type="1">
<li><picture><source srcset="form_82_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v={2}^{15}s_{15}+{2}^{17}s_{13}+{2}_{21}s_{10}+{2}^{20}s_4+(1+{2}^{8})s_0$" src="form_82.png"/></picture> mod <picture><source srcset="form_83_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></picture></li>
<li><picture><source srcset="form_84_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_{16}=(v+u)$" src="form_84.png"/></picture> mod <picture><source srcset="form_83_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></picture></li>
<li><picture><source srcset="form_85_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ If s_{16}=0$" src="form_85.png"/></picture>, then set <picture><source srcset="form_86_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s_{16}={2}^{31}-1$" src="form_86.png"/></picture></li>
<li><picture><source srcset="form_87_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ (s_1,s_2,\cdots,s_{15},s_{16})\rightarrow(s_0,s_1,\cdots,s_{14},s_{15})$" src="form_87.png"/></picture> <br  />
</li>
</ol>
<p >} <br  />
</p>
<p >In the working mode, the LFSR does not receive any input, and it works as follows: <br  />
</p>
<p >LFSRWithWorkMode() {</p>
<ol type="1">
<li><picture><source srcset="form_88_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_{16}={2}^{15}s_15+{2}^{17}s_13+{2}^{21}s_10+{2}^{20}s_4+(1+{2}^{8})s_0$" src="form_88.png"/></picture> mod <picture><source srcset="form_83_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></picture></li>
<li><picture><source srcset="form_85_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ If s_{16}=0$" src="form_85.png"/></picture>, then set <picture><source srcset="form_89_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_{16}={2}^{31}-1$" src="form_89.png"/></picture></li>
<li><picture><source srcset="form_87_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ (s_1,s_2,\cdots,s_{15},s_{16})\rightarrow(s_0,s_1,\cdots,s_{14},s_{15})$" src="form_87.png"/></picture></li>
</ol>
<p >} <br  />
</p>
<p >Informative note: Since the multiplication of a 31-bit string s by <picture><source srcset="form_90_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {2}^{i}$" src="form_90.png"/></picture> over <picture><source srcset="form_91_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ GF({2}^{31}-1)$" src="form_91.png"/></picture> can be implemented by a cyclic shift of s to the left by i bits, only addition modulo <picture><source srcset="form_92_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {2}^{31}-1$" src="form_92.png"/></picture> is needed in step 1 of the above functions. More precisely, step 1 of the function LFSRWithInitialisationMode can be implemented by <br  />
</p>
<p ><picture><source srcset="form_93_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v=(s_{15} &lt;&lt;&lt;_{31} 15)+(s_{13} &lt;&lt;&lt;_{31} 17)+(s_{10} &lt;&lt;&lt;_{31} 21)+(s_4 &lt;&lt;&lt;_{31} 20)+(s_0 &lt;&lt;&lt;_{31} 8)+s_0$" src="form_93.png"/></picture> mod <picture><source srcset="form_83_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></picture></p>
<p >and the same implementation is needed for step 1 of the function LFSRWithWorkMode</p>
<p >Informative note: For two elements <picture><source srcset="form_94_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ a,b$" src="form_94.png"/></picture> over <picture><source srcset="form_91_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ GF({2}^{31}-1)$" src="form_91.png"/></picture>, the computation of <picture><source srcset="form_95_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v=a+b$" src="form_95.png"/></picture> mod <picture><source srcset="form_83_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ ({2}^{31}-1)$" src="form_83.png"/></picture> can be done by</p>
<p >(1) compute v=a+b and</p>
<p >(2) if the carry bit is 1, then set v=v+1</p>
<p >Alternatively (and better if the implementation should resist possible timing attacks):</p>
<p >(1) compute w=a+b, where w is a 32-bit value; and</p>
<p >(2) set v = (least significant 31 bits of w) + (most significant bit of w) <br  />
</p>
<p ><b>The bit-reorganization</b></p>
<p >The middle layer of the algorithm is the bit-reorganization. It extracts 128 bits from the cells of the LFSR and forms 4 of 32-bit words, where the first three words will be used by the nonlinear function F in the bottom layer, and the last word will be involved in producing the keystream</p>
<p >Let <picture><source srcset="form_96_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_0, s_2, s_5, s_7, s_9, s_{11}, s_{14}, s_{15}$" src="form_96.png"/></picture> be 8 cells of LFSR as in section 3.2. Then the bitreorganization forms 4 of 32-bit words <picture><source srcset="form_97_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1, X_2, X_3$" src="form_97.png"/></picture> from the above cells as follows: <br  />
</p>
<p >Bitreorganization() {</p>
<ol type="1">
<li><picture><source srcset="form_98_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0=s_{15H} \parallel s_{14L}$" src="form_98.png"/></picture></li>
<li><picture><source srcset="form_99_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_1=s_{11L} \parallel s_{9H}$" src="form_99.png"/></picture></li>
<li><picture><source srcset="form_100_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_2=s_{7L} \parallel s_{5H}$" src="form_100.png"/></picture></li>
<li><picture><source srcset="form_101_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_3=s_{2L} \parallel s_{0H}$" src="form_101.png"/></picture></li>
</ol>
<p >} <br  />
</p>
<p >Note: The <picture><source srcset="form_102_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_i$" src="form_102.png"/></picture> are 31-bit integers, so <picture><source srcset="form_103_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_{iH}$" src="form_103.png"/></picture> means bits 30...15 and not 31...16 of <picture><source srcset="form_104_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_i, for 0 \leq i \leq 15$" src="form_104.png"/></picture></p>
<p ><b>The nonlinear function F</b></p>
<p >The nonlinear function F has 2 of 32-bit memory cells <picture><source srcset="form_105_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ R_1$" src="form_105.png"/></picture> and <picture><source srcset="form_106_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ R_2$" src="form_106.png"/></picture>. Let the inputs to F be <picture><source srcset="form_107_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1$" src="form_107.png"/></picture> and <picture><source srcset="form_108_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_2$" src="form_108.png"/></picture>, which come from the outputs of the bit-reorganization (see section 3.3), then the function F outputs a 32-bit word W. The detailed process of F is as follows: <br  />
</p>
<p >F ( <picture><source srcset="form_109_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/></picture>) {</p>
<ol type="1">
<li><picture><source srcset="form_110_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ W=(X_0 \oplus R_1) \oplus R_2$" src="form_110.png"/></picture></li>
<li><picture><source srcset="form_111_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ W_1=R_1 \oplus X_1$" src="form_111.png"/></picture></li>
<li><picture><source srcset="form_112_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ W_2=R_2 \oplus X_2$" src="form_112.png"/></picture></li>
<li><picture><source srcset="form_113_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ R_1=S(L_1(W_{1L} \parallel W_{2H}))$" src="form_113.png"/></picture></li>
<li><picture><source srcset="form_114_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ R_2=S(L_2(W_{2L} \parallel W_{1H}))$" src="form_114.png"/></picture></li>
</ol>
<p >} <br  />
</p>
<p >where <em>S</em> is a 32×32 S-box, see section 3.4.1, <picture><source srcset="form_115_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L_1$" src="form_115.png"/></picture> and <picture><source srcset="form_116_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L_2$" src="form_116.png"/></picture> are linear transforms as defined in section 3.4.2</p>
<p ><b>The S-box S</b></p>
<p >The 32×32 S-box S is composed of 4 juxtaposed 8×8 S-boxes, i.e., S=( <picture><source srcset="form_117_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_0,S_1,S_2,S_3$" src="form_117.png"/></picture>), where <picture><source srcset="form_118_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_0=S_2$" src="form_118.png"/></picture>, <picture><source srcset="form_119_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_1=S_3$" src="form_119.png"/></picture>. The definitions of <picture><source srcset="form_120_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_0$" src="form_120.png"/></picture> and <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_1$" src="form_121.png"/></picture> can be found in table 3.1 and table 3.2 respectively</p>
<p >Let x be an 8-bit input to <picture><source srcset="form_120_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_0$" src="form_120.png"/></picture> (or <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_1$" src="form_121.png"/></picture>). Write x into two hexadecimal digits as <picture><source srcset="form_122_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x=h \parallel l$" src="form_122.png"/></picture>, then the entry at the intersection of the h-th row and the l-th column in table 3.1 (or table 3.2) is the output of <picture><source srcset="form_120_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_0$" src="form_120.png"/></picture> (or <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ S_1$" src="form_121.png"/></picture>)</p>
<div class="image">
<img src="SBOX_S0.png" alt=""/>
<div class="caption">
The S-Box S0</div></div>
 <div class="image">
<img src="SBOX_S1.png" alt=""/>
<div class="caption">
The S-Box S1</div></div>
 <p ><b>The linear transforms L1 and L2</b></p>
<p >Both L1 and L2 are linear transforms from 32-bit words to 32-bit words, and are defined as follows: <br  />
</p>
<p ><picture><source srcset="form_123_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L_1(X)=X \oplus (X &lt;&lt;&lt;_{32} 2) \oplus (X &lt;&lt;&lt;_{32} 10) \oplus (X &lt;&lt;&lt;_{32} 18) \oplus (X &lt;&lt;&lt;_{32} 24)$" src="form_123.png"/></picture></p>
<p ><picture><source srcset="form_124_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L_2(X)=X \oplus (X &lt;&lt;&lt;_{32} 8) \oplus (X &lt;&lt;&lt;_{32} 14) \oplus (X &lt;&lt;&lt;_{32} 22) \oplus (X &lt;&lt;&lt;_{32} 30)$" src="form_124.png"/></picture></p>
<p ><b>Key loading</b></p>
<p >The key loading procedure will expand the initial key and the initial vector into 16 of 31-bit integers as the initial state of the LFSR. Let the 128-bit initial key k and the 128-bit initial vector iv be <br  />
</p>
<p ><picture><source srcset="form_125_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ k=k_0 \parallel k_1 \parallel k_2 \parallel \cdots \parallel k_{15}$" src="form_125.png"/></picture></p>
<p >and <br  />
</p>
<p ><picture><source srcset="form_126_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ iv=iv_0 \parallel iv_1 \parallel iv_2 \parallel \cdots \parallel iv_{15}$" src="form_126.png"/></picture></p>
<p >respectively, where <picture><source srcset="form_127_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ k_i$" src="form_127.png"/></picture> and <picture><source srcset="form_128_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ iv_i, 0\leq i\leq 15$" src="form_128.png"/></picture>, are all bytes. Then k and iv are loaded to the cells <picture><source srcset="form_129_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ s_0, s_1,\cdots, s_{15}$" src="form_129.png"/></picture> of LFSR as follows: <br  />
</p>
<ol type="1">
<li>Let D be a 240-bit long constant string composed of 16 substrings of 15 bits: <br  />
</li>
</ol>
<p ><picture><source srcset="form_130_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ D=d_0 \parallel d_1 \parallel \cdots \parallel d_{15}$" src="form_130.png"/></picture></p>
<p >where <br  />
</p>
<p ><picture><source srcset="form_131_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d00 = 100010011010111_2 $" src="form_131.png"/></picture></p>
<p ><picture><source srcset="form_132_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d01 = 010011010111100_2 $" src="form_132.png"/></picture></p>
<p ><picture><source srcset="form_133_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d02 = 110001001101011_2 $" src="form_133.png"/></picture></p>
<p ><picture><source srcset="form_134_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d03 = 001001101011110_2 $" src="form_134.png"/></picture></p>
<p ><picture><source srcset="form_135_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d04 = 101011110001001_2 $" src="form_135.png"/></picture></p>
<p ><picture><source srcset="form_136_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d05 = 011010111100010_2 $" src="form_136.png"/></picture></p>
<p ><picture><source srcset="form_137_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d06 = 111000100110101_2 $" src="form_137.png"/></picture></p>
<p ><picture><source srcset="form_138_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d07 = 000100110101111_2 $" src="form_138.png"/></picture></p>
<p ><picture><source srcset="form_139_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d08 = 100110101111000_2 $" src="form_139.png"/></picture></p>
<p ><picture><source srcset="form_140_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d09 = 010111100010011_2 $" src="form_140.png"/></picture></p>
<p ><picture><source srcset="form_141_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d10 = 110101111000100_2 $" src="form_141.png"/></picture></p>
<p ><picture><source srcset="form_142_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d11 = 001101011110001_2 $" src="form_142.png"/></picture></p>
<p ><picture><source srcset="form_143_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d12 = 101111000100110_2 $" src="form_143.png"/></picture></p>
<p ><picture><source srcset="form_144_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d13 = 011110001001101_2 $" src="form_144.png"/></picture></p>
<p ><picture><source srcset="form_145_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d14 = 111100010011010_2 $" src="form_145.png"/></picture></p>
<p ><picture><source srcset="form_146_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d15 = 100011110101100_2 $" src="form_146.png"/></picture></p>
<ol type="1">
<li><picture><source srcset="form_147_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ For 0 \leq i \leq 15, let s_i=k_i \parallel d_i \parallel iv_i$" src="form_147.png"/></picture></li>
</ol>
<p ><b>The execution of ZUC</b></p>
<p >The execution of ZUC has two stages: the initialization stage and the working stage</p>
<p ><b>The initialization stage</b></p>
<p >During the initialization stage, the algorithm calls the key loading procedure (see section 3.5) to load the 128-bit initial key k and the 128-bit initial vector iv into the LFSR, and set the 32bit memory cells R1 and R2 to be all 0. Then the cipher runs the following operations 32 times:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>w=F( <picture><source srcset="form_109_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/></picture>);</li>
<li>LFSRWithInitialisationMode(w &gt;&gt; 1)</li>
</ol>
<p ><b>The working stage</b></p>
<p >After the initialization stage, the algorithm moves into the working stage. At the working stage, the algorithm executes the following operations once, and discards the output W of F:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>F( <picture><source srcset="form_109_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1, X_2$" src="form_109.png"/></picture>);</li>
<li>LFSRWithWorkMode()</li>
</ol>
<p >Then the algorithm goes into the stage of producing keystream, i.e., for each iteration, the following operations are executed once, and a 32-bit word Z is produced as an output:</p>
<ol type="1">
<li>Bitreorganization();</li>
<li>Z=F( <picture><source srcset="form_148_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ X_0, X_1, X_2) \oplus X3$" src="form_148.png"/></picture>;</li>
<li>LFSRWithWorkMode()</li>
</ol>
<p ><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jarray.html">ProtocolPP::jarray</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jzuc.html">ProtocolPP::jzuc</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jmodes.html">ProtocolPP::jmodes</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jconfident.html">ProtocolPP::jconfident</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jintegrity.html">ProtocolPP::jintegrity</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjarray.html">jarray</a> </dd>
<dd>
<a class="el" href="classjzuc.html">jzuc</a> </dd>
<dd>
<a class="el" href="classjmodes.html">jmodes</a> </dd>
<dd>
<a class="el" href="classjconfident.html">jconfident</a> </dd>
<dd>
<a class="el" href="classjintegrity.html">jintegrity</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) modified by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2023 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p >The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p >No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p >Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p >Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
<li><b>TXu002383571 (Version 5.4.3)</b></li>
</ul>
</li>
</ul>
<p >The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jzuc.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classjzuc.html">jzuc</a></li>
    <li class="footer">Generated on Mon Oct 23 2023 11:44:35 for Protocol++&reg; (Protocolpp&reg;) by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
