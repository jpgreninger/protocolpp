<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++(Protocolpp): jip Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++(Protocolpp)
   &#160;<span id="projectnumber">v5.4.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classjip.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">jip Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;include/jip.h&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="IP_Class"></a>
Internet Protocol (IP)</h1>
<p>See <a href="https://en.wikipedia.org/wiki/Internet_Protocol">https://en.wikipedia.org/wiki/Internet_Protocol</a></p>
<p>The Internet Protocol (IP) is the principal communications protocol in the Internet protocol suite for relaying datagrams across network boundaries. Its routing function enables internetworking, and essentially establishes the Internet.</p>
<p>IP has the task of delivering packets from the source host to the destination host solely based on the IP addresses in the packet headers. For this purpose, IP defines packet structures that encapsulate the data to be delivered. It also defines addressing methods that are used to label the datagram with source and destination information.</p>
<p>Historically, IP was the connectionless datagram service in the original Transmission Control Program introduced by Vint Cerf and Bob Kahn in 1974; the other being the connection-oriented Transmission Control Protocol (TCP). The Internet protocol suite is therefore often referred to as TCP/IP.</p>
<p>The first major version of IP, Internet Protocol Version 4 (IPv4), is the dominant protocol of the Internet. Its successor is Internet Protocol V6</p>
<p>The header for IPv4 is configured as follows (See RFC 791) [1]</p>
<div class="image">
<img src="IP_version4_hdr2.png" alt=""/>
<div class="caption">
IP Version 4 Header</div></div>
 <ul>
<li><p class="startli">Version: 4 bits</p>
<p class="startli">The Version field indicates the format of the internet header</p>
</li>
<li><p class="startli">IHL: 4 bits</p>
<p class="startli">Internet Header Length is the length of the internet header in 32 bit words, and thus points to the beginning of the data. Note that the minimum value for a correct header is 5.</p>
</li>
<li><p class="startli">Type of Service: 8 bits</p>
<p class="startli">The Type of Service provides an indication of the abstract parameters of the quality of service desired. These parameters are to be used to guide the selection of the actual service parameters when transmitting a datagram through a particular network. Several networks offer service precedence, which somehow treats high precedence traffic as more important than other traffic (generally by accepting only traffic above a certain precedence at time of high load). The major choice is a three way tradeoff between low-delay, high-reliability, and high-throughput.</p>
</li>
</ul>
<div class="image">
<img src="IPsecPrecedence50.png" alt=""/>
<div class="caption">
IP Version 4 ToS</div></div>
 <p>The use of the Delay, Throughput, and Reliability indications may increase the cost (in some sense) of the service. In many networks better performance for one of these parameters is coupled with worse performance on another. Except for very unusual cases at most two of these three indications should be set.</p>
<p>The type of service is used to specify the treatment of the datagram during its transmission through the internet system. Example mappings of the internet type of service to the actual service provided on networks such as AUTODIN II, ARPANET, SATNET, and PRNET is given in "Service Mappings"</p>
<p>The Network Control precedence designation is intended to be used within a network only. The actual use and control of that designation is up to each network. The Internetwork Control designation is intended for use by gateway control originators only. If the actual use of these precedence designations is of concern to a particular network, it is the responsibility of that network to control the access to, and use of, those precedence designations.</p>
<ul>
<li><p class="startli">Total Length: 16 bits</p>
<p class="startli">Total Length is the length of the datagram, measured in octets, including internet header and data. This field allows the length of a datagram to be up to 65,535 octets. Such long datagrams are impractical for most hosts and networks. All hosts must be prepared to accept datagrams of up to 576 octets (whether they arrive whole or in fragments). It is recommended that hosts only send datagrams larger than 576 octets if they have assurance that the destination is prepared to accept the larger datagrams.</p>
<p class="startli">The number 576 is selected to allow a reasonable sized data block to be transmitted in addition to the required header information. For example, this size allows a data block of 512 octets plus 64 header octets to fit in a datagram. The maximal internet header is 60 octets, and a typical internet header is 20 octets, allowing a margin for headers of higher level protocols.</p>
</li>
<li><p class="startli">Identification: 16 bits</p>
<p class="startli">An identifying value assigned by the sender to aid in assembling the fragments of a datagram.</p>
</li>
<li>Flags: 3 bits</li>
</ul>
<div class="image">
<img src="DFBit75.png" alt=""/>
<div class="caption">
IP Version 4 Control Flags</div></div>
 <ul>
<li><p class="startli">Fragment Offset: 13 bits</p>
<p class="startli">This field indicates where in the datagram this fragment belongs The fragment offset is measured in units of 8 octets (64 bits). The first fragment has offset zero.</p>
</li>
<li><p class="startli">Time to Live: 8 bits</p>
<p class="startli">This field indicates the maximum time the datagram is allowed to remain in the internet system. If this field contains the value zero, then the datagram must be destroyed. This field is modified in internet header processing. The time is measured in units of seconds, but since every module that processes a datagram must decrease the TTL by at least one even if it process the datagram in less than a second, the TTL must be thought of only as an upper bound on the time a datagram may exist. The intention is to cause undeliverable datagrams to be discarded, and to bound the maximum datagram lifetime.</p>
</li>
<li><p class="startli">Protocol: 8 bits</p>
<p class="startli">This field indicates the next level protocol used in the data portion of the internet datagram. The values for various protocols are specified in "Assigned Numbers"</p>
</li>
<li><p class="startli">Header Checksum: 16 bits</p>
<p class="startli">A checksum on the header only. Since some header fields change (e.g., time to live), this is recomputed and verified at each point that the internet header is processed. The checksum algorithm is:</p>
<p class="startli">The checksum field is the 16 bit one’s complement of the one’s complement sum of all 16 bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.</p>
<p class="startli">This is a simple to compute checksum and experimental evidence indicates it is adequate, but it is provisional and may be replaced by a CRC procedure, depending on further experience.</p>
</li>
<li><p class="startli">Source Address: 32 bits</p>
<p class="startli">The source address. See section 3.2.</p>
</li>
<li><p class="startli">Destination Address: 32 bits</p>
<p class="startli">The destination address. See section 3.2.</p>
</li>
</ul>
<p>The header for IPv6 is configured as follows (see RFC 2460) [2]</p>
<div class="image">
<img src="IPv6Header50.png" alt=""/>
<div class="caption">
IP Version 6 Header</div></div>
 <ul>
<li><p class="startli">Version: <br  />
</p>
<p class="startli">4-bit Internet Protocol version number = 6.</p>
</li>
<li><p class="startli">Traffic Class:</p>
<p class="startli">8-bit traffic class field. See section 7.</p>
</li>
<li><p class="startli">Flow Label:</p>
<p class="startli">20-bit flow label. See section 6.</p>
</li>
<li><p class="startli">Payload Length:</p>
<p class="startli">16-bit unsigned integer. Length of the IPv6 payload, i.e., the rest of the packet following this IPv6 header, in octets. (Note that any extension headers present are considered part of the payload, i.e., included in the length count.)</p>
</li>
<li><p class="startli">Next Header:</p>
<p class="startli">8-bit selector. Identifies the type of header immediately following the IPv6 header. Uses the same values as the IPv4 Protocol field [RFC-1700 et seq.]</p>
</li>
<li><p class="startli">Hop Limit:</p>
<p class="startli">8-bit unsigned integer. Decremented by 1 by each node that forwards the packet. The packet is discarded if Hop Limit is decremented to zero.</p>
</li>
<li><p class="startli">Source Address:</p>
<p class="startli">128-bit address of the originator of the packet</p>
</li>
<li><p class="startli">Destination Address:</p>
<p class="startli">128-bit address of the intended recipient of the packet (possibly not the ultimate recipient, if a Routing header is present)</p>
</li>
</ul>
<p><b>IPv4 vs IPv6 Header Comparison [3]</b></p>
<div class="image">
<img src="IP_hdr_comp.png" alt=""/>
<div class="caption">
Comparison of IPv4 and IPv6 Header Fields</div></div>
 <p><b>IPv6 Extension Headers</b></p>
<p>In IPv6, optional internet-layer information is encoded in separate headers that may be placed between the IPv6 header and the upper layer header in a packet. There are a small number of such extension headers, each identified by a distinct Next Header value. As illustrated in these examples, an IPv6 packet may carry zero, one, or more extension headers, each identified by the Next Header field of the preceding header:</p>
<div class="image">
<img src="IPv6Headers1.png" alt=""/>
<div class="caption">
IPv6 Extension Headers</div></div>
 <p>With one exception, extension headers are not examined or processed by any node along a packet’s delivery path, until the packet reaches the node (or each of the set of nodes, in the case of multicast) identified in the Destination Address field of the IPv6 header. There, normal demultiplexing on the Next Header field of the IPv6 header invokes the module to process the first extension header, or the upper-layer header if no extension header is present. The contents and semantics of each extension header determine whether or not to proceed to the next header. Therefore, extension headers must be processed strictly in the order they appear in the packet; a receiver must not, for example, scan through a packet looking for a particular kind of extension header and process that header prior to processing all preceding ones.</p>
<p>The exception referred to in the preceding paragraph is the Hop-by Hop Options header, which carries information that must be examined and processed by every node along a packet’s delivery path, including the source and destination nodes. The Hop-by-Hop Options header, when present, must immediately follow the IPv6 header. Its presence is indicated by the value zero in the Next Header field of the IPv6 header. If, as a result of processing a header, a node is required to proceed to the next header but the Next Header value in the current header is unrecognized by the node, it should discard the packet and send an ICMP Parameter Problem message to the source of the packet, with an ICMP Code value of 1 ("unrecognized Next Header type encountered") and the ICMP Pointer field containing the offset of the unrecognized value within the original packet. The same action should be taken if a node encounters a Next Header value of zero in any header other than an IPv6 header. Each extension header is an integer multiple of 8 octets long, in order to retain 8-octet alignment for subsequent headers. Multi octet fields within each extension header are aligned on their natural boundaries, i.e., fields of width n octets are placed at an integer multiple of n octets from the start of the header, for n = 1, 2, 4, or 8. A full implementation of IPv6 includes implementation of the following extension headers:</p>
<p>Hop-by-Hop Options (including Jumbogram [RFC-2675]) Routing (Type 0) Fragment Destination Options Authentication (RFC-2402) Encapsulating Security Payload (RFC-2406)</p>
<p><b>Extension Header Order</b></p>
<p>When more than one extension header is used in the same packet, it is recommended that those headers appear in the following order:</p>
<ul>
<li>IPv6 header</li>
<li>Hop-by-Hop Options header</li>
<li>Destination Options header</li>
<li>Routing header</li>
<li>Fragment header</li>
<li>Authentication header</li>
<li>Encapsulating Security Payload header</li>
<li>Destination Options header</li>
<li>upper-layer header</li>
</ul>
<p><b>Extension Header Formats</b></p>
<p><b>Hop-by-Hop Options Header</b></p>
<p>The Hop-by-Hop Options header is used to carry optional information that must be examined by every node along a packet’s delivery path. The Hop-by-Hop Options header is identified by a Next Header value of 0 in the IPv6 header, and has the following format:</p>
<div class="image">
<img src="IPHeadersOptions75.png" alt=""/>
<div class="caption">
IPv6 Options Header</div></div>
 <ul>
<li><p class="startli">Next Header 8-bit selector</p>
<p class="startli">Identifies the type of header immediately following the Hop-by-Hop Options header. Uses the same values as the IPv4 Protocol field</p>
</li>
<li><p class="startli">Hdr Ext Len 8-bit unsigned integer</p>
<p class="startli">Length of the Hop-by-Hop Options header in 8-octet units, not including the first 8 octets.</p>
</li>
<li><p class="startli">Options Variable-length field</p>
<p class="startli">Length such that the complete Hop-by-Hop Options header is an integer multiple of 8 octets long. Contains one or more TLV-encoded options</p>
</li>
</ul>
<p><b>Jumbo Payload Option</b></p>
<p>The Jumbo Payload option is carried in an IPv6 Hop-by-Hop Options header, immediately following the IPv6 header. This option has an alignment requirement of 4n + 2. (See [IPv6, Section 4.2] for discussion of option alignment.) The option has the following format:</p>
<div class="image">
<img src="IPHeadersJumbo75.png" alt=""/>
<div class="caption">
IPv6 Jumbogram Header</div></div>
 <ul>
<li>Option Type 8-bit value of 0xC2 (hexadecimal)</li>
<li>Opt Data Len 8-bit value of 0x04</li>
<li><p class="startli">Jumbo Payload Length 32-bit unsigned integer</p>
<p class="startli">Length of the IPv6 packet in octets, excluding the IPv6 header but including the Hop-by-Hop Options header and any other extension headers present. Must be greater than 65,535.</p>
</li>
</ul>
<p><b>Routing Options Header</b></p>
<p>The Routing header is used by an IPv6 source to list one or more intermediate nodes to be "visited" on the way to a packet’s destination. This function is very similar to IPv4’s Loose Source and Record Route option</p>
<p>The Routing header is identified by a Next Header value of 43 in the immediately preceding header, and has the following format:</p>
<div class="image">
<img src="IPHeadersRoute75.png" alt=""/>
<div class="caption">
IPv6 Routing Header</div></div>
 <ul>
<li><p class="startli">Next Header 8-bit selector</p>
<p class="startli">Identifies the type of header immediately following the Routing header Uses the same values as the IPv4 Protocol field</p>
</li>
<li><p class="startli">Hdr Ext Len 8-bit unsigned integer</p>
<p class="startli">Length of the Routing header in 8-octet units, not including the first 8 octets.</p>
</li>
<li><p class="startli">Routing Type 8-bit identifier</p>
<p class="startli">Identifies a particular Routing header variant</p>
</li>
<li><p class="startli">Segments Left 8-bit unsigned integer</p>
<p class="startli">Number of route segments remaining, i.e., number of explicitly listed intermediate nodes still to be visited before reaching the final destination.</p>
</li>
<li><p class="startli">type-specific data Variable-length field</p>
<p class="startli">Format determined by the Routing Type, and of length such that the complete Routing header is an integer multiple of 8 octets long</p>
</li>
</ul>
<p>If, while processing a received packet, a node encounters a Routing header with an unrecognized Routing Type value, the required behavior of the node depends on the value of the Segments Left field, as follows:</p>
<p>If Segments Left is zero, the node must ignore the Routing header and proceed to process the next header in the packet, whose type is identified by the Next Header field in the Routing header. If Segments Left is non-zero, the node must discard the packet and send an ICMP Parameter Problem, Code 0, message to the packet’s Source Address, pointing to the unrecognized Routing Type. If, after processing a Routing header of a received packet, an intermediate node determines that the packet is to be forwarded onto a link whose link MTU is less than the size of the packet, the node must discard the packet and send an ICMP Packet Too Big message to the packet’s Source Address</p>
<p>The Type 0 Routing header has the following format:</p>
<div class="image">
<img src="IPHeadersRoute075.png" alt=""/>
<div class="caption">
IPv6 Routing Type 0 Header</div></div>
 <p>Multicast addresses must not appear in a Routing header of Type 0, or in the IPv6 Destination Address field of a packet carrying a Routing header of Type 0</p>
<p>A Routing header is not examined or processed until it reaches the node identified in the Destination Address field of the IPv6 header. In that node, dispatching on the Next Header field of the immediately preceding header causes the Routing header module to be invoked, which, in the case of Routing Type 0, performs the following algorithm:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> Segments Left = 0 {</div>
<div class="line">    proceed to process the next header in the packet, whose type is</div>
<div class="line">    identified by the Next Header field in the Routing header</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> Hdr Ext Len is odd {</div>
<div class="line">    send an <a class="code" href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a01707ea74549b59906aacc339f3b2b45">ICMP</a> Parameter Problem, Code 0, message to the Source</div>
<div class="line">    Address, pointing to the Hdr Ext Len field, and discard the</div>
<div class="line">    packet</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    compute n, the number of addresses in the Routing header, by</div>
<div class="line">    dividing Hdr Ext Len by 2</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> Segments Left is greater than n {</div>
<div class="line">        send an <a class="code" href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a01707ea74549b59906aacc339f3b2b45">ICMP</a> Parameter Problem, Code 0, message to the Source</div>
<div class="line">        Address, pointing to the Segments Left field, and discard the</div>
<div class="line">        packet</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        decrement Segments Left by 1;</div>
<div class="line">        compute i, the index of the next address to be visited in</div>
<div class="line">        the address vector, by subtracting Segments Left from n</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> Address [i] or the IPv6 Destination Address is multicast {</div>
<div class="line">            discard the packet</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <a class="code" href="namespaceProtocolPP.html#a6c7793aaf65e41dd012e888085221fd9">swap</a> the IPv6 Destination Address and Address[i]</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> the IPv6 Hop Limit is less than or equal to 1 {</div>
<div class="line">                send an <a class="code" href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a01707ea74549b59906aacc339f3b2b45">ICMP</a> Time Exceeded -- Hop Limit Exceeded in</div>
<div class="line">                Transit message to the Source Address and discard the</div>
<div class="line">                packet</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                decrement the Hop Limit by 1</div>
<div class="line"> </div>
<div class="line">                resubmit the packet to the IPv6 module <span class="keywordflow">for</span> transmission</div>
<div class="line">                to the <span class="keyword">new</span> destination</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceProtocolPP_html_a6c7793aaf65e41dd012e888085221fd9"><div class="ttname"><a href="namespaceProtocolPP.html#a6c7793aaf65e41dd012e888085221fd9">ProtocolPP::swap</a></div><div class="ttdeci">static void swap(w128_t *array, int size)</div><div class="ttdef"><b>Definition:</b> SFMT-alti.h:148</div></div>
<div class="ttc" id="anamespaceProtocolPP_html_acfb3e3c6ca0eb6279a8e73b93f9c91e8a01707ea74549b59906aacc339f3b2b45"><div class="ttname"><a href="namespaceProtocolPP.html#acfb3e3c6ca0eb6279a8e73b93f9c91e8a01707ea74549b59906aacc339f3b2b45">ProtocolPP::ICMP</a></div><div class="ttdeci">@ ICMP</div><div class="ttdoc">Internet Control Message Protocol (ICMP) version 4 - 1.</div><div class="ttdef"><b>Definition:</b> jenum.h:1911</div></div>
</div><!-- fragment --><p><b>Fragment Options Header</b></p>
<p>The Fragment header is used by an IPv6 source to send a packet larger than would fit in the path MTU to its destination. (Note: unlike IPv4, fragmentation in IPv6 is performed only by source nodes, not by routers along a packet’s delivery path &ndash; see section 5.) The Fragment header is identified by a Next Header value of 44 in the immediately preceding header, and has the following format:</p>
<div class="image">
<img src="IPHeadersFrag75.png" alt=""/>
<div class="caption">
IPv6 Fragmentation Header</div></div>
 <ul>
<li><p class="startli">Next Header 8-bit selector</p>
<p class="startli">Identifies the initial header type of the Fragmentable Part of the original packet (defined below). Uses the same values as the IPv4 Protocol field</p>
</li>
<li><p class="startli">Reserved 8-bit reserved field</p>
<p class="startli">Initialized to zero for transmission; ignored on reception</p>
</li>
<li><p class="startli">Fragment Offset 13-bit unsigned integer</p>
<p class="startli">The offset, in 8-octet units, of the data following this header, relative to the start of the Fragmentable Part of the original packet.</p>
</li>
<li><p class="startli">Res 2-bit reserved field.</p>
<p class="startli">Initialized to zero for transmission; ignored on reception.</p>
</li>
<li>M flag 1 = more fragments; 0 = last fragment</li>
<li>Identification 32 bits</li>
</ul>
<p><b>Destination Options Header</b></p>
<p>The Destination Options header is used to carry optional information that need be examined only by a packet’s destination node(s). The Destination Options header is identified by a Next Header value of 60 in the immediately preceding header, and has the following format:</p>
<div class="image">
<img src="IPHeadersOptions75.png" alt=""/>
<div class="caption">
IPv6 Destinations Options Header</div></div>
 <ul>
<li><p class="startli">Next Header 8-bit selector</p>
<p class="startli">Identifies the type of header immediately following the Destination Options header. Uses the same values as the IPv4 Protocol field</p>
</li>
<li><p class="startli">Hdr Ext Len 8-bit unsigned integer</p>
<p class="startli">Length of the Destination Options header in 8-octet units, not including the first 8 octets</p>
</li>
<li><p class="startli">Options Variable-length field</p>
<p class="startli">Length such that the complete Destination Options header is an integer multiple of 8 octets long. Contains one or more TLV-encoded options, as described in section 4.2</p>
</li>
</ul>
<p>[1] <a href="http://orm-chimera-prod.s3.amazonaws.com/1230000000545/ch03.html">http://orm-chimera-prod.s3.amazonaws.com/1230000000545/ch03.html</a></p>
<p>[2] <a href="https://www.petri.com/ipv6-header-vs-ipv4">https://www.petri.com/ipv6-header-vs-ipv4</a></p>
<p>[3] <a href="http://help.mysonicwall.com/sw/eng/5505/ui2/25560/IPv6.html">http://help.mysonicwall.com/sw/eng/5505/ui2/25560/IPv6.html</a></p>
<p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jprotocol.html">ProtocolPP::jprotocol</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jip.html">ProtocolPP::jip</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jipsa.html">ProtocolPP::jipsa</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jicmp.html">ProtocolPP::jicmp</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jarray.html">ProtocolPP::jarray</a> </dd>
<dd>
ProtocolPP::jenum</dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjprotocol.html">jprotocol</a> </dd>
<dd>
<a class="el" href="classjip.html">jip</a> </dd>
<dd>
<a class="el" href="classjipsa.html">jipsa</a> </dd>
<dd>
<a class="el" href="classjicmp.html">jicmp</a> </dd>
<dd>
<a class="el" href="classjarray.html">jarray</a> </dd>
<dd>
<a class="el" href="classjenum.html">jenum</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2023 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jip.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classjip.html">jip</a></li>
    <li class="footer">Generated on Wed Jan 4 2023 18:29:10 for Protocol++(Protocolpp) by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
