<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++&reg; (Protocolpp&reg;): jtestbench/include/optionparser.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++&reg; (Protocolpp&reg;)
   &#160;<span id="projectnumber">v5.6.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('optionparser_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">optionparser.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the only file required to use The Lean Mean C++ Option Parser. Just #include it and you're set.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1Descriptor.html">option::Descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an option, its help text (usage) and how it should be parsed.  <a href="structoption_1_1Descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1Option.html">option::Option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parsed option from the command line together with its argument if it has one.  <a href="classoption_1_1Option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1Arg.html">option::Arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for checking the validity of option arguments.  <a href="structoption_1_1Arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1Stats.html">option::Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the minimum lengths of the buffer and options arrays used for <a class="el" href="classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are easier to work wit...">Parser</a>.  <a href="structoption_1_1Stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1Parser.html">option::Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks argument vectors for validity and parses them into data structures that are easier to work with.  <a href="classoption_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1Parser_1_1Action.html">option::Parser::Action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1Stats_1_1CountOptionsAction.html">option::Stats::CountOptionsAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1Parser_1_1StoreOptionAction.html">option::Parser::StoreOptionAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation.html">option::PrintUsageImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">option::PrintUsageImplementation::IStringWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html">option::PrintUsageImplementation::FunctionWriter&lt; Function &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html">option::PrintUsageImplementation::OStreamWriter&lt; OStream &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html">option::PrintUsageImplementation::TemporaryWriter&lt; Temporary &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html">option::PrintUsageImplementation::SyscallWriter&lt; Syscall &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoption_1_1PrintUsageImplementation_1_1StreamWriter.html">option::PrintUsageImplementation::StreamWriter&lt; Function, Stream &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">option::PrintUsageImplementation::LinePartIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">option::PrintUsageImplementation::LineWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceoption"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoption.html">option</a></td></tr>
<tr class="memdesc:namespaceoption"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace of The Lean Mean C++ <a class="el" href="classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> <a class="el" href="classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are easier to work wit...">Parser</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4cdf403efae65e18bf850e2001b12a2a"><td class="memItemLeft" align="right" valign="top">typedef ArgStatus(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoption.html#a4cdf403efae65e18bf850e2001b12a2a">option::CheckArg</a>) (const Option &amp;option, bool msg)</td></tr>
<tr class="memdesc:a4cdf403efae65e18bf850e2001b12a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of functions that check if an argument is valid for a certain type of option.  <a href="namespaceoption.html#a4cdf403efae65e18bf850e2001b12a2a">More...</a><br /></td></tr>
<tr class="separator:a4cdf403efae65e18bf850e2001b12a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aee8c76a07877335762631491e7a5a1a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9">option::ArgStatus</a> { <a class="el" href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e">option::ARG_NONE</a>
, <a class="el" href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55">option::ARG_OK</a>
, <a class="el" href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9">option::ARG_IGNORE</a>
, <a class="el" href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a9528e32563b795bd2930b12d0a5e382d">option::ARG_ILLEGAL</a>
 }</td></tr>
<tr class="memdesc:aee8c76a07877335762631491e7a5a1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible results when checking if an argument is valid for a certain option.  <a href="namespaceoption.html#aee8c76a07877335762631491e7a5a1a9">More...</a><br /></td></tr>
<tr class="separator:aee8c76a07877335762631491e7a5a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc8bb7e040a98a0b33ff1ce9da1be0d1"><td class="memTemplParams" colspan="2">template&lt;typename OStream &gt; </td></tr>
<tr class="memitem:afc8bb7e040a98a0b33ff1ce9da1be0d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoption.html#afc8bb7e040a98a0b33ff1ce9da1be0d1">option::printUsage</a> (OStream &amp;prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr class="memdesc:afc8bb7e040a98a0b33ff1ce9da1be0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping.  <a href="namespaceoption.html#afc8bb7e040a98a0b33ff1ce9da1be0d1">More...</a><br /></td></tr>
<tr class="separator:afc8bb7e040a98a0b33ff1ce9da1be0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846de0735717c8402b76d14f0a7a4430"><td class="memTemplParams" colspan="2"><a id="a846de0735717c8402b76d14f0a7a4430"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a846de0735717c8402b76d14f0a7a4430"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>option::printUsage</b> (Function *prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr class="separator:a846de0735717c8402b76d14f0a7a4430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e12a019c4da81e5031901af9c800cc"><td class="memTemplParams" colspan="2"><a id="a86e12a019c4da81e5031901af9c800cc"></a>
template&lt;typename Temporary &gt; </td></tr>
<tr class="memitem:a86e12a019c4da81e5031901af9c800cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>option::printUsage</b> (const Temporary &amp;prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr class="separator:a86e12a019c4da81e5031901af9c800cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84764f72d05ba8480143043e3d56ad6a"><td class="memTemplParams" colspan="2"><a id="a84764f72d05ba8480143043e3d56ad6a"></a>
template&lt;typename Syscall &gt; </td></tr>
<tr class="memitem:a84764f72d05ba8480143043e3d56ad6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>option::printUsage</b> (Syscall *prn, int fd, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr class="separator:a84764f72d05ba8480143043e3d56ad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bfa29dc37bb1bfc5e0b891509e5881"><td class="memTemplParams" colspan="2"><a id="a27bfa29dc37bb1bfc5e0b891509e5881"></a>
template&lt;typename Function , typename Stream &gt; </td></tr>
<tr class="memitem:a27bfa29dc37bb1bfc5e0b891509e5881"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>option::printUsage</b> (Function *prn, Stream *stream, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr class="separator:a27bfa29dc37bb1bfc5e0b891509e5881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the only file required to use The Lean Mean C++ Option Parser. Just #include it and you're set. </p>
<p>The Lean Mean C++ Option Parser handles the program's command line arguments (argc, argv). It supports the short and long option formats of getopt(), getopt_long() and getopt_long_only() but has a more convenient interface.</p>
<dl class="section user"><dt>Feedback:</dt><dd>Send questions, bug reports, feature requests etc. to: <code><b>optionparser-feedback(a)lists.sourceforge.net</b></code></dd></dl>
<dl class="section user"><dt>Highlights:</dt><dd><ul style="padding-left:1em;margin-left:0">
<li>
It is a header-only library. Just <code>#include "optionparser.h"</code> and you're set. </li>
<li>
It is freestanding. There are no dependencies whatsoever, not even the C or C++ standard library. </li>
<li>
It has a usage message formatter that supports column alignment and line wrapping. This aids localization because it adapts to translated strings that are shorter or longer (even if they contain Asian wide characters). </li>
<li>
Unlike getopt() and derivatives it doesn't force you to loop through options sequentially. Instead you can access options directly like this: <ul style="margin-top:.5em">
<li>
Test for presence of a switch in the argument vector: <div class="fragment"><div class="line"><span class="keywordflow">if</span> ( options[QUIET] ) ... </div>
</div><!-- fragment --> </li>
<li>
Evaluate &ndash;enable-foo/&ndash;disable-foo pair where the last one used wins: <div class="fragment"><div class="line"><span class="keywordflow">if</span> ( options[FOO].last()-&gt;type() == DISABLE ) ... </div>
</div><!-- fragment --> </li>
<li>
Cumulative option (-v verbose, -vv more verbose, -vvv even more verbose): <div class="fragment"><div class="line"><span class="keywordtype">int</span> verbosity = options[VERBOSE].count(); </div>
</div><!-- fragment --> </li>
<li>
Iterate over all &ndash;file=&lt;fname&gt; arguments: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (Option* opt = options[FILE]; opt; opt = opt-&gt;next())</div>
<div class="line"> fname = opt-&gt;arg; ... </div>
</div><!-- fragment --> </li>
<li>
If you really want to, you can still process all arguments in order: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; p.optionsCount(); ++i) {</div>
<div class="line">  Option&amp; opt = buffer[i];</div>
<div class="line">  <span class="keywordflow">switch</span>(opt.index()) {</div>
<div class="line">    <span class="keywordflow">case</span> HELP:    ...</div>
<div class="line">    <span class="keywordflow">case</span> VERBOSE: ...</div>
<div class="line">    <span class="keywordflow">case</span> FILE:    fname = opt.arg; ...</div>
<div class="line">    <span class="keywordflow">case</span> UNKNOWN: ...</div>
</div><!-- fragment --> </li>
</ul>
</li>
</ul>
<br  />
Despite these features the code size remains tiny. It is smaller than <a href="http://uclibc.org">uClibc</a>'s GNU getopt() and just a couple 100 bytes larger than uClibc's SUSv3 getopt(). <br  />
(This does not include the usage formatter, of course. But you don't have to use that.)</dd></dl>
<dl class="section user"><dt>Download:</dt><dd>Tarball with examples and test programs: <a href="http://sourceforge.net/projects/optionparser/files/optionparser-1.7.tar.gz/download" style="font-size:larger;font-weight:bold">optionparser-1.7.tar.gz</a> <br  />
Just the header (this is all you really need): <a href="http://optionparser.sourceforge.net/optionparser.h" style="font-size:larger;font-weight:bold">optionparser.h</a></dd></dl>
<dl class="section user"><dt>Changelog:</dt><dd><b>Version 1.7:</b> Work on const-correctness. <br  />
<b>Version 1.6:</b> Fix for MSC compiler. <br  />
<b>Version 1.5:</b> Fixed 2 warnings about potentially uninitialized variables. <br  />
 Added const version of Option::next(). <br  />
<b>Version 1.4:</b> Fixed 2 printUsage() bugs that messed up output with small COLUMNS values. <br  />
<b>Version 1.3:</b> Compatible with Microsoft Visual C++. <br  />
<b>Version 1.2:</b> Added <a class="el" href="classoption_1_1Option.html#a3aa2957b19ad5815873441b415d56050">Option::namelen</a> and removed the extraction of short option characters into a special buffer. <br  />
 Changed <a class="el" href="structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0">Arg::Optional</a> to accept arguments if they are attached rather than separate. This is what GNU getopt() does and how POSIX recommends utilities should interpret their arguments.<br  />
<b>Version 1.1:</b> Optional mode with argument reordering as done by GNU getopt(), so that options and non-options can be mixed. See <a class="el" href="classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138">Parser::parse()</a>.</dd></dl>
<dl class="section user"><dt>Example program:</dt><dd>(Note: <code>option:</code>:* identifiers are links that take you to their documentation.) <div class="fragment"><div class="line"><span class="preprocessor">#error EXAMPLE SHORTENED FOR READABILITY. BETTER EXAMPLES ARE IN THE .TAR.GZ!</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="optionparser_8h.html">optionparser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span>  optionIndex { UNKNOWN, HELP, PLUS };</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structoption_1_1Descriptor.html">option::Descriptor</a> usage[] =</div>
<div class="line">{</div>
<div class="line"> {UNKNOWN, 0,<span class="stringliteral">&quot;&quot;</span> , <span class="stringliteral">&quot;&quot;</span>    ,<a class="code" href="structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">option::Arg::None</a>, <span class="stringliteral">&quot;USAGE: example [options]\n\n&quot;</span></div>
<div class="line">                                            <span class="stringliteral">&quot;Options:&quot;</span> },</div>
<div class="line"> {HELP,    0,<span class="stringliteral">&quot;&quot;</span> , <span class="stringliteral">&quot;help&quot;</span>,<a class="code" href="structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">option::Arg::None</a>, <span class="stringliteral">&quot;  --help  \tPrint usage and exit.&quot;</span> },</div>
<div class="line"> {PLUS,    0,<span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;plus&quot;</span>,<a class="code" href="structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">option::Arg::None</a>, <span class="stringliteral">&quot;  --plus, -p  \tIncrement count.&quot;</span> },</div>
<div class="line"> {UNKNOWN, 0,<span class="stringliteral">&quot;&quot;</span> ,  <span class="stringliteral">&quot;&quot;</span>   ,<a class="code" href="structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">option::Arg::None</a>, <span class="stringliteral">&quot;\nExamples:\n&quot;</span></div>
<div class="line">                                            <span class="stringliteral">&quot;  example --unknown -- --this_is_no_option\n&quot;</span></div>
<div class="line">                                            <span class="stringliteral">&quot;  example -unk --plus -ppp file1 file2\n&quot;</span> },</div>
<div class="line"> {0,0,0,0,0,0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  argc-=(argc&gt;0); argv+=(argc&gt;0); <span class="comment">// skip program name argv[0] if present</span></div>
<div class="line">  <a class="code" href="structoption_1_1Stats.html">option::Stats</a>  stats(usage, argc, argv);</div>
<div class="line">  <a class="code" href="classoption_1_1Option.html">option::Option</a> options[stats.options_max], buffer[stats.buffer_max];</div>
<div class="line">  <a class="code" href="classoption_1_1Parser.html">option::Parser</a> parse(usage, argc, argv, options, buffer);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (parse.error())</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (options[HELP] || argc == 0) {</div>
<div class="line">    <a class="code" href="namespaceoption.html#afc8bb7e040a98a0b33ff1ce9da1be0d1">option::printUsage</a>(std::cout, usage);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;--plus count: &quot;</span> &lt;&lt;</div>
<div class="line">    options[PLUS].<a class="code" href="classoption_1_1Option.html#ad26a118ffebde656fd82c06709086bed">count</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classoption_1_1Option.html">option::Option</a>* opt = options[UNKNOWN]; opt; opt = opt-&gt;<a class="code" href="classoption_1_1Option.html#a59ae9aed505f4d410633bb36478a32be">next</a>())</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown option: &quot;</span> &lt;&lt; opt-&gt;name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; parse.nonOptionsCount(); ++i)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Non-option #&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; parse.nonOption(i) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassoption_1_1Option_html"><div class="ttname"><a href="classoption_1_1Option.html">option::Option</a></div><div class="ttdoc">A parsed option from the command line together with its argument if it has one.</div><div class="ttdef"><b>Definition:</b> optionparser.h:443</div></div>
<div class="ttc" id="aclassoption_1_1Option_html_a59ae9aed505f4d410633bb36478a32be"><div class="ttname"><a href="classoption_1_1Option.html#a59ae9aed505f4d410633bb36478a32be">option::Option::next</a></div><div class="ttdeci">Option * next()</div><div class="ttdoc">Returns a pointer to the next element of the linked list or NULL if called on last().</div><div class="ttdef"><b>Definition:</b> optionparser.h:695</div></div>
<div class="ttc" id="aclassoption_1_1Option_html_ad26a118ffebde656fd82c06709086bed"><div class="ttname"><a href="classoption_1_1Option.html#ad26a118ffebde656fd82c06709086bed">option::Option::count</a></div><div class="ttdeci">int count() const</div><div class="ttdoc">Returns the number of times this Option (or others with the same Descriptor::index) occurs in the arg...</div><div class="ttdef"><b>Definition:</b> optionparser.h:559</div></div>
<div class="ttc" id="aclassoption_1_1Parser_html"><div class="ttname"><a href="classoption_1_1Parser.html">option::Parser</a></div><div class="ttdoc">Checks argument vectors for validity and parses them into data structures that are easier to work wit...</div><div class="ttdef"><b>Definition:</b> optionparser.h:1090</div></div>
<div class="ttc" id="anamespaceoption_html_afc8bb7e040a98a0b33ff1ce9da1be0d1"><div class="ttname"><a href="namespaceoption.html#afc8bb7e040a98a0b33ff1ce9da1be0d1">option::printUsage</a></div><div class="ttdeci">void printUsage(OStream &amp;prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</div><div class="ttdoc">Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping.</div><div class="ttdef"><b>Definition:</b> optionparser.h:2824</div></div>
<div class="ttc" id="aoptionparser_8h_html"><div class="ttname"><a href="optionparser_8h.html">optionparser.h</a></div><div class="ttdoc">This is the only file required to use The Lean Mean C++ Option Parser. Just #include it and you're se...</div></div>
<div class="ttc" id="astructoption_1_1Arg_html_a7fc01987899c91c6b6a1be5711a46e22"><div class="ttname"><a href="structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">option::Arg::None</a></div><div class="ttdeci">static ArgStatus None(const Option &amp;, bool)</div><div class="ttdoc">For options that don't take an argument: Returns ARG_NONE.</div><div class="ttdef"><b>Definition:</b> optionparser.h:926</div></div>
<div class="ttc" id="astructoption_1_1Descriptor_html"><div class="ttname"><a href="structoption_1_1Descriptor.html">option::Descriptor</a></div><div class="ttdoc">Describes an option, its help text (usage) and how it should be parsed.</div><div class="ttdef"><b>Definition:</b> optionparser.h:316</div></div>
<div class="ttc" id="astructoption_1_1Stats_html"><div class="ttname"><a href="structoption_1_1Stats.html">option::Stats</a></div><div class="ttdoc">Determines the minimum lengths of the buffer and options arrays used for Parser.</div><div class="ttdef"><b>Definition:</b> optionparser.h:960</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Option syntax:</dt><dd><ul>
<li>The Lean Mean C++ Option Parser follows POSIX <code>getopt()</code> conventions and supports GNU-style <code>getopt_long()</code> long options as well as Perl-style single-minus long options (<code>getopt_long_only()</code>). </li>
<li>short options have the format <code>-X</code> where <code>X</code> is any character that fits in a char. </li>
<li>short options can be grouped, i.e. <code>-X -Y</code> is equivalent to <code>-XY</code>. </li>
<li>a short option may take an argument either separate (<code>-X foo</code>) or attached (<code>-Xfoo</code>). You can make the parser accept the additional format <code>-X=foo</code> by registering <code>X</code> as a long option (in addition to being a short option) and enabling single-minus long options. </li>
<li>an argument-taking short option may be grouped if it is the last in the group, e.g. <code>-ABCXfoo</code> or <code> -ABCX foo </code> (<code>foo</code> is the argument to the <code>-X</code> option). </li>
<li>a lone minus character <code>'-'</code> is not treated as an option. It is customarily used where a file name is expected to refer to stdin or stdout. </li>
<li>long options have the format <code>&ndash;option-name</code>. </li>
<li>the option-name of a long option can be anything and include any characters. Even <code>=</code> characters will work, but don't do that. </li>
<li>[optional] long options may be abbreviated as long as the abbreviation is unambiguous. You can set a minimum length for abbreviations. </li>
<li>[optional] long options may begin with a single minus. The double minus form is always accepted, too. </li>
<li>a long option may take an argument either separate (<code> &ndash;option arg </code>) or attached (<code> &ndash;option=arg </code>). In the attached form the equals sign is mandatory. </li>
<li>an empty string can be passed as an attached long option argument: <code> &ndash;option-name= </code>. Note the distinction between an empty string as argument and no argument at all. </li>
<li>an empty string is permitted as separate argument to both long and short options. </li>
<li>Arguments to both short and long options may start with a <code>'-'</code> character. E.g. <code> -X-X </code>, <code>-X -X</code> or <code> &ndash;long-X=-X </code>. If <code>-X</code> and <code>&ndash;long-X</code> take an argument, that argument will be <code>"-X"</code> in all 3 cases. </li>
<li>If using the built-in <a class="el" href="structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0">Arg::Optional</a>, optional arguments must be attached. </li>
<li>the special option <code>&ndash;</code> (i.e. without a name) terminates the list of options. Everything that follows is a non-option argument, even if it starts with a <code>'-'</code> character. The <code>&ndash;</code> itself will not appear in the parse results. </li>
<li>the first argument that doesn't start with <code>'-'</code> or <code>'&ndash;'</code> and does not belong to a preceding argument-taking option, will terminate the option list and is the first non-option argument. All following command line arguments are treated as non-option arguments, even if they start with <code>'-'</code> . <br  />
 NOTE: This behaviour is mandated by POSIX, but GNU getopt() only honours this if it is explicitly requested (e.g. by setting POSIXLY_CORRECT). <br  />
 You can enable the GNU behaviour by passing <code>true</code> as first argument to e.g. <a class="el" href="classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138">Parser::parse()</a>. </li>
<li>Arguments that look like options (i.e. <code>'-'</code> followed by at least 1 character) but aren't, are NOT treated as non-option arguments. They are treated as unknown options and are collected into a list of unknown options for error reporting. <br  />
 This means that in order to pass a first non-option argument beginning with the minus character it is required to use the <code>&ndash;</code> special option, e.g. <div class="fragment"><div class="line">program -x -- --strange-filename</div>
</div><!-- fragment --> In this example, <code>&ndash;strange-filename</code> is a non-option argument. If the <code>&ndash;</code> were omitted, it would be treated as an unknown option. <br  />
 See <a class="el" href="structoption_1_1Descriptor.html#a470c449dfa894c9bfda2dae026142b4b">option::Descriptor::longopt</a> for information on how to collect unknown options. </li>
</ul>
</dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_4adf3aab527e3df278199f710399a892.html">jtestbench</a></li><li class="navelem"><a class="el" href="dir_26117df3ca15fb64e5cc905593ec4d25.html">include</a></li><li class="navelem"><a class="el" href="optionparser_8h.html">optionparser.h</a></li>
    <li class="footer">Generated on Tue Jul 23 2024 08:35:46 for Protocol++&reg; (Protocolpp&reg;) by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
