<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++ (ProtocolPP): jsrtp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++ (ProtocolPP)
   &#160;<span id="projectnumber">5.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">jsrtp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="jsrtp_8h_source.html">include/jsrtp.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for jsrtp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classjsrtp__coll__graph.png" border="0" usemap="#jsrtp_coll__map" alt="Collaboration graph"/></div>
<map name="jsrtp_coll__map" id="jsrtp_coll__map">
</map>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="SRTP_Class"></a>
Secure Real-Time Protocol (SRTP)</h1>
<p><b>SRTP Framework</b></p>
<p>RTP is the Real-time Transport Protocol [RFC3550]. We define SRTP as a profile of RTP. This profile is an extension to the RTP Audio/Video Profile [RFC3551]. Except where explicitly noted, all aspects of that profile apply, with the addition of the SRTP security features. Conceptually, we consider SRTP to be a "bump in the stack" implementation which resides between the RTP application and the transport layer. SRTP intercepts RTP packets and then forwards an equivalent SRTP packet on the sending side, and intercepts SRTP packets and passes an equivalent RTP packet up the stack on the receiving side.</p>
<p>Secure RTCP (SRTCP) provides the same security services to RTCP as SRTP does to RTP. SRTCP message authentication is MANDATORY and thereby protects the RTCP fields to keep track of membership, provide feedback to RTP senders, or maintain packet sequence counters. SRTCP is described in Section 3.4.</p>
<p><b>Secure RTP (see IETF specifications RFC3711, RFC7741)</b></p>
<p>The format of an SRTP packet is illustrated in Figure 1 [1]</p>
<div class="image">
<img src="SRTP_HDR.png" alt="SRTP_HDR.png"/>
<div class="caption">
Secure Real-Time Protocol (SRTP) Packet Structure</div></div>
<p>The ﬁrst twelve octets are present in every RTP packet, while the list of CSRC identiﬁers is present only when inserted by a mixer. The ﬁelds have the following meaning:</p>
<ul>
<li><p class="startli">version (V): 2 bits</p>
<p class="startli">This ﬁeld identiﬁes the version of RTP. The version deﬁned by this speciﬁcation is two (2). (The value 1 is used by the ﬁrst draft version of RTP and the value 0 is used by the protocol initially implemented in the “vat” audio tool.)</p>
</li>
<li><p class="startli">padding (P): 1 bit</p>
<p class="startli">If the padding bit is set, the packet contains one or more additional padding octets at the end which are not part of the payload. The last octet of the padding contains a count of how many padding octets should be ignored, including itself. Padding may be needed by some encryption algorithms with ﬁxed block sizes or for carrying several RTP packets in a lower-layer protocol data unit.</p>
</li>
<li><p class="startli">extension (X): 1 bit</p>
<p class="startli">If the extension bit is set, the ﬁxed header must be followed by exactly one header extension, with a format deﬁned in Section 5.3.1.</p>
</li>
<li><p class="startli">CSRC count (CC): 4 bits</p>
<p class="startli">The CSRC count contains the number of CSRC identiﬁers that follow the ﬁxed header.</p>
</li>
<li><p class="startli">marker (M): 1 bit</p>
<p class="startli">The interpretation of the marker is deﬁned by a proﬁle. It is intended to allow signiﬁcant events such as frame boundaries to be marked in the packet stream. A proﬁle may deﬁne additional marker bits or specify that there is no marker bit by changing the number of bits in the payload type ﬁeld (see Section 5.3).</p>
</li>
<li><p class="startli">payload type (PT): 7 bits</p>
<p class="startli">This ﬁeld identiﬁes the format of the RTP payload and determines its interpretation by the application. A proﬁle may specify a default static mapping of payload type codes to payload formats. Additional payload type codes may bedeﬁned dynamically through non-RTP means (see Section 3). A set of default mappings for audio and video is speciﬁed in the companion RFC 3551 [1]. An RTP source may change the payload type during a session, but this ﬁeld should not be used for multiplexing separate media streams (see Section 5.2). A receiver must ignore packets with payload types that it does not understand.</p>
</li>
<li><p class="startli">sequence number: 16 bits</p>
<p class="startli">The sequence number increments by one for each RTP data packet sent, and may be used by the receiver to detect packet loss and to restore packet sequence. The initial value of the sequence number should be random (unpredictable) to make known-plaintext attacks on encryption more diﬃcult, even if the source itself does not encrypt according to the method in Section 9.1, because the packets may ﬂow through a translator that does. Techniques for choosing unpredictable numbers are discussed in [17].</p>
</li>
<li><p class="startli">timestamp: 32 bits</p>
<p class="startli">The timestamp reﬂects the sampling instant of the ﬁrst octet in the RTP data packet. The sampling instant must be derived from a clock that increments monotonically and linearly in time to allow synchronization and jitter calculations (see Section 6.4.1). The resolution of the clock must be suﬃcient for the desired synchronization accuracy and for measuring packet arrival jitter (one tick per video frame is typically not suﬃcient). The clock frequency is dependent on the format of data carried as payload and is speciﬁed statically in the proﬁle or payload format speciﬁcation that deﬁnes the format, or may be speciﬁed dynamically for payload formats deﬁned through non-RTP means. If RTP packets are generated periodically, the nominal sampling instant as determined from the sampling clock is to be used, not a reading of the system clock. As an example, for ﬁxed-rate audio the timestamp clock would likely increment byone for each samplingperiod. If an audio application reads blocks covering 160 sampling periods from the input device, the timestamp would be increased by 160 for each such block, regardless of whether the block is transmitted in a packet or dropped as silent. The initial value of the timestamp should be random, as for the sequence number. Several consecutive RTP packets will have equal timestamps if they are (logically) generated at once, e.g., belong to the same video frame. Consecutive RTP packets may contain timestamps that are not monotonic if the data is not transmitted in the order it was sampled, as in the case of MPEG interpolated video frames. (The sequence numbers of the packets as transmitted will still be monotonic.) RTP timestamps from diﬀerent media streams may advance at diﬀerent rates and usually have independent, random oﬀsets. Therefore, although these timestamps are suﬃcient to reconstruct the timing of a single stream, directly comparing RTP timestamps from diﬀerent media is not eﬀective for synchronization. Instead, for each medium the RTP timestamp is related to the sampling instant by pairing it with a timestamp from a reference clock (wallclock) that represents the time when the data corresponding to the RTP timestamp was sampled. The reference clock is shared by all media to be synchronized. The timestamp pairs are not transmitted in every data packet, but at a lower rate in RTCP SR packets as described in Section 6.4. The sampling instant is chosen as the point of reference for the RTP timestamp because it is known to the transmitting endpoint and has a common deﬁnition for all media, independent of encoding delays or other processing. The purpose is to allow synchronized presentation of all media sampled at the same time. Applications transmitting stored data rather than data sampled in real time typically use a virtual presentation timeline derived from wallclock time to determine when the next frame or other unit of each medium in the stored data should be presented. In this case, the RTP timestamp would reﬂect the presentation time for each unit. That is, the RTP timestamp for each unit would be related to the wallclock time at which the unit becomes current on the virtual presentation timeline. Actual presentation occurs some time later as determined by the receiver. An example describing live audio narration of prerecorded video illustrates the signiﬁcance of choosing the sampling instant as the reference point. In this scenario, the video would be presented locally for the narrator to view and would be simultaneously transmitted using RTP. The “sampling instant” of a video frame transmitted in RTP would be established by referencing its timestamp to the wallclock time when that video frame was presented to the narrator. The sampling instant for the audio RTP packets containing the narrator’s speech would be established by referencing the same wallclock time when the audio was sampled. The audio and video may even be transmitted by diﬀerent hosts if the reference clocks on the two hosts are synchronized by some means such as NTP. A receiver can then synchronize presentation of the audio and video packets by relating their RTP timestamps using the timestamp pairs in RTCP SR packets.</p>
</li>
<li><p class="startli">SSRC: 32 bits</p>
<p class="startli">The SSRC ﬁeld identiﬁes the synchronization source. This identiﬁer should be chosen randomly, with the intent that no two synchronization sources within the same RTP session will have the same SSRC identiﬁer. An example algorithm for generating a random identiﬁer is presented in Appendix A.6. Although the probability of multiple sources choosing the same identiﬁer is low, all RTP implementations must be prepared to detect and resolve collisions. Section 8 describes the probability of collision along with a mechanism for resolving collisions and detecting RTP-level forwarding loops based on the uniqueness of the SSRC identiﬁer. If a source changes its source transport address, it must also choose a new SSRC identiﬁer to avoid being interpreted as a looped source (see Section 8.2).</p>
</li>
<li><p class="startli">CSRC list: 0 to 15 items, 32 bits each</p>
<p class="startli">The CSRC list identiﬁes the contributing sources for the payload contained in this packet. The number of identiﬁers is given by the CC ﬁeld. If there are more than 15 contributing sources, only 15 can be identiﬁed. CSRC identiﬁers are inserted by mixers (see Section 7.1), using the SSRC identiﬁers of contributing sources. For example, for audio packets the SSRC identiﬁers of all sources that were mixed together to create a packet are listed, allowing correct talker indication at the receiver.</p>
</li>
</ul>
<p>The "Encrypted Portion" of an SRTP packet consists of the encryption of the RTP payload (including RTP padding when present) of the equivalent RTP packet. The Encrypted Portion MAY be the exact size of the plaintext or MAY be larger. Figure 1 shows the RTP payload including any possible padding for RTP [RFC3550].</p>
<p>None of the pre-defined encryption transforms uses any padding; for these, the RTP and SRTP payload sizes match exactly. New transforms added to SRTP (following Section 6) may require padding, and may hence produce larger payloads. RTP provides its own padding format (as seen in Fig. 1), which due to the padding indicator in the RTP header has merits in terms of compactness relative to paddings using prefix-free codes. This RTP padding SHALL be the default method for transforms requiring padding. Transforms MAY specify other padding methods, and MUST then specify the amount, format, and processing of their padding. It is important to note that encryption transforms that use padding are vulnerable to subtle attacks, especially when message authentication is not used [V02]. Each specification for a new encryption transform needs to carefully consider and describe the security implications of the padding that it uses. Message authentication codes define their own padding, so this default does not apply to authentication transforms.</p>
<p>The OPTIONAL MKI and the RECOMMENDED authentication tag are the only fields defined by SRTP that are not in RTP. Only 8-bit alignment is assumed.</p>
<ul>
<li>MKI (Master Key Identifier): configurable length, OPTIONAL. The MKI is defined, signaled, and used by key management. The MKI identifies the master key from which the session key(s) were derived that authenticate and/or encrypt the particular packet. Note that the MKI SHALL NOT identify the SRTP cryptographic context, which is identified according to Section 3.2.3. The MKI MAY be used by key management for the purposes of re-keying, identifying a particular master key within the cryptographic context (Section 3.2.1).</li>
<li>Authentication tag: configurable length, RECOMMENDED. The authentication tag is used to carry message authentication data. The Authenticated Portion of an SRTP packet consists of the RTP header followed by the Encrypted Portion of the SRTP packet. Thus, if both encryption and authentication are applied, encryption SHALL be applied before authentication on the sender side and conversely on the receiver side. The authentication tag provides authentication of the RTP header and payload, and it indirectly provides replay protection by authenticating the sequence number. Note that the MKI is not integrity protected as this does not provide any extra protection.</li>
</ul>
<p><b>SRTP Cryptographic Contexts</b></p>
<p>Each SRTP stream requires the sender and receiver to maintain cryptographic state information. This information is called the "cryptographic context". SRTP uses two types of keys: session keys and master keys. By a "session key", we mean a key which is used directly in a cryptographic transform (e.g., encryption or message authentication), and by a "master key", we mean a random bit string (given by the key management protocol) from which session keys are derived in a cryptographically secure way. The master key(s) and other parameters in the cryptographic context are provided by key management mechanisms external to SRTP, see Section 8.</p>
<p><b>Transform-independent parameters</b></p>
<p>Transform-independent parameters are present in the cryptographic context independently of the particular encryption or authentication transforms that are used. The transform-independent parameters of the cryptographic context for SRTP consist of:</p>
<ul>
<li><p class="startli">a 32-bit unsigned rollover counter (ROC), which records how many times the 16-bit RTP sequence number has been reset to zero after passing through 65,535. Unlike the sequence number (SEQ), which SRTP extracts from the RTP packet header, the ROC is maintained by SRTP as described in Section 3.3.1.</p>
<p class="startli">We define the index of the SRTP packet corresponding to a given ROC and RTP sequence number to be the 48-bit quantity</p>
</li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ i = {2}^{16} \oplus ROC + SEQ \]" src="form_416.png"/>
</p>
<ul>
<li>for the receiver only, a 16-bit sequence number s_l, which can be thought of as the highest received RTP sequence number (see Section 3.3.1 for its handling), which SHOULD be authenticated since message authentication is RECOMMENDED,</li>
<li>an identifier for the encryption algorithm, i.e., the cipher and its mode of operation,</li>
<li>an identifier for the message authentication algorithm,</li>
<li>a replay list, maintained by the receiver only (when authentication and replay protection are provided), containing indices of recently received and authenticated SRTP packets,</li>
<li>an MKI indicator (0/1) as to whether an MKI is present in SRTP and SRTCP packets,</li>
<li>if the MKI indicator is set to one, the length (in octets) of the MKI field, and (for the sender) the actual value of the currently active MKI (the value of the MKI indicator and length MUST be kept fixed ror the lifetime of the context),</li>
<li>the master key(s), which MUST be random and kept secret,</li>
<li>for each master key, there is a counter of the number of SRTP packets that have been processed (sent) with that master key (essential for security, see Sections 3.3.1 and 9),</li>
<li>non-negative integers n_e, and n_a, determining the length of the session keys for encryption, and message authentication.</li>
</ul>
<p>In addition, for each master key, an SRTP stream MAY use the following associated values:</p>
<ul>
<li>a master salt, to be used in the key derivation of session keys. This value, when used, MUST be random, but MAY be public. Use of master salt is strongly RECOMMENDED, see Section 9.2. A "NULL" salt is treated as 00...0.</li>
<li>an integer in the set {1,2,4,..., <img class="formulaInl" alt="${2}^{24}$" src="form_417.png"/> }, the "key_derivation_rate", where an unspecified value is treated as zero. The constraint to be a power of 2 simplifies the session-key derivation implementation, see Section 4.3.</li>
<li>an MKI value,</li>
<li>&lt;From, To&gt; values, specifying the lifetime for a master key, expressed in terms of the two 48-bit index values inside whose range (including the range end-points) the master key is valid. For the use of &lt;From, To&gt;, see Section 8.1.1. &lt;From, To&gt; is an alternative to the MKI and assumes that a master key is in one to-one correspondence with the SRTP session key on which the &lt;From, To&gt; range is defined.</li>
</ul>
<p>` SRTCP SHALL by default share the crypto context with SRTP, except:</p>
<ul>
<li>no rollover counter and s_l-value need to be maintained as the RTCP index is explicitly carried in each SRTCP packet,</li>
<li>a separate replay list is maintained (when replay protection is provided),</li>
<li>SRTCP maintains a separate counter for its master key (even if the master key is the same as that for SRTP, see below), as a means to maintain a count of the number of SRTCP packets that have been processed with that key.</li>
</ul>
<p>Note in particular that the master key(s) MAY be shared between SRTP and the corresponding SRTCP, if the pre-defined transforms (including the key derivation) are used but the session key(s) MUST NOT be so shared.</p>
<p>In addition, there can be cases (see Sections 8 and 9.1) where several SRTP streams within a given RTP session, identified by their synchronization source (SSRCs, which is part of the RTP header), share most of the crypto context parameters (including possibly master and session keys). In such cases, just as in the normal SRTP/SRTCP parameter sharing above, separate replay lists and packet counters for each stream (SSRC) MUST still be maintained.</p>
<p>Also, separate SRTP indices MUST then be maintained. A summary of parameters, pre-defined transforms, and default values for the above parameters (and other SRTP parameters) can be found in Sections 5 and 8.2.</p>
<h2><a class="anchor" id="SRTP_PKT"></a>
SRTP Packet Processing</h2>
<p>Assuming initialization of the cryptographic context(s) has taken place via key management, the sender SHALL do the following to construct an SRTP packet:</p>
<ol type="1">
<li>Determine which cryptographic context to use as described in Section 3.2.3.</li>
<li>Determine the index of the SRTP packet using the rollover counter, the highest sequence number in the cryptographic context, and the sequence number in the RTP packet, as described in Section 3.3.1.</li>
<li>Determine the master key and master salt. This is done using the index determined in the previous step or the current MKI in the cryptographic context, according to Section 8.1.</li>
<li>Determine the session keys and session salt (if they are used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate, and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.</li>
<li>Encrypt the RTP payload to produce the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers). This step uses the encryption algorithm indicated in the cryptographic context, the session encryption key and the session salt (if used) found in Step 4 together with the index found in Step 2.</li>
<li>If the MKI indicator is set to one, append the MKI to the packet.</li>
<li>For message authentication, compute the authentication tag for the Authenticated Portion of the packet, as described in Section 4.2. This step uses the current rollover counter, the authentication algorithm indicated in the cryptographic context, and the session authentication key found in Step 4. Append the authentication tag to the packet.</li>
<li>If necessary, update the ROC as in Section 3.3.1, using the packet index determined in Step 2.</li>
</ol>
<p>To authenticate and decrypt an SRTP packet, the receiver SHALL do the following:</p>
<ol type="1">
<li>Determine which cryptographic context to use as described in Section 3.2.3.</li>
<li>Run the algorithm in Section 3.3.1 to get the index of the SRTP packet. The algorithm uses the rollover counter and highest sequence number in the cryptographic context with the sequence number in the SRTP packet, as described in Section 3.3.1.</li>
<li>Determine the master key and master salt. If the MKI indicator in the context is set to one, use the MKI in the SRTP packet, otherwise use the index from the previous step, according to Section 8.1.</li>
<li>Determine the session keys, and session salt (if used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.</li>
<li><p class="startli">For message authentication and replay protection, first check if the packet has been replayed (Section 3.3.2), using the Replay List and the index as determined in Step 2. If the packet is judged to be replayed, then the packet MUST be discarded, and the event SHOULD be logged.</p>
<p class="startli">Next, perform verification of the authentication tag, using the rollover counter from Step 2, the authentication algorithm indicated in the cryptographic context, and the session authentication key from Step 4. If the result is "AUTHENTICATION FAILURE" (see Section 4.2), the packet MUST be discarded from further processing and the event SHOULD be logged.</p>
</li>
<li>Decrypt the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers), using the decryption algorithm indicated in the cryptographic context, the session encryption key and salt (if used) found in Step 4 with the index from Step 2.</li>
<li>Update the rollover counter and highest sequence number, s_l, in the cryptographic context as in Section 3.3.1, using the packet index estimated in Step 2. If replay protection is provided, also update the Replay List as described in Section 3.3.2.</li>
<li>When present, remove the MKI and authentication tag fields from the packet.</li>
</ol>
<p><b>Packet Index Determination, and ROC, s_l Update</b></p>
<p>SRTP implementations use an "implicit" packet index for sequencing, i.e., not all of the index is explicitly carried in the SRTP packet. For the pre-defined transforms, the index i is used in replay protection (Section 3.3.2), encryption (Section 4.1), message authentication (Section 4.2), and for the key derivation (Section 4.3).</p>
<p>When the session starts, the sender side MUST set the rollover counter, ROC, to zero. Each time the RTP sequence number, SEQ, wraps modulo <img class="formulaInl" alt="${2}^{16}$" src="form_418.png"/>, the sender side MUST increment ROC by one, modulo <img class="formulaInl" alt="${2}^{32}$" src="form_340.png"/> (see security aspects below). The sender’s packet index is then defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ i = {2}^{16} \oplus ROC + SEQ \]" src="form_416.png"/>
</p>
<p>Receiver-side implementations use the RTP sequence number to determine the correct index of a packet, which is the location of the packet in the sequence of all SRTP packets. A robust approach for the proper use of a rollover counter requires its handling and use to be well defined. In particular, out-of-order RTP packets with sequence numbers close to <img class="formulaInl" alt="${2}^{16}$" src="form_418.png"/> or zero must be properly handled.</p>
<p>The index estimate is based on the receiver’s locally maintained ROC and s_l values. At the setup of the session, the ROC MUST be set to zero. Receivers joining an on-going session MUST be given the current ROC value using out-of-band signaling such as key-management signaling. Furthermore, the receiver SHALL initialize s_l to the RTP sequence number (SEQ) of the first observed SRTP packet (unless the initial value is provided by out of band signaling such as key management).</p>
<p>On consecutive SRTP packets, the receiver SHOULD estimate the index as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ i = {2}^{16} \oplus v + SEQ \]" src="form_419.png"/>
</p>
<p>where v is chosen from the set { ROC-1, ROC, ROC+1 } (modulo <img class="formulaInl" alt="${2}^{32}$" src="form_340.png"/>) such that i is closest (in modulo <img class="formulaInl" alt="${2}^{48}$" src="form_420.png"/> sense) to the value <img class="formulaInl" alt="${2}^{16} \oplus ROC + s_l$" src="form_421.png"/> (see Appendix A for pseudocode).</p>
<p>After the packet has been processed and authenticated (when enabled for SRTP packets for the session), the receiver MUST use v to conditionally update its s_l and ROC variables as follows. If <img class="formulaInl" alt="$v=(ROC-1) \bmod{{2}^{32}}$" src="form_422.png"/>, then there is no update to s_l or ROC. If v=ROC, then s_l is set to SEQ if and only if SEQ is larger than the current s_l; there is no change to ROC. If <img class="formulaInl" alt="$v=(ROC+1) \bmod{{2}^{32}}$" src="form_423.png"/>, then s_l is set to SEQ and ROC is set to v.</p>
<p>After a re-keying occurs (changing to a new master key), the rollover counter always maintains its sequence of values, i.e., it MUST NOT be reset to zero.</p>
<p>As the rollover counter is 32 bits long and the sequence number is 16 bits long, the maximum number of packets belonging to a given SRTP stream that can be secured with the same key is <img class="formulaInl" alt="${2}^{48}$" src="form_420.png"/> using the predefined transforms. After that number of SRTP packets have been sent with a given (master or session) key, the sender MUST NOT send any more packets with that key. (There exists a similar limit for SRTCP, which in practice may be more restrictive, see Section 9.2.) This limitation enforces a security benefit by providing an upper bound on the amount of traffic that can pass before cryptographic keys are changed. Re-keying (see Section 8.1) MUST be triggered, before this amount of traffic, and MAY be triggered earlier, e.g., for increased security and access control to media. Recurring key derivation by means of a non-zero key_derivation_rate (see Section 4.3), also gives stronger security but does not change the above absolute maximum value.</p>
<p>On the receiver side, there is a caveat to updating s_l and ROC: if message authentication is not present, neither the initialization of s_l, nor the ROC update can be made completely robust. The receiver’s "implicit index" approach works for the pre-defined transforms as long as the reorder and loss of the packets are not too great and bit-errors do not occur in unfortunate ways. In particular, <img class="formulaInl" alt="${2}^{15}$" src="form_424.png"/> packets would need to be lost, or a packet would need to be <img class="formulaInl" alt="${2}^{15}$" src="form_424.png"/> packets out of sequence before synchronization is lost. Such drastic loss or reorder is likely to disrupt the RTP application itself.</p>
<p>The algorithm for the index estimate and ROC update is a matter of implementation, and should take into consideration the environment (e.g., packet loss rate) and the cases when synchronization is likely to be lost, e.g., when the initial sequence number (randomly chosen by RTP) is not known in advance (not sent in the key management protocol) but may be near to wrap modulo <img class="formulaInl" alt="${2}^{16}$" src="form_418.png"/>.</p>
<p>A more elaborate and more robust scheme than the one given above is the handling of RTP’s own "rollover counter", see Appendix A.1 of [RFC3550].</p>
<p><b>Replay Protection</b></p>
<p>Secure replay protection is only possible when integrity protection is present. It is RECOMMENDED to use replay protection, both for RTP and RTCP, as integrity protection alone cannot assure security against replay attacks.</p>
<p>A packet is "replayed" when it is stored by an adversary, and then re-injected into the network. When message authentication is provided, SRTP protects against such attacks through a Replay List. Each SRTP receiver maintains a Replay List, which conceptually contains the indices of all of the packets which have been received and authenticated. In practice, the list can use a "sliding window" approach, so that a fixed amount of storage suffices for replay protection. Packet indices which lag behind the packet index in the context by more than SRTP-WINDOW-SIZE can be assumed to have been received, where SRTP-WINDOW-SIZE is a receiver-side, implementation dependent parameter and MUST be at least 64, but which MAY be set to a higher value.</p>
<p>The receiver checks the index of an incoming packet against the replay list and the window. Only packets with index ahead of the window, or, inside the window but not already received, SHALL be accepted.</p>
<p>After the packet has been authenticated (if necessary the window is first moved ahead), the replay list SHALL be updated with the new index. The Replay List can be efficiently implemented by using a bitmap to represent which packets have been received, as described in the Security Architecture for IP [RFC2401].</p>
<h2><a class="anchor" id="SRTPAEAD"></a>
Generic AEAD Processing</h2>
<p>Types of Input Data</p>
<ul>
<li>Associated Data: This is data that is to be authenticated but not encrypted</li>
<li>Plaintext: Data that is to be both encrypted and authenticated</li>
<li>Raw Data: Data that is to be neither encrypted nor authenticated</li>
</ul>
<p>Which portions of SRTP/SRTCP packets that are to be treated as associated data, which are to be treated as plaintext, and which are to be treated as raw data</p>
<p><b>AEAD Invocation Inputs and Outputs</b></p>
<p>Encrypt Mode</p>
<p>Inputs:</p>
<ul>
<li>Encryption_key : Octet string, either 16 or 32 octets long</li>
<li>Initialization_Vector : Octet string, 12 octets long</li>
<li>Associated_Data : Octet string of variable length</li>
<li>Plaintext : Octet string of variable length</li>
</ul>
<p>Outputs:</p>
<ul>
<li>Ciphertext : Octet string, length = length(Plaintext)+tag_length</li>
</ul>
<p>(*): In AEAD the authentication tag in embedded in the cipher text. When GCM is being used the ciphertext consists of the encrypted plain text followed by the authentication tag.</p>
<p>Decrypt Mode</p>
<p>Inputs:</p>
<ul>
<li>Encryption_key : Octet string, either 16 or 32 octets long</li>
<li>Initialization_Vector : Octet string, 12 octets long</li>
<li>Associated_Data : Octet string of variable length</li>
<li>Ciphertext : Octet string of variable length</li>
</ul>
<p>Outputs:</p>
<ul>
<li>Plaintext : Octet string, length = length(Ciphertext)-tag_length</li>
<li>Validity_Flag : Boolean, TRUE if valid, FALSE otherwise</li>
</ul>
<p><b>Handling of AEAD Authentication</b></p>
<p>AEAD requires that all incoming packets MUST pass AEAD authentication before any other action takes place. Plaintext and associated data MUST NOT be released until the AEAD authentication tag has been validated. Further the ciphertext MUST NOT be decrypted until the AEAD tag has been validated.</p>
<p>Should the AEAD tag prove to be invalid, the packet in question is to be discarded and a Validation Error flag raised. Local policy determines how this flag is to be handled and is outside the scope of this document.</p>
<h2><a class="anchor" id="CTR"></a>
Counter Mode Encryption</h2>
<p>Each outbound packet uses a 12-octet IV and an encryption key to form two outputs, a 16-octet first_key_block which is used in forming the authentication tag and a key stream of octets, formed in blocks of 16-octets each. The first 16-octet block of key is saved for use in forming the authentication tag, and the remainder of the key stream is XORed to the plaintext to form cipher. This key stream is formed one block at a time by inputting the concatenation of a 12-octet IV (see sections 8.1 and 9.1) with a 4-octet block to AES. The pseudo-code below illustrates this process:</p>
<div class="fragment"><div class="line">def GCM_keystream( Plaintext_len, <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>, Encryption_key ):</div><div class="line">    assert Plaintext_len  &lt;= (2**36) - 32 ## measured in octets</div><div class="line">    key_stream = <span class="stringliteral">&quot;&quot;</span></div><div class="line">    block_counter = 1</div><div class="line">    first_key_block = AES_ENC( data=<a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>||block_counter,</div><div class="line">                               key=Encryption_key        )</div><div class="line">    while len(key_stream) &lt; Plaintext_len:</div><div class="line">          block_counter = block_counter + 1</div><div class="line">          key_block = AES_ENC( data=<a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36aea41ac6e2e650d48da10a7354e89e41a">IV</a>||block_counter,</div><div class="line">          key=Encryption_key        )</div><div class="line">          key_stream  = key_stream || key_block</div><div class="line">          key_stream = truncate( key_stream, Plaintext_len )</div><div class="line">    return (first_key_block, key_stream )</div></div><!-- fragment --><p>In theory this keystream generation process allows for the encryption of up to <img class="formulaInl" alt="${2}^{36}-32$" src="form_425.png"/> octets per invocation (i.e. per packet), far longer than is actually required.</p>
<p>With any counter mode, if the same (IV, Encryption_key) pair is used twice, precisely the same keystream is formed. As explained in section 9.1 of RFC 3711, this is a cryptographic disaster. For GCM the consequences are even worse since such a reuse compromises GCM’s integrity mechanism not only for the current packet stream but for all future uses of the current encryption_key.</p>
<p><b>Unneeded SRTP/SRTCP Fields</b></p>
<p>AEAD counter mode encryption removes the need for certain existing SRTP/SRTCP mechanisms.</p>
<p><b>SRTP/SRTCP Authentication Field</b></p>
<p>The AEAD message authentication mechanism MUST be the primary message authentication mechanism for AEAD SRTP/SRTCP. Additional SRTP/SRTCP authentication mechanisms SHOULD NOT be used with any AEAD algorithm and the optional SRTP/SRTCP Authentication Tags are NOT RECOMMENDED and SHOULD NOT be present. Note that this contradicts section 3.4 of [RFC3711] which makes the use of the SRTCP Authentication field mandatory, but the presence of the AEAD authentication renders the older authentication methods redundant.</p>
<p>Rationale - Some applications use the SRTP/SRTCP Authentication Tag as a means of conveying additional information, notably [RFC4771]. This document retains the Authentication Tag field primarily to preserve compatibility with these applications.</p>
<p><b>RTP Padding</b></p>
<p>AES-GCM does not requires that the data be padded out to a specific block size, reducing the need to use the padding mechanism provided by RTP. It is RECOMMENDED that the RTP padding mechanism not be used unless it is necessary to disguise the length of the underlying plaintext.</p>
<h2><a class="anchor" id="GCM"></a>
AES-GCM processing for SRTP</h2>
<p>SRTP IV formation for AES-GCM </p><div class="fragment"><div class="line"> 0  0  0  0  0  0  0  0  0  0  1  1</div><div class="line"> 0  1  2  3  4  5  6  7  8  9  0  1</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+</div><div class="line">|00|00|    <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a7d80d3a533775a3c8c284b3fa4e912dc">SSRC</a>   |     <a class="code" href="namespaceProtocolPP.html#a44018cab1f12fe3ca4e2f32c547eab36a5a1e29d6086a1f73243c7011251ebe05">ROC</a>   | SEQ |---+</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+   |</div><div class="line">                                        |</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+   |</div><div class="line">|         Encryption Salt           |-&gt;(+)</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+   |</div><div class="line">                                        |</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+   |</div><div class="line">|       Initialization Vector       |&lt;--+</div><div class="line">+--+--+--+--+--+--+--+--+--+--+--+--+</div><div class="line"></div><div class="line">Figure 1: AES-GCM <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> Initialization</div><div class="line">                Vector Formation</div></div><!-- fragment --><p>Vector formation - The 12 octet initialization vector used by AES-GCM SRTP is formed by first concatenating 2 octets of zeroes, the 4-octet SSRC, the 4-octet Rollover Counter (ROC) and the 2-octet sequence number SEQ. The resulting 12-octet value is then XORed to the 12-octet salt to form the 12-octet IV.</p>
<p><b>Summary of AES-GCM in SRTP/SRTCP</b></p>
<p>For convenience, much of the information about the use of AES-GCM family of algorithms in SRTP is collected in the tables contained in this section. The AES-GCM family of AEAD algorithms is built around the AES block cipher algorithm. AES-GCM uses AES counter mode for encryption and Galois Message Authentication Code (GMAC) for authentication. A detailed description of the AES-GCM family can be found in [RFC5116]. The following members of the AES-GCM family may be used with SRTP/SRTCP:</p>
<div class="fragment"><div class="line">Name                 Key Size      AEAD Tag Size      Reference</div><div class="line">================================================================</div><div class="line"><a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaa01a7325b7fee00d3b5ba4338f41ce98">AEAD_AES_128_GCM_8</a>   16 octets      8 octets          [RFC5282]</div><div class="line"><a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaed584c4871724defe401038282727f10">AEAD_AES_128_GCM</a>     16 octets     16 octets          [RFC5116]</div><div class="line"><a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaab1321b4cf5cd60af7427c10a0e69b46">AEAD_AES_256_GCM</a>     32 octets     16 octets          [RFC5116]</div><div class="line"></div><div class="line">        Table 1: AES-GCM algorithms <span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>/SRTCP</div></div><!-- fragment --><p> Any implementation of AES-GCM SRTP MUST support both AEAD_AES_128_GCM and AEAD_AES_256_GCM (the versions with 16 octet AEAD authentication tags), and it MAY support AEAD_AES_128_GCM_8 Below we summarize parameters associated with these three GCM algorithms:</p>
<div class="fragment"><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |</div><div class="line">+--------------------------------+------------------------------+ </div><div class="line">| Master key length              | 128 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_CM_PRF [RFC3711]         |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaa01a7325b7fee00d3b5ba4338f41ce98">AEAD_AES_128_GCM_8</a>           |</div><div class="line">| AEAD authentication tag length | 64 bits                      |</div><div class="line">+--------------------------------+------------------------------+</div><div class="line">            Table 2: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaa01a7325b7fee00d3b5ba4338f41ce98">AEAD_AES_128_GCM_8</a> Crypto Suite</div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |</div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 128 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_CM_PRF [RFC3711]         |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaed584c4871724defe401038282727f10">AEAD_AES_128_GCM</a>             |</div><div class="line">| AEAD authentication tag length | 128 bits                     |</div><div class="line">+--------------------------------+------------------------------+</div><div class="line">            Table 3: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaed584c4871724defe401038282727f10">AEAD_AES_128_GCM</a> Crypto Suite</div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |</div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 256 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_256_CM_PRF [RFC6188]     |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaab1321b4cf5cd60af7427c10a0e69b46">AEAD_AES_256_GCM</a>             |</div><div class="line">| AEAD authentication tag length | 128 bits                     |</div><div class="line">+--------------------------------+------------------------------+</div><div class="line">            Table 4: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aaab1321b4cf5cd60af7427c10a0e69b46">AEAD_AES_256_GCM</a> Crypto Suite</div></div><!-- fragment --><h2><a class="anchor" id="CCM"></a>
AES-CCM for SRTP/SRTCP</h2>
<p>AES-CCM is another family of AEAD algorithms built around the AES block cipher algorithm. AES-CCM uses AES counter mode for encryption and AES Cipher Block Chaining Message Authentication Code (CBC-MAC) for authentication. A detailed description of the AES-CCM family can be found in [RFC5116]. Four of the six CCM algorithms used in this document are defined in previous RFCs, while two, AEAD_AES_128_CCM_12 and AEAD_AES_256_CCM_12, are defined in section 7 of this document.</p>
<p>Any implementation of AES-CCM SRTP/SRTCP MUST support both AEAD_AES_128_CCM and AEAD_AES_256_CCM (the versions with 16 octet AEAD authentication tags), and MAY support the other four variants.</p>
<div class="fragment"><div class="line"> Name                 Key Size    AEAD Tag Size    Reference</div><div class="line">================================================================</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aadcf7870e8a78980e2fa96ea8f4995823">AEAD_AES_128_CCM</a>     128 bits    16 octets        [RFC5116]</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aab9bd2280e0c25c38fb7d3a4752c3062f">AEAD_AES_256_CCM</a>     256 bits    16 octets        [RFC5116]</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4e6c8615ed5f5c92f249a0f7609fd92b">AEAD_AES_128_CCM_12</a>  128 bits    12 octets        see section 7</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4a7fb6f702219969093b81a0bf205d69">AEAD_AES_256_CCM_12</a>  256 bits    12 octets        see section 7</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa327c03047e219f15650608d8953cff36">AEAD_AES_128_CCM_8</a>   128 bits     8 octets        [RFC6655]</div><div class="line"> <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa0b385f08c1fec36eaadb97fd584ebb20">AEAD_AES_256_CCM_8</a>   256 bits     8 octets        [RFC6655]</div><div class="line"></div><div class="line">         Table 6: AES-CCM algorithms <span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>/SRTCP</div></div><!-- fragment --><p> In addition to the flag octet used in counter mode encryption, AES-CCM authentications also uses a flag octet that conveys information about the length of the authentication tag, length of the block counter, and presence of additional authenticated data (see section 2.2 of [RFC3610]). For AES-CCM in SRTP/SRTCP, the flag octet has the hex value 5A if an 8-octet AEAD authentication tag is used, 6A if a 12-octet AEAD authentication tag is used, and 7A if a 16-octet AEAD authentication tag is used. The flag octet is one of the inputs to AES during the counter mode encryption of the plaintext. </p><div class="fragment"><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 128 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_CM_PRF [RFC3711]         |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa327c03047e219f15650608d8953cff36">AEAD_AES_128_CCM_8</a>           |</div><div class="line">| AEAD authentication tag length | 64 bits                      |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">           Table 7: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa327c03047e219f15650608d8953cff36">AEAD_AES_128_CCM_8</a> Crypto Suite</div><div class="line"></div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 128 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_CM_PRF [RFC3711]         |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4e6c8615ed5f5c92f249a0f7609fd92b">AEAD_AES_128_CCM_12</a>          |</div><div class="line">| AEAD authentication tag length | 96 bits                      |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">           Table 8: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4e6c8615ed5f5c92f249a0f7609fd92b">AEAD_AES_128_CCM_12</a> Crypto Suite</div><div class="line"></div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 128 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_CM_PRF [RFC3711]         |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aadcf7870e8a78980e2fa96ea8f4995823">AEAD_AES_128_CCM</a>             |</div><div class="line">| AEAD authentication tag length | 128 bits                     |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">            Table 9: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aadcf7870e8a78980e2fa96ea8f4995823">AEAD_AES_128_CCM</a> Crypto Suite</div><div class="line"></div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 256 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_256_CM_PRF [RFC6188]     |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa0b385f08c1fec36eaadb97fd584ebb20">AEAD_AES_256_CCM_8</a>           |</div><div class="line">| AEAD authentication tag length | 64 bits                      |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">         Table 10: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa0b385f08c1fec36eaadb97fd584ebb20">AEAD_AES_256_CCM_8</a> Crypto Suite</div><div class="line"></div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 256 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_256_CM_PRF [RFC6188]     |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4a7fb6f702219969093b81a0bf205d69">AEAD_AES_256_CCM_12</a>          |</div><div class="line">| AEAD authentication tag length | 96 bits                      |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">          Table 11: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aa4a7fb6f702219969093b81a0bf205d69">AEAD_AES_256_CCM_12</a> Crypto Suite</div><div class="line"></div><div class="line"></div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Parameter                      | Value                        |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line">| Master key length              | 256 bits                     |</div><div class="line">| Master salt length             | 96 bits                      |</div><div class="line">| Key Derivation Function        | AES_256_CM_PRF [RFC6188]     |</div><div class="line">| Maximum key lifetime (<a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a>)    | 2^48 packets                 |</div><div class="line">| Maximum key lifetime (SRTCP)   | 2^31 packets                 |</div><div class="line">| Cipher (<span class="keywordflow">for</span> <a class="code" href="namespaceProtocolPP.html#a15957f30f5cdc906a54e53fcb4834e5ca19a12da0b094a55286f5772f95ee7a72">SRTP</a> and SRTCP)    | <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aab9bd2280e0c25c38fb7d3a4752c3062f">AEAD_AES_256_CCM</a>             |</div><div class="line">| AEAD authentication tag length | 128 bits                     |     </div><div class="line">+--------------------------------+------------------------------+</div><div class="line"></div><div class="line">           Table 12: The <a class="code" href="namespaceProtocolPP.html#af9de89d351f27b280c94bd76e19ba48aab9bd2280e0c25c38fb7d3a4752c3062f">AEAD_AES_256_CCM</a> Crypto Suite</div></div><!-- fragment --><h2><a class="anchor" id="SRTP_ARIA"></a>
Use of the ARIA Block cipher with SRTP</h2>
<p>ARIA is a general-purpose block cipher algorithm developed by Korean cryptographers in 2003. It is an iterated block cipher with 128-, 192-, and 256-bit keys and encrypts 128-bit blocks in 12, 14, and 16 rounds, depending on the key size. It is secure and suitable for most software and hardware implementations on 32-bit and 8-bit processors. It was established as a Korean standard block cipher algorithm in 2004 [ARIAKS] and has been widely used in Korea, especially for government-to-public services. It was included in PKCS #11 in 2007 [ARIAPKCS]. The algorithm specification and object identifiers are described in [RFC5794].</p>
<p><b>ARIA-CTR</b></p>
<p>Section 4.1.1 of [RFC3711] defines AES-128 counter mode encryption, which it refers to as "AES_CM". Section 2 of [RFC6188] defines "AES_192_CM" and "AES_256_CM" in SRTP. ARIA counter modes are defined in the same manner except that each invocation of AES is replaced by that of ARIA [RFC5794], and are denoted by ARIA_128_CTR, ARIA_192_CTR and ARIA_256_CTR respectively, according to the key lengths. The plaintext inputs to the block cipher are formed as in AES-CTR(AES_CM, AES_192_CM, AES_256_CM) and the block cipher outputs are processed as in AES-CTR. Note that, ARIA-CTR MUST be used only in conjunction with an authentication transform.</p>
<p>Section 3.2 of [RFC6904] defines AES-CTR for SRTP header extension keystream generation. When ARIA-CTR is used, the header extension keystream SHALL be generated in the same manner except that each invocation of AES is replaced by that of ARIA [RFC5794].</p>
<p><b>ARIA-GCM</b></p>
<p>GCM (Galois Counter Mode) [GCM][RFC5116] is an AEAD (Authenticated Encryption with Associated Data) block cipher mode. A detailed description of ARIA-GCM is defined similarly as AES-GCM found in [RFC5116][RFC5282].</p>
<p>The document [I-D.ietf-avtcore-srtp-aes-gcm] describes the use of AES-GCM with SRTP [RFC3711][RFC6904]. The use of ARIA-GCM with SRTP is defined the same as that of AES-GCM except that each invocation of AES is replaced by ARIA [RFC5794]. When [RFC6904] is in use, a separate keystream to encrypt selected RTP header extension elements MUST be generated in the same manner defined in [I-D.ietf-avtcore-srtp-aes-gcm] except that AES-CTR is replaced by ARIA-CTR.</p>
<p><b>Protection Profiles</b></p>
<p>This section defines SRTP Protection Profiles that use the ARIA transforms and key derivation functions defined in this document. The following list indicates the SRTP transform parameters for each protection profile. Those are described for use with DTLS-SRTP [RFC5764].</p>
<p>The parameters cipher_key_length, cipher_salt_length, auth_key_length, and auth_tag_length express the number of bits in the values to which they refer. The maximum_lifetime parameter indicates the maximum number of packets that can be protected with each single set of keys when the parameter profile is in use. All of these parameters apply to both RTP and RTCP, unless the RTCP parameters are separately specified.</p>
<p>SRTP_ARIA_128_CTR_HMAC_SHA1_80</p><ul>
<li>cipher: ARIA_128_CTR</li>
<li>cipher_key_length: 128 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_128_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_ARIA_128_CTR_HMAC_SHA1_32</p><ul>
<li>cipher: ARIA_128_CTR</li>
<li>cipher_key_length: 128 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_128_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>SRTP auth_tag_length: 32 bits</li>
<li>SRTCP auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_ARIA_192_CTR_HMAC_SHA1_80</p><ul>
<li>cipher: ARIA_192_CTR</li>
<li>cipher_key_length: 192 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_192_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_ARIA_192_CTR_HMAC_SHA1_32</p><ul>
<li>cipher: ARIA_192_CTR</li>
<li>cipher_key_length: 192 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_192_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>SRTP auth_tag_length: 32 bits</li>
<li>SRTCP auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_ARIA_256_CTR_HMAC_SHA1_80</p><ul>
<li>cipher: ARIA_256_CTR</li>
<li>cipher_key_length: 256 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_256_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_ARIA_256_CTR_HMAC_SHA1_32</p><ul>
<li>cipher: ARIA_256_CTR</li>
<li>cipher_key_length: 256 bits</li>
<li>cipher_salt_length: 112 bits</li>
<li>key derivation function: ARIA_256_CTR_PRF</li>
<li>auth_function: HMAC-SHA1</li>
<li>auth_key_length: 160 bits</li>
<li>SRTP auth_tag_length: 32 bits</li>
<li>SRTCP auth_tag_length: 80 bits</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_AEAD_ARIA_128_GCM</p><ul>
<li>cipher: ARIA_128_GCM</li>
<li>cipher_key_length: 128 bits</li>
<li>cipher_salt_length: 96 bits</li>
<li>aead_auth_tag_length: 128 bits</li>
<li>auth_function: NULL</li>
<li>auth_key_length: N/A</li>
<li>auth_tag_length: N/A</li>
<li>key derivation function: ARIA_128_CTR_PRF</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>SRTP_AEAD_ARIA_256_GCM</p><ul>
<li>cipher: ARIA_256_GCM</li>
<li>cipher_key_length: 256 bits</li>
<li>cipher_salt_length: 96 bits</li>
<li>aead_auth_tag_length: 128 bits</li>
<li>auth_function: NULL</li>
<li>auth_key_length: N/A</li>
<li>auth_tag_length: N/A</li>
<li>key derivation function: ARIA_256_CTR_PRF</li>
<li>maximum_lifetime: at most <img class="formulaInl" alt="$ {2}^{31}$" src="form_426.png"/> SRTCP packets and at most <img class="formulaInl" alt="$ {2}^{48}$" src="form_427.png"/> SRTP packets</li>
</ul>
<p>The ARIA-CTR protection profiles use the same authentication transform that is mandatory to implement in SRTP, HMAC-SHA1 with a 160-bit key.</p>
<p>Note that SRTP Protection Profiles which use AEAD algorithms do not specify an auth_function, auth_key_length, or auth_tag_length, since they do not use a separate auth_function, auth_key, or auth_tag. The term aead_auth_tag_length is used to emphasize that this refers to the authentication tag provided by the AEAD algorithm and that this tag is not located in the authentication tag field provided by SRTP/SRTCP.</p>
<p>[1] <a href="http://blog.csdn.net/fanbird2008/article/details/18623141">http://blog.csdn.net/fanbird2008/article/details/18623141</a></p>
<p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd>ProtoocolPP::jprotocol </dd>
<dd>
ProtoocolPP::jsrtp </dd>
<dd>
ProtoocolPP::jsrtpsa </dd>
<dd>
ProtoocolPP::jarray </dd>
<dd>
ProtoocolPP::jrand</dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjprotocol.html">jprotocol</a> </dd>
<dd>
<a class="el" href="classjsrtp.html">jsrtp</a> </dd>
<dd>
<a class="el" href="classjsrtpsa.html">jsrtpsa</a> </dd>
<dd>
<a class="el" href="classjarray.html">jarray</a> </dd>
<dd>
<a class="el" href="classjrand.html">jrand</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2022 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="jsrtp_8h_source.html">jsrtp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 4 2022 10:59:30 for Protocol++ (ProtocolPP) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
