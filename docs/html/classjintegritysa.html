<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Protocol++(Protocolpp): jintegritysa Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Protocol++(Protocolpp)
   &#160;<span id="projectnumber">5.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classjintegritysa.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">jintegritysa Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;include/jintegritysa.h&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="MD5ASA"></a>
MD5 Message-Digest Algorithm</h1>
<p>See <a href="https://en.wikipedia.org/wiki/MD5">https://en.wikipedia.org/wiki/MD5</a></p>
<p>The MD5 message-digest algorithm is a widely used hash function producing a 128-bit hash value. Although MD5 was initially designed to be used as a cryptographic hash function, it has been found to suffer from extensive vulnerabilities. It can still be used as a checksum to verify data integrity, but only against unintentional corruption. It remains suitable for other non-cryptographic purposes, for example for determining the partition for a particular key in a partitioned database</p>
<p>MD5 was designed by Ronald Rivest in 1991 to replace an earlier hash function MD4,[4] and was specified in 1992 as RFC 1321</p>
<p>One basic requirement of any cryptographic hash function is that it should be computationally infeasible to find two distinct messages that hash to the same value. MD5 fails this requirement catastrophically; such collisions can be found in seconds on an ordinary home computer</p>
<p>The weaknesses of MD5 have been exploited in the field, most infamously by the Flame malware in 2012. The CMU Software Engineering Institute considers MD5 essentially "cryptographically broken and unsuitable for further use"</p>
<p>As of 2019, MD5 continues to be widely used, in spite of its well-documented weaknesses and deprecation by security experts</p>
<p><b>Security</b></p>
<p>The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 224.1). Further, there is also a chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within seconds, using off-the-shelf computing hardware (complexity 239). The ability to find collisions has been greatly aided by the use of off-the-shelf GPUs. On an NVIDIA GeForce 8400GS graphics processor, 16–18 million hashes per second can be computed. An NVIDIA GeForce 8800 Ultra can calculate more than 200 million hashes per second</p>
<p>These hash and collision attacks have been demonstrated in the public in various situations, including colliding document files and digital certificates. As of 2015, MD5 was demonstrated to be still quite widely used, most notably by security research and antivirus companies</p>
<p>As of 2019, one quarter of widely used content management systems were reported to still use MD5 for password hashing</p>
<p><b>Applications</b></p>
<p>MD5 digests have been widely used in the software world to provide some assurance that a transferred file has arrived intact. For example, file servers often provide a pre-computed MD5 (known as md5sum) checksum for the files, so that a user can compare the checksum of the downloaded file to it. Most unix-based operating systems include MD5 sum utilities in their distribution packages; Windows users may use the included PowerShell function "Get-FileHash", install a Microsoft utility, or use third-party applications. Android ROMs also use this type of checksum.</p>
<div class="image">
<img src="MD5Hashing25.png" alt="MD5Hashing25.png"/>
</div>
 <p>As it is easy to generate MD5 collisions, it is possible for the person who created the file to create a second file with the same checksum, so this technique cannot protect against some forms of malicious tampering. In some cases, the checksum cannot be trusted (for example, if it was obtained over the same channel as the downloaded file), in which case MD5 can only provide error-checking functionality: it will recognize a corrupt or incomplete download, which becomes more likely when downloading larger files</p>
<p>Historically, MD5 has been used to store a one-way hash of a password, often with key stretching. NIST does not include MD5 in their list of recommended hashes for password storage</p>
<p>MD5 is also used in the field of electronic discovery, in order to provide a unique identifier for each document that is exchanged during the legal discovery process. This method can be used to replace the Bates stamp numbering system that has been used for decades during the exchange of paper documents. As above, this usage should be discouraged due to the ease of collision attacks</p>
<p><b>Algorithm</b></p>
<p>MD5 processes a variable-length message into a fixed-length output of 128 bits. The input message is broken up into chunks of 512-bit blocks (sixteen 32-bit words); the message is padded so that its length is divisible by 512. The padding works as follows: first a single bit, 1, is appended to the end of the message. This is followed by as many zeros as are required to bring the length of the message up to 64 bits fewer than a multiple of 512. The remaining bits are filled up with 64 bits representing the length of the original message, modulo <img class="formulaInl" alt="$ {2}^{64} $" src="form_310.png"/></p>
<p>The main MD5 algorithm operates on a 128-bit state, divided into four 32-bit words, denoted <em>A, B, C,</em> and <em>D</em>. These are initialized to certain fixed constants. The main algorithm then uses each 512-bit message block in turn to modify the state. The processing of a message block consists of four similar stages, termed rounds; each round is composed of 16 similar operations based on a non-linear function <em>F</em>, modular addition, and left rotation. The figure below illustrates one operation within a round. There are four possible functions, a different one is used in each round:</p>
<p><img class="formulaInl" alt="$ F(B, C, D) = (B \wedge C) \vee (\neg B \wedge D) $" src="form_311.png"/></p>
<p><img class="formulaInl" alt="$ G(B, C, D) = (B \wedge D) \vee (C \wedge \neg D) $" src="form_312.png"/></p>
<p><img class="formulaInl" alt="$ H(B, C, D) = B \oplus C \oplus D $" src="form_313.png"/></p>
<p><img class="formulaInl" alt="$ I(B, C, D) = C \oplus (B \vee \neg D) $" src="form_314.png"/></p>
<p><img class="formulaInl" alt="$ \oplus, \wedge, \vee, \neg $" src="form_315.png"/> denote the XOR, AND, OR and NOT operations respectively</p>
<div class="image">
<img src="MD5Algorithm25.png" alt="MD5Algorithm25.png"/>
</div>
 <p><b>Pseudocode</b></p>
<p>The MD5 hash is calculated according to this algorithm. All values are in little-endian</p>
<div class="fragment"><div class="line">Note: All variables are <span class="keywordtype">unsigned</span> 32 bit and wrap modulo 2^32 when calculating</div><div class="line">var <span class="keywordtype">int</span>[64] s, K</div><div class="line">var <span class="keywordtype">int</span> i</div><div class="line"></div><div class="line"><span class="comment">//s specifies the per-round shift amounts</span></div><div class="line">s[ 0..15] := { 7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22 }</div><div class="line">s[16..31] := { 5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20 }</div><div class="line">s[32..47] := { 4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23 }</div><div class="line">s[48..63] := { 6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 }</div><div class="line"></div><div class="line"><span class="comment">//Use binary integer part of the sines of integers (Radians) as constants:</span></div><div class="line"><span class="keywordflow">for</span> i from 0 to 63</div><div class="line">    K[i] := floor(232 × abs(sin(i + 1)))</div><div class="line">end for</div><div class="line"><span class="comment">//(Or just use the following precomputed table):</span></div><div class="line">K[ 0.. 3] := { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee }</div><div class="line">K[ 4.. 7] := { 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 }</div><div class="line">K[ 8..11] := { 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be }</div><div class="line">K[12..15] := { 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 }</div><div class="line">K[16..19] := { 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa }</div><div class="line">K[20..23] := { 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 }</div><div class="line">K[24..27] := { 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed }</div><div class="line">K[28..31] := { 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a }</div><div class="line">K[32..35] := { 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c }</div><div class="line">K[36..39] := { 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 }</div><div class="line">K[40..43] := { 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 }</div><div class="line">K[44..47] := { 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 }</div><div class="line">K[48..51] := { 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 }</div><div class="line">K[52..55] := { 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 }</div><div class="line">K[56..59] := { 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 }</div><div class="line">K[60..63] := { 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }</div><div class="line"></div><div class="line"><span class="comment">//Initialize variables:</span></div><div class="line">var <span class="keywordtype">int</span> a0 := 0x67452301   <span class="comment">//A</span></div><div class="line">var <span class="keywordtype">int</span> b0 := 0xefcdab89   <span class="comment">//B</span></div><div class="line">var <span class="keywordtype">int</span> c0 := 0x98badcfe   <span class="comment">//C</span></div><div class="line">var <span class="keywordtype">int</span> d0 := 0x10325476   <span class="comment">//D</span></div><div class="line"></div><div class="line"><span class="comment">//Pre-processing: adding a single 1 bit</span></div><div class="line">append <span class="stringliteral">&quot;1&quot;</span> bit to message    </div><div class="line"><span class="comment">// Notice: the input bytes are considered as bits strings,</span></div><div class="line"><span class="comment">//  where the first bit is the most significant bit of the byte</span></div><div class="line"></div><div class="line"><span class="comment">//Pre-processing: padding with zeros</span></div><div class="line">append <span class="stringliteral">&quot;0&quot;</span> bit until message length in bits ≡ 448 (mod 512)</div><div class="line">append original length in bits mod 264 to message</div><div class="line"></div><div class="line"><span class="comment">//Process the message in successive 512-bit chunks:</span></div><div class="line"><span class="keywordflow">for each</span> 512-bit chunk of padded message</div><div class="line">    <span class="keywordflow">break</span> chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15</div><div class="line">    <span class="comment">//Initialize hash value for this chunk:</span></div><div class="line">    var <span class="keywordtype">int</span> A := a0</div><div class="line">    var <span class="keywordtype">int</span> B := b0</div><div class="line">    var <span class="keywordtype">int</span> C := c0</div><div class="line">    var <span class="keywordtype">int</span> D := d0</div><div class="line">    <span class="comment">//Main loop:</span></div><div class="line">    <span class="keywordflow">for</span> i from 0 to 63</div><div class="line">        var <span class="keywordtype">int</span> F, g</div><div class="line">        <span class="keywordflow">if</span> 0 ≤ i ≤ 15 then</div><div class="line">            F := (B and C) or ((not B) and D)</div><div class="line">            g := i</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> 16 ≤ i ≤ 31 then</div><div class="line">            F := (D and B) or ((not D) and C)</div><div class="line">            g := (5×i + 1) mod 16</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> 32 ≤ i ≤ 47 then</div><div class="line">            F := B xor C xor D</div><div class="line">            g := (3×i + 5) mod 16</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> 48 ≤ i ≤ 63 then</div><div class="line">            F := C xor (B or (not D))</div><div class="line">            g := (7×i) mod 16</div><div class="line">        <span class="comment">//Be wary of the below definitions of a,b,c,d</span></div><div class="line">        F := F + A + K[i] + M[g]  <span class="comment">//M[g] must be a 32-bits block</span></div><div class="line">        A := D</div><div class="line">        D := C</div><div class="line">        C := B</div><div class="line">        B := B + leftrotate(F, s[i])</div><div class="line">    end <span class="keywordflow">for</span></div><div class="line">    <span class="comment">//Add this chunk&#39;s hash to result so far:</span></div><div class="line">    a0 := a0 + A</div><div class="line">    b0 := b0 + B</div><div class="line">    c0 := c0 + C</div><div class="line">    d0 := d0 + D</div><div class="line">end <span class="keywordflow">for</span></div><div class="line"></div><div class="line">var <span class="keywordtype">char</span> digest[16] := a0 append b0 append c0 append d0 <span class="comment">//(Output is in little-endian)</span></div><div class="line"></div><div class="line"><span class="comment">//leftrotate function definition</span></div><div class="line">leftrotate (x, c)</div><div class="line">    <span class="keywordflow">return</span> (x &lt;&lt; c) binary or (x &gt;&gt; (32-c));</div></div><!-- fragment --><p><em>Note: Instead of the formulation from the original RFC 1321 shown, the following may be used for improved efficiency</em> <em>useful if assembly language is being used – otherwise, the compiler will generally optimize the above code. Since each</em> <em>computation is dependent on another in these formulations, this is often slower than the above method where the nand/and</em> <em>can be parallelised):</em> </p><div class="fragment"><div class="line">( 0 ≤ i ≤ 15): F := D xor (B and (C xor D))</div><div class="line">(16 ≤ i ≤ 31): F := C xor (D and (B xor C))</div></div><!-- fragment --><h1><a class="anchor" id="HMACSA"></a>
HMAC-SHA</h1>
<p><b>HMAC-SHA1 generation</b></p>
<p>In cryptography, an HMAC (sometimes expanded as either keyed-hash message authentication code or hash-based message authentication code) is a specific type of message authentication code (MAC) involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message, as with any MAC. Any cryptographic hash function, such as SHA-256 or SHA-3, may be used in the calculation of an HMAC; the resulting MAC algorithm is termed HMAC-X, where X is the hash function used (e.g. HMAC-SHA256 or HMAC-SHA3). The cryptographic strength of the HMAC depends upon the cryptographic strength of the underlying hash function, the size of its hash output, and the size and quality of the key</p>
<p>HMAC uses two passes of hash computation. The secret key is first used to derive two keys–inner and outer. The first pass of the algorithm produces an internal hash derived from the message and the inner key. The second pass produces the final HMAC code derived from the inner hash result and the outer key. Thus the algorithm provides better immunity against length extension attacks</p>
<p>An iterative hash function breaks up a message into blocks of a fixed size and iterates over them with a compression function. For example, SHA-256 operates on 512-bit blocks. The size of the output of HMAC is the same as that of the underlying hash function (e.g., 256 and 1600 bits in the case of SHA-256 and SHA-3, respectively), although it can be truncated if desired</p>
<p>HMAC does not encrypt the message. Instead, the message (encrypted or not) must be sent alongside the HMAC hash. Parties with the secret key will hash the message again themselves, and if it is authentic, the received and computed hashes will match</p>
<p>The definition and analysis of the HMAC construction was first published in 1996 in a paper by Mihir Bellare, Ran Canetti, and Hugo Krawczyk,[1] and they also wrote RFC 2104 in 1997. The 1996 paper also defined a variant called NMAC. FIPS PUB 198 generalizes and standardizes the use of HMACs. HMAC is used within the IPsec and TLS protocols and for JSON Web Token</p>
<p>This definition is taken from RFC 2104:</p>
<p><img class="formulaInl" alt="$ HMAC(K,m) = H(({K}^{'}\oplus opad) \parallel H(({K}^{'}\oplus ipad) \parallel m)) $" src="form_316.png"/></p>
<p><img class="formulaInl" alt="$ {K}^{'} = H(K) - if K is larger than block size$" src="form_317.png"/></p>
<p><img class="formulaInl" alt="$ {K}^{'} = K - otherwise$" src="form_318.png"/></p>
<p>where</p>
<ul>
<li><em>H</em> is a cryptographic hash function</li>
<li><em>m</em> is the message to be authenticated</li>
<li><em>K</em> is a secret key</li>
<li><em>K'</em> is a block-sized key derived from the secret key, K; either by padding to the right with 0s up to the block size, or by hashing down to less than the block size first and then padding to the right with zeros</li>
<li><img class="formulaInl" alt="$ \parallel$" src="form_319.png"/> denotes concatenation</li>
<li><img class="formulaInl" alt="$ \oplus$" src="form_320.png"/> denotes bitwise exclusive or (XOR)</li>
<li><em>opad</em> is the block-sized outer padding, consisting of repeated bytes valued 0x5c</li>
<li><em>ipad</em> is the block-sized inner padding, consisting of repeated bytes valued 0x36</li>
</ul>
<div class="image">
<img src="SHAHmac25.png" alt="SHAHmac25.png"/>
</div>
 <h1><a class="anchor" id="ACMACSA"></a>
AES-CMAC and AES-XCBC-MAC</h1>
<p><b>AES-CMAC and AES-XCBC-MAC Authentication</b></p>
<p>One-key MAC (OMAC) is a message authentication code constructed from a block cipher much like the CBC-MAC algorithm. Officially there are two OMAC algorithms (OMAC1 and OMAC2) which are both essentially the same except for a small tweak. OMAC1 is equivalent to CMAC, which became an NIST recommendation in May 2005</p>
<p>It is free for all uses: it is not covered by any patents.[citation needed] In cryptography, CMAC (Cipher-based Message Authentication Code)[1] is a block cipher-based message authentication code algorithm. It may be used to provide assurance of the authenticity and, hence, the integrity of binary data. This mode of operation fixes security deficiencies of CBC-MAC (CBC-MAC is secure only for fixed-length messages)</p>
<p>The core of the CMAC algorithm is a variation of CBC-MAC that Black and Rogaway proposed and analyzed under the name XCBC and submitted to NIST. The XCBC algorithm efficiently addresses the security deficiencies of CBC-MAC, but requires three keys. Iwata and Kurosawa proposed an improvement of XCBC and named the resulting algorithm One-Key CBC-MAC (OMAC) in their papers. They later submitted OMAC1, a refinement of OMAC, and additional security analysis. The OMAC algorithm reduces the amount of key material required for XCBC. CMAC is equivalent to OMAC1</p>
<div class="image">
<img src="CMACcalc50.png" alt="CMACcalc50.png"/>
</div>
 <p>To generate an l-bit CMAC tag (t) of a message (m) using a b-bit block cipher (E) and a secret key (k), one first generates two b-bit sub-keys (k1 and k2) using the following algorithm (this is equivalent to multiplication by x and x2 in a finite field GF(2b)). Let <img class="formulaInl" alt="$ \ll $" src="form_321.png"/> denote the standard left-shift operator and <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> denote bit-wise exclusive or:</p>
<ol type="1">
<li>Calculate a temporary value k0 = Ek(0)</li>
<li>If msb(k0) = 0, then k1 = k0 <img class="formulaInl" alt="$ \ll $" src="form_321.png"/> 1, else k1 = (k0 <img class="formulaInl" alt="$ \ll $" src="form_321.png"/> 1) <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> C; where C is a certain constant that depends only on b. (Specifically, C is the non-leading coefficients of the lexicographically first irreducible degree-b binary polynomial with the minimal number of ones: 0x1B for 64-bit, 0x87 for 128-bit, and 0x425 for 256-bit blocks)</li>
<li>If msb(k1) = 0, then k2 = k1 <img class="formulaInl" alt="$ \ll $" src="form_321.png"/> 1, else k2 = (k1 <img class="formulaInl" alt="$ \ll $" src="form_321.png"/> 1) <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> C</li>
<li>Return keys (k1, k2) for the MAC generation process</li>
</ol>
<p>As a small example, suppose b = 4, C = 00112, and k0 = Ek(0) = 01012. Then k1 = 10102 and k2 = 0100 ⊕ 0011 = 01112.</p>
<p>The CMAC tag generation process is as follows:</p>
<ol type="1">
<li>Divide message into b-bit blocks m = m1 <img class="formulaInl" alt="$ \parallel $" src="form_322.png"/> ... <img class="formulaInl" alt="$ \parallel $" src="form_322.png"/> mn−1 <img class="formulaInl" alt="$ \parallel $" src="form_322.png"/> mn, where m1, ..., mn−1 are complete blocks. (The empty message is treated as one incomplete block)</li>
<li>If mn is a complete block then mn' = k1 <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> mn else mn' = k2 <img class="formulaInl" alt="$ \oplus $" src="form_5.png"/> (mn <img class="formulaInl" alt="$ \parallel 10...0_2) $" src="form_323.png"/></li>
<li>Let c0 = 00...02</li>
<li>For i = 1,..., n−1, calculate <img class="formulaInl" alt="$ c_i = E_k(c_i−1 \oplus m_i) $" src="form_324.png"/></li>
<li><img class="formulaInl" alt="$ c_n = E_k(c_n−1 \oplus m_n) $" src="form_325.png"/></li>
<li><img class="formulaInl" alt="$ Output t = msb_l(c_n) $" src="form_326.png"/></li>
</ol>
<p>The verification process is as follows:</p>
<ol type="1">
<li>Use the above algorithm to generate the tag</li>
<li>Check that the generated tag is equal to the received tag</li>
</ol>
<h1><a class="anchor" id="SHA3SA"></a>
SHA3-KECCAK</h1>
<p>Secure Hash Algorithm 3 (SHA3) is the latest member of the Secure Hash Algorithm family of standards, released by NIST on August 5, 2015. Although part of the same series of standards, SHA-3 is internally different from the MD5-like structure of SHA-1 and SHA-2.</p>
<p>SHA-3 is a subset of the broader cryptographic primitive family Keccak (/ˈkɛtʃæk, -ɑːk/),[6][7] designed by Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche, building upon RadioGatún. Keccak's authors have proposed additional uses for the function, not (yet) standardized by NIST, including a stream cipher, an authenticated encryption system, a "tree" hashing scheme for faster hashing on certain architectures, and AEAD ciphers Keyak and Ketje</p>
<p>Keccak is based on a novel approach called sponge construction. Sponge construction is based on a wide random function or random permutation, and allows inputting ("absorbing" in sponge terminology) any amount of data, and outputting ("squeezing") any amount of data, while acting as a pseudorandom function with regard to all previous inputs. This leads to great flexibility</p>
<p>NIST does not currently plan to withdraw SHA-2 or remove it from the revised Secure Hash Standard. The purpose of SHA-3 is that it can be directly substituted for SHA-2 in current applications if necessary, and to significantly improve the robustness of NIST's overall hash algorithm toolkit</p>
<p>The creators of the Keccak algorithms and the SHA-3 functions suggest using the faster function KangarooTwelve with adjusted parameters and a new tree hashing mode without extra overhead for small message sizes</p>
<p><b>Design</b></p>
<p>The sponge construction for hash functions. Pi are input, Zi are hashed output. The unused "capacity" c should be twice the desired resistance to collision or preimage attacks</p>
<p>SHA-3 uses the sponge construction, in which data is "absorbed" into the sponge, then the result is "squeezed" out. In the absorbing phase, message blocks are XORed into a subset of the state, which is then transformed as a whole using a permutation function f. In the "squeeze" phase, output blocks are read from the same subset of the state, alternated with the state transformation function f. The size of the part of the state that is written and read is called the "rate" (denoted r), and the size of the part that is untouched by input/output is called the "capacity" (denoted c). The capacity determines the security of the scheme. The maximum security level is half the capacity</p>
<p>Given an input bit string N, a padding function pad, a permutation function f that operates on bit blocks of width b, a rate r and an output length d, we have capacity c = b − r and the sponge construction Z = sponge[f,pad,r](N,d), yielding a bit string Z of length d, works as follows:</p>
<ul>
<li>pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer)</li>
<li>break P into n consecutive r-bit pieces P0, ..., Pn−1</li>
<li>initialize the state S to a string of b zero bits</li>
<li>absorb the input into the state: for each block Pi:<ul>
<li>extend Pi at the end by a string of c zero bits, yielding one of length b</li>
<li>XOR that with S</li>
<li>apply the block permutation f to the result, yielding a new state S</li>
</ul>
</li>
<li>initialize Z to be the empty string</li>
<li>while the length of Z is less than d:<ul>
<li>append the first r bits of S to Z</li>
<li>if Z is still less than d bits long, apply f to S, yielding a new state S</li>
</ul>
</li>
<li>truncate Z to d bits</li>
</ul>
<div class="image">
<img src="SHA3Sponge25.png" alt="SHA3Sponge25.png"/>
</div>
 <p>The fact that the internal state S contains c additional bits of information in addition to what is output to Z prevents the length extension attacks that SHA-2, SHA-1, MD5 and other hashes based on the Merkle–Damgård construction are susceptible to</p>
<p>In SHA-3, the state S consists of a 5 × 5 array of w-bit words (with w=64), b = 5 × 5 × w = 5 × 5 × 64 = 1600 bits total. Keccak is also defined for smaller power-of-2 word sizes w down to 1 bit (total state of 25 bits). Small state sizes can be used to test cryptanalytic attacks, and intermediate state sizes (from w = 8, 200 bits, to w = 32, 800 bits) can be used in practical, lightweight applications</p>
<p>For SHA-3-224, SHA-3-256, SHA-3-384, and SHA-3-512 instances, r is greater than d, so there is no need for additional block permutations in the squeezing phase; the leading d bits of the state are the desired hash. However, SHAKE-128 and SHAKE-256 allow an arbitrary output length, which is useful in applications such as optimal asymmetric encryption padding</p>
<p><b>Padding</b></p>
<p>To ensure the message can be evenly divided into r-bit blocks, padding is required. SHA-3 uses the pattern 10*1 in its padding function: a 1 bit, followed by zero or more 0 bits (maximum r − 1) and a final 1 bit</p>
<p>The maximum of r − 1 zero bits occurs when the last message block is r − 1 bits long. Then another block is added after the initial 1 bit, containing r − 1 zero bits before the final 1 bit</p>
<p>The two 1 bits will be added even if the length of the message is already divisible by r.[24]:5.1 In this case, another block is added to the message, containing a 1 bit, followed by a block of r − 2 zero bits and another 1 bit. This is necessary so that a message with length divisible by r ending in something that looks like padding does not produce the same hash as the message with those bits removed</p>
<p>The initial 1 bit is required so messages differing only in a few additional 0 bits at the end do not produce the same hash</p>
<p>The position of the final 1 bit indicates which rate r was used (multi-rate padding), which is required for the security proof to work for different hash variants. Without it, different hash variants of the same short message would be the same up to truncation</p>
<div class="image">
<img src="SHAComparison50.png" alt="SHAComparison50.png"/>
</div>
 <h1><a class="anchor" id="POLY1305SA"></a>
Poly1305-AES</h1>
<p>Poly1305 is a cryptographic message authentication code (MAC) created by Daniel J. Bernstein. It can be used to verify the data integrity and the authenticity of a message. A variant of Bernstein's Poly1305 that does not require AES has been standardized by the Internet Engineering Task Force in RFC 8439</p>
<p>The original proposal, Poly1305-AES, which uses AES block cipher to expand key, computes a 128-bit (16 bytes) authenticator of a variable-length message, using a 128-bit AES key, a 128-bit additional key (with 106 effective key bits), r, and a 128-bit nonce. The message is broken into 16-byte chunks which become coefficients of a polynomial in r, evaluated modulo the prime number 2130−5. The name is derived from this and the use of 2130−5 and the Advanced Encryption Standard. In NaCl Poly1305 is used with Salsa20 instead of AES, in TLS and SSH it is used with ChaCha20 keystream</p>
<p>Google has selected Poly1305 along with Bernstein's ChaCha20 symmetric cipher as a replacement for RC4 in TLS/SSL, which is used for Internet security. Google's initial implementation is used in securing https (TLS/SSL) traffic between the Chrome browser on Android phones and Google's websites. Use of ChaCha20/Poly1305 has been standardized in RFC 7905</p>
<p>Shortly after Google's adoption for use in TLS, both ChaCha20 and Poly1305 support was added to OpenSSH via the <a href="#" onclick="location.href='mai'+'lto:'+'cha'+'ch'+'a20'+'-p'+'oly'+'13'+'05@'+'op'+'ens'+'sh'+'.co'+'m'; return false;">chach<span style="display: none;">.nosp@m.</span>a20-<span style="display: none;">.nosp@m.</span>poly1<span style="display: none;">.nosp@m.</span>305@<span style="display: none;">.nosp@m.</span>opens<span style="display: none;">.nosp@m.</span>sh.c<span style="display: none;">.nosp@m.</span>om</a> authenticated encryption cipher. Subsequently, this made it possible for OpenSSH to remove its dependency on OpenSSL through a compile-time option</p>
<p><b>Security</b></p>
<p>The security of Poly1305-AES is very close to the underlying AES block cipher algorithm. Consequently, the only way for an attacker to break Poly1305-AES is to break AES</p>
<p>For instance, assuming that messages are packets up to 1024 bytes; that the attacker sees 264 messages authenticated under a Poly1305-AES key; that the attacker attempts a whopping 275 forgeries; and that the attacker cannot break AES with probability above δ; then, with probability at least 0.999999-δ, all the 275 are rejected</p>
<p><b>Speed</b></p>
<p>Poly1305-AES can be computed at high speed in various CPUs: for an n-byte message, no more than 3.1n+780 Athlon cycles are needed, for example. The author has released optimized source code for Athlon, Pentium Pro/II/III/M, PowerPC, and UltraSPARC, in addition to non-optimized reference implementations in C and C++ as public domain software</p>
<h1><a class="anchor" id="CRCSA"></a>
Cycle Redundency Check (CRC)</h1>
<p>A cyclic redundancy check (CRC) is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data. Blocks of data entering these systems get a short check value attached, based on the remainder of a polynomial division of their contents. On retrieval, the calculation is repeated and, in the event the check values do not match, corrective action can be taken against data corruption. CRCs can be used for error correction (see bitfilters)</p>
<p>CRCs are so called because the check (data verification) value is a redundancy (it expands the message without adding information) and the algorithm is based on cyclic codes. CRCs are popular because they are simple to implement in binary hardware, easy to analyze mathematically, and particularly good at detecting common errors caused by noise in transmission channels. Because the check value has a fixed length, the function that generates it is occasionally used as a hash function</p>
<p>The CRC was invented by W. Wesley Peterson in 1961; the 32-bit CRC function, used in Ethernet and many other standards, is the work of several researchers and was published in 1975</p>
<p>CRCs are based on the theory of cyclic error-correcting codes. The use of systematic cyclic codes, which encode messages by adding a fixed-length check value, for the purpose of error detection in communication networks, was first proposed by W. Wesley Peterson in 1961. Cyclic codes are not only simple to implement but have the benefit of being particularly well suited for the detection of burst errors: contiguous sequences of erroneous data symbols in messages. This is important because burst errors are common transmission errors in many communication channels, including magnetic and optical storage devices. Typically an n-bit CRC applied to a data block of arbitrary length will detect any single error burst not longer than n bits, and the fraction of all longer error bursts that it will detect is (1 − 2−n)</p>
<p>Specification of a CRC code requires definition of a so-called generator polynomial. This polynomial becomes the divisor in a polynomial long division, which takes the message as the dividend and in which the quotient is discarded and the remainder becomes the result. The important caveat is that the polynomial coefficients are calculated according to the arithmetic of a finite field, so the addition operation can always be performed bitwise-parallel (there is no carry between digits)</p>
<p>In practice, all commonly used CRCs employ the Galois field of two elements, GF(2). The two elements are usually called 0 and 1, comfortably matching computer architecture</p>
<p>A CRC is called an n-bit CRC when its check value is n bits long. For a given n, multiple CRCs are possible, each with a different polynomial. Such a polynomial has highest degree n, which means it has n + 1 terms. In other words, the polynomial has a length of n + 1; its encoding requires n + 1 bits. Note that most polynomial specifications either drop the MSB or LSB, since they are always 1. The CRC and associated polynomial typically have a name of the form CRC-n-XXX as in the table below</p>
<p>The simplest error-detection system, the parity bit, is in fact a 1-bit CRC: it uses the generator polynomial x + 1 (two terms), and has the name CRC-1</p>
<p><b>Data Integrity</b></p>
<p>CRCs are specifically designed to protect against common types of errors on communication channels, where they can provide quick and reasonable assurance of the integrity of messages delivered. However, they are not suitable for protecting against intentional alteration of data</p>
<p>Firstly, as there is no authentication, an attacker can edit a message and recompute the CRC without the substitution being detected. When stored alongside the data, CRCs and cryptographic hash functions by themselves do not protect against intentional modification of data. Any application that requires protection against such attacks must use cryptographic authentication mechanisms, such as message authentication codes or digital signatures (which are commonly based on cryptographic hash functions)</p>
<p>Secondly, unlike cryptographic hash functions, CRC is an easily reversible function, which makes it unsuitable for use in digital signatures</p>
<p>Thirdly, CRC is a linear function with a property that</p>
<p><img class="formulaInl" alt="$ crc(x \oplus y \oplus z) = crc(x) \oplus crc(y) \oplus crc(z) $" src="form_327.png"/></p>
<p>as a result, even if the CRC is encrypted with a stream cipher that uses XOR as its combining operation (or mode of block cipher which effectively turns it into a stream cipher, such as OFB or CFB), both the message and the associated CRC can be manipulated without knowledge of the encryption key; this was one of the well-known design flaws of the Wired Equivalent Privacy (WEP) protocol</p>
<h1><a class="anchor" id="SM3hashSA"></a>
SM3 Hash Algorithm</h1>
<p>See <a href="https://tools.ietf.org/id/draft-oscca-cfrg-sm3-02.html">https://tools.ietf.org/id/draft-oscca-cfrg-sm3-02.html</a> for more information</p>
<p>SM3 is a cryptographic hash function used in the Chinese National Standard. It was published by the State Cryptography Administration (Chinese: 国家密码管理局) on 2010-12-17[1][2] as "GM/T 0004-2012: SM3 cryptographic hash algorithm"</p>
<p>SM3 is mainly used in digital signatures, message authentication codes, and pseudorandom number generators. The algorithm is public and is claimed by the China Internet Network Information Center to be like SHA-256 in security and efficiency</p>
<h2><a class="anchor" id="INTROSA"></a>
Introduction</h2>
<p>The algorithm described in this document is published ([SM3]) by the Chinese Commercial Cryptography Administration Office. This document gives IETF standard description of these algorithms and parameters</p>
<h2><a class="anchor" id="ALGSA"></a>
Algorithm</h2>
<p>This chatper introduces the algorithm itself. The content and structure strictly follows what is published by the Chinese Commercial Cryptography Administration Office</p>
<h2><a class="anchor" id="SCOPESA"></a>
Scope of SM3</h2>
<p>This document defines SM3 Hash algorithms and gives computing examples. It can be used in commercial cryptography applicaitons like digital signature and verification, message authentication code and verification, and random number generation. This document can also be a technical reference of security product and standards in order to improve the trustworthiness and interoperability of standards</p>
<h2><a class="anchor" id="DEFSA"></a>
Definitions and Terms</h2>
<ul>
<li>Bit String - String composed of 0 and 1</li>
<li>Big-endian - A format that describes the order in which data is stored in computer memory. It defines that the bytes with most significant value are stored at the left and bytes with least significant value are stored at the right. The high digits of a number are stored at high storage address and the low digits of a number are stored at low storage address</li>
<li>Message - Bit string with arbitary length. In this document a message is consider the input of the hash algorithm</li>
<li>Hash Value - The bit string which is the output after the hash algorithm applied to a message. The length of the hash value in this document is 256 bits</li>
<li>Word - A bit string with length 32</li>
</ul>
<h2><a class="anchor" id="ITERSA"></a>
Iteration Procedure</h2>
<p>The procedure is:</p>
<p>Divide the message <img class="formulaInl" alt="$ {M}^{'}$" src="form_328.png"/> after padding into 512 bit blocks:</p>
<p><img class="formulaInl" alt="$ {M}^{'} = B_0, B_1 ... B_{n-1} where n=\frac{l+k+65}{512}$" src="form_329.png"/></p>
<p>Apply iteration operation to <img class="formulaInl" alt="$ {M}^{'}$" src="form_328.png"/> as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} FOR&amp;i=&amp;0..n-1 \\ V(i+1) &amp;=&amp; CF(V(i),B(i)) \\ ENDFOR \end{eqnarray*}" src="form_330.png"/>
</p>
<p>where CF is the compression function, V(0) is a 256 bit of IV[not], B(i) is a message block after padding, and the result after iterative compression is V(n)</p>
<h2><a class="anchor" id="MSGEXTSA"></a>
Message Extension</h2>
<p>Divide the message block B(i) into 32-bit words, then apply the words into the compression function:</p>
<p>a) divide message block B(i) into 16 words <img class="formulaInl" alt="$ W_0, W_1, ... , W_15$" src="form_331.png"/></p>
<p>b) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} FOR&amp;j=&amp;16..67 \\ W_j &amp;=&amp; P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} &lt;&lt;&lt; 15)) \oplus (W_{j-13} &lt;&lt;&lt; 7) \oplus W_{j-6} \\ ENDFOR \\ \end{eqnarray*}" src="form_332.png"/>
</p>
<p>c) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} FOR&amp;j=&amp;0..63 \\ {W}^{'}_j &amp;=&amp; W_j \oplus W_(j+4) \\ ENDFOR \\ \end{eqnarray*}" src="form_333.png"/>
</p>
<h2><a class="anchor" id="COMPFUNCSA"></a>
Compression function</h2>
<ul>
<li>Let A,B,C,D,E,F,G,H be registers to store words</li>
<li>Let SS1, SS2, TT1 and TT2 be intermediate variables</li>
</ul>
<p>The compression function is as follows:</p>
<p><img class="formulaInl" alt="$ V_(i+1) = CF(V(i),B(i)) where 0 A!U i A!U n $" src="form_334.png"/></p>
<p>The computation precedure is as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} ABCDEFGH &amp;=&amp; V(i) \\ FOR &amp; j= &amp;0..63 \\ SS1 &amp;=&amp; (((RK[0] &lt;&lt;&lt; 12) + RK[4] + (T_j &lt;&lt;&lt; j)) &lt;&lt;&lt; 7) \\ SS2 &amp;=&amp; SS1 \oplus (RK[0] &lt;&lt;&lt; 12) \\ TT1 &amp;=&amp; FF_j(RK[0], RK[1], RK[2]) + RK[3] + SS2 + {W}^{'}_j \\ TT1 &amp;=&amp; GG_j(RK[4], RK[5], RK[6]) + RK[7] + SS1 + W_j \\ RK[3] &amp;=&amp; RK[2] \\ RK[2] &amp;=&amp; (RK[1] &lt;&lt;&lt; 9) \\ RK[1] &amp;=&amp; RK[0] \\ RK[0] &amp;=&amp; TT1 \\ RK[7] &amp;=&amp; RK[6] \\ RK[6] &amp;=&amp; (RK[5] &lt;&lt;&lt; 19) \\ RK[5] &amp;=&amp; RK[4] \\ RK[4] &amp;=&amp; P0(TT2) \\ ENDFOR \\ \end{eqnarray*}" src="form_335.png"/>
</p>
<p><img class="formulaInl" alt="$ V(i+1) = ABCDEFGH \oplus V(i)$" src="form_336.png"/></p>
<p>where a word is stored in memory as big-endian format</p>
<h2><a class="anchor" id="SM3HASHVALSA"></a>
Hash Value</h2>
<p><img class="formulaInl" alt="$ ABCDEFGH = V(n)$" src="form_337.png"/></p>
<p>The 256 bits of the hash value is <img class="formulaInl" alt="$ y=ABCDEFGH$" src="form_338.png"/></p>
<p><b>For API Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classProtocolPP_1_1jintegritysa.html">ProtocolPP::jintegritysa</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jsnow3g.html">ProtocolPP::jsnow3g</a> </dd>
<dd>
<a class="el" href="classProtocolPP_1_1jzuc.html">ProtocolPP::jzuc</a></dd></dl>
<p><b>For Additional Documentation:</b> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classjintegrity.html">jintegrity</a> </dd>
<dd>
<a class="el" href="classjintegritysa.html">jintegritysa</a> </dd>
<dd>
<a class="el" href="classjsnow3g.html">jsnow3g</a> </dd>
<dd>
<a class="el" href="classjzuc.html">jzuc</a></dd></dl>
<center>Protocol++&reg; (<a class="el" href="namespaceProtocolPP.html">ProtocolPP</a>&reg;) written by : John Peter Greninger &bull; &copy; John Peter Greninger 2015-2022 &bull; All Rights Reserved</center> <center><sub>All copyrights and trademarks are the property of their respective owners</sub></center><p>The source code contained or described herein and all documents related to the source code (herein called "Material") are owned by John Peter Greninger and Sheila Rocha Greninger. Title to the Material remains with John Peter Greninger and Sheila Rocha Greninger. The Material contains trade secrets and proprietary and confidential information of John Peter Greninger and Sheila Rocha Greninger. The Material is protected by worldwide copyright and trade secret laws and treaty provisions. No part of the Material may be used, copied, reproduced, modified, published, uploaded, posted, transmitted, distributed, or disclosed in any way without prior express written consent of John Peter Greninger and Sheila Rocha Greninger (both are required)</p>
<p>No license under any patent, copyright, trade secret, or other intellectual property right is granted to or conferred upon you by disclosure or delivery of the Materials, either expressly, by implication, inducement, estoppel, or otherwise. Any license under such intellectual property rights must be express and approved by John Peter Greninger and Sheila Rocha Greninger in writing</p>
<p>Licensing information can be found at <b>www.protocolpp.com/license</b> with use of the binary forms permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li>
<li>Any and all modifications must be returned to John Peter Greninger at GitHub.com <a href="https://github.com/jpgreninger/protocolpp">https://github.com/jpgreninger/protocolpp</a> for evaluation. Inclusion of modifications in the source code shall be determined solely by John Peter Greninger. Failure to provide modifications shall render this license NULL and VOID and revoke any rights to use of Protocol++&reg;</li>
<li>Commercial use (incidental or not) requires a fee-based license obtainable at <b>www.protocolpp.com/shop</b></li>
<li>Academic or research use requires prior written and notarized permission from John Peter and Sheila Rocha Greninger</li>
</ul>
<p>Use of the source code requires purchase of the source code. Source code can be purchased at <b>www.protocolpp.com/shop</b></p>
<ul>
<li><b>US Copyrights at <a href="https://www.copyright.gov/">https://www.copyright.gov/</a></b><ul>
<li><b>TXu002059872 (Version 1.0.0)</b></li>
<li><b>TXu002066632 (Version 1.2.7)</b></li>
<li><b>TXu002082674 (Version 1.4.0)</b></li>
<li><b>TXu002097880 (Version 2.0.0)</b></li>
<li><b>TXu002169236 (Version 3.0.1)</b></li>
<li><b>TXu002182417 (Version 4.0.0)</b></li>
<li><b>TXu002219402 (Version 5.0.0)</b></li>
<li><b>TXu002272076 (Version 5.2.1)</b></li>
</ul>
</li>
</ul>
<p>The name of its contributor may not be used to endorse or promote products derived from this software without specific prior written permission and licensing</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jintegritysa.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classjintegritysa.html">jintegritysa</a></li>
    <li class="footer">Generated on Mon Jul 25 2022 21:13:22 for Protocol++(Protocolpp) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
